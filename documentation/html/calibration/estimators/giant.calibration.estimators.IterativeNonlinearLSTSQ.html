
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>giant.calibration.estimators.IterativeNonlinearLSTSQ &#8212; GIANT 1.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="shortcut icon" href="../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="copyright" title="Copyright" href="../../copyright.html" />
    <link rel="next" title="IterativeNonlinearLSTSQ.compute_residuals" href="giant.calibration.estimators.IterativeNonlinearLSTSQ.compute_residuals.html" />
    <link rel="prev" title="CalibrationEstimator.reset" href="giant.calibration.estimators.CalibrationEstimator.reset.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../index.html">
    <img class="logo" src="../../_static/logo.png" alt="Logo"/>
    
  </a>
</p>



<p class="blurb">A powerful API for Optical Navigation</p>






<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installing GIANT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../giant.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../giant.html#indices">Indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../copyright.html">Copyright</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../../giant.html">API Reference</a><ul>
  <li><a href="../../giant.calibration.html">giant.calibration</a><ul>
  <li><a href="../giant.calibration.estimators.html">giant.calibration.estimators</a><ul>
      <li>Previous: <a href="giant.calibration.estimators.CalibrationEstimator.reset.html" title="previous chapter">CalibrationEstimator.reset</a></li>
      <li>Next: <a href="giant.calibration.estimators.IterativeNonlinearLSTSQ.compute_residuals.html" title="next chapter">IterativeNonlinearLSTSQ.compute_residuals</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="giant.calibration.estimators.CalibrationEstimator.reset.html" title="Previous document">CalibrationEstimator.reset</a>
        </li>
        <li>
          <a href="giant.calibration.estimators.IterativeNonlinearLSTSQ.compute_residuals.html" title="Next document">IterativeNonlinearLSTSQ.compute_residuals</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <section id="giant-calibration-estimators-iterativenonlinearlstsq">
<h1>giant.calibration.estimators.IterativeNonlinearLSTSQ<a class="headerlink" href="#giant-calibration-estimators-iterativenonlinearlstsq" title="Permalink to this headline">¶</a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="giant.calibration.estimators.IterativeNonlinearLSTSQ">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">giant.calibration.estimators.</span></span><span class="sig-name descname"><span class="pre">IterativeNonlinearLSTSQ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighted_estimation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residual_atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residual_rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state_atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state_rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurements</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">camera_frame_directions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_covariance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_priori_state_covariance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperatures</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/giant/calibration/estimators.html#IterativeNonlinearLSTSQ"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ" title="Permalink to this definition">¶</a></dt>
<dd><p>This concrete estimator implements iterative non-linear least squares for estimating an updated camera model.</p>
<p>Iterative non-linear least squares estimation is done by estimating updates to the “state” vector (in this case the
camera model parameters being updated) iteratively.  At each step, the system is linearized about the current
estimate of the state and the additive update is estimated.  This iteration is repeated until convergence (or
divergence) based on the pre/post update residuals and the update vector itself.</p>
<p>The state vector that is being estimated by this class is controlled by the
<a class="reference internal" href="../../camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel.estimation_parameters" title="giant.camera_models.camera_model.CameraModel.estimation_parameters"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CameraModel.estimation_parameters</span></code></a> attribute of the provided camera model.  This class does not actually use
the <a class="reference internal" href="../../camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel.estimation_parameters" title="giant.camera_models.camera_model.CameraModel.estimation_parameters"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CameraModel.estimation_parameters</span></code></a> attribute since it is handled by the
<a class="reference internal" href="../../camera_model/giant.camera_models.camera_model.CameraModel.compute_jacobian.html#giant.camera_models.camera_model.CameraModel.compute_jacobian" title="giant.camera_models.camera_model.CameraModel.compute_jacobian"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CameraModel.compute_jacobian()</span></code></a> and <a class="reference internal" href="../../camera_model/giant.camera_models.camera_model.CameraModel.apply_update.html#giant.camera_models.camera_model.CameraModel.apply_update" title="giant.camera_models.camera_model.CameraModel.apply_update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CameraModel.apply_update()</span></code></a> methods of the provided camera model
internally, but it is mentioned here to show how to control what exactly is being estimated.</p>
<p>Because this class linearizes about the current estimate of the state, it requires an initial guess for the camera
model that is “close enough” to the actual model to ensure convergence.  Defining “close enough” in any broad sense
is impossible, but based on experience, using the manufacturer defined specs for focal length/pixel pitch and
assuming no distortion is generally “close enough” even for cameras with heavy distortion (star identification may
require a better initial model than this anyway).</p>
<p>As this class converges the state estimate, it updates the supplied camera model in place, therefore, if you wish to
keep a copy of the original camera model, you should manually create a copy of it before calling the
<a class="reference internal" href="giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate.html#giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a> method on this class.</p>
<p>In the <a class="reference internal" href="giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate.html#giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a> method, convergence is checked on both the sum of squares of the residuals and the update
vector for the state.  That is convergence is reached when either of</p>
<div class="math notranslate nohighlight">
\begin{gather*}
\left\|\mathbf{r}_{pre}^T\mathbf{r}_{pre} - \mathbf{r}_{post}^T\mathbf{r}_{post}\right\|
\le(a_r+r_r\mathbf{r}_{pre}^T\mathbf{r}_{pre}) \\
\text{all}\left[\left\|\mathbf{u}\right\|\le(a_s+r_s\mathbf{s}_{pre})\right]
\end{gather*}</div><p>is <code class="docutils literal notranslate"><span class="pre">True</span></code>. Here <span class="math notranslate nohighlight">\(\mathbf{r}_{pre}\)</span> is the nx1 vector of residuals before the update is applied,
<span class="math notranslate nohighlight">\(\mathbf{r}_{post}\)</span> is the nx1 vector of residuals after the update is applied, <span class="math notranslate nohighlight">\(a_r\)</span> is the
<a class="reference internal" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.residual_atol" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.residual_atol"><code class="xref py py-attr docutils literal notranslate"><span class="pre">residual_atol</span></code></a> absolute residual tolerance, <span class="math notranslate nohighlight">\(r_r\)</span> is the <a class="reference internal" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.residual_rtol" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.residual_rtol"><code class="xref py py-attr docutils literal notranslate"><span class="pre">residual_rtol</span></code></a> relative residual
tolerance, <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> is the update vector, <span class="math notranslate nohighlight">\(\text{all}\)</span> indicates that the contained expression is
<code class="docutils literal notranslate"><span class="pre">True</span></code> for all elements, <span class="math notranslate nohighlight">\(a_s\)</span> is the <a class="reference internal" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.state_atol" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.state_atol"><code class="xref py py-attr docutils literal notranslate"><span class="pre">state_atol</span></code></a> absolute tolerance for the state vector,
<span class="math notranslate nohighlight">\(r_s\)</span> is the <a class="reference internal" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.state_rtol" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.state_rtol"><code class="xref py py-attr docutils literal notranslate"><span class="pre">state_rtol</span></code></a> relative tolerance for the state vector, and <span class="math notranslate nohighlight">\(\mathbf{s}_{pre}\)</span> is the
state vector before the update is applied.  Divergence is only checked on the sum of squares of the residuals, that
is, divergence is occurring when</p>
<div class="math notranslate nohighlight">
\[\mathbf{r}_{pre}^T\mathbf{r}_{pre} &lt; \mathbf{r}_{post}^T\mathbf{r}_{post}\]</div>
<p>where all is as defined as before.  If a case is diverging then a warning will be printed, the iteration will cease,
and <a class="reference internal" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.successful" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.successful"><code class="xref py py-attr docutils literal notranslate"><span class="pre">successful</span></code></a> will be set to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>Typically this class is not used by the user, and instead it is used internally by the <a class="reference internal" href="../calibration_class/giant.calibration.calibration_class.Calibration.html#giant.calibration.calibration_class.Calibration" title="giant.calibration.calibration_class.Calibration"><code class="xref py py-class docutils literal notranslate"><span class="pre">Calibration</span></code></a> class
which handles data preparation for you. If you wish to use this externally from the <a class="reference internal" href="../calibration_class/giant.calibration.calibration_class.Calibration.html#giant.calibration.calibration_class.Calibration" title="giant.calibration.calibration_class.Calibration"><code class="xref py py-class docutils literal notranslate"><span class="pre">Calibration</span></code></a> class you
must first set</p>
<ul class="simple">
<li><p><a class="reference internal" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.model" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.model"><code class="xref py py-attr docutils literal notranslate"><span class="pre">model</span></code></a></p></li>
<li><p><a class="reference internal" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.measurements" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.measurements"><code class="xref py py-attr docutils literal notranslate"><span class="pre">measurements</span></code></a></p></li>
<li><p><a class="reference internal" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.camera_frame_directions" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.camera_frame_directions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">camera_frame_directions</span></code></a></p></li>
<li><p><a class="reference internal" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.temperatures" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.temperatures"><code class="xref py py-attr docutils literal notranslate"><span class="pre">temperatures</span></code></a></p></li>
<li><p><a class="reference internal" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.weighted_estimation" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.weighted_estimation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">weighted_estimation</span></code></a></p></li>
<li><p><a class="reference internal" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.measurement_covariance" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.measurement_covariance"><code class="xref py py-attr docutils literal notranslate"><span class="pre">measurement_covariance</span></code></a> <em>if</em> <a class="reference internal" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.weighted_estimation" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.weighted_estimation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">weighted_estimation</span></code></a> <em>is</em> <code class="docutils literal notranslate"><span class="pre">True</span></code></p></li>
<li><p><a class="reference internal" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.a_priori_state_covariance" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.a_priori_state_covariance"><code class="xref py py-attr docutils literal notranslate"><span class="pre">a_priori_state_covariance</span></code></a> <em>if</em> <a class="reference internal" href="../../camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel.use_a_priori" title="giant.camera_models.camera_model.CameraModel.use_a_priori"><code class="xref py py-attr docutils literal notranslate"><span class="pre">use_a_priori</span></code></a> <em>is set to</em> <code class="docutils literal notranslate"><span class="pre">True</span></code> for the camera
model.</p></li>
</ul>
<p>according to their documentation.  Once those have been set, you can perform the estimation using <a class="reference internal" href="giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate.html#giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a>
which will iterate until convergence (or divergence).  If the fit successfully converges, <a class="reference internal" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.successful" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.successful"><code class="xref py py-attr docutils literal notranslate"><span class="pre">successful</span></code></a> will be
set to <code class="docutils literal notranslate"><span class="pre">True</span></code> and attributes <a class="reference internal" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.postfit_covariance" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.postfit_covariance"><code class="xref py py-attr docutils literal notranslate"><span class="pre">postfit_covariance</span></code></a> and <a class="reference internal" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.postfit_residuals" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.postfit_residuals"><code class="xref py py-attr docutils literal notranslate"><span class="pre">postfit_residuals</span></code></a> will both return numpy
arrays instead of <code class="docutils literal notranslate"><span class="pre">None</span></code>.  If you wish to use the same instance of this class to do another estimation you should
call <a class="reference internal" href="giant.calibration.estimators.IterativeNonlinearLSTSQ.reset.html#giant.calibration.estimators.IterativeNonlinearLSTSQ.reset" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.reset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reset()</span></code></a> before setting the new data to ensure that data is not mixed between estimation runs and all
flags are set correctly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="../../camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel" title="giant.camera_models.camera_model.CameraModel"><em>giant.camera_models.camera_model.CameraModel</em></a><em>]</em>) – The camera model instance to be estimated set with an initial guess of the state.</p></li>
<li><p><strong>weighted_estimation</strong> (<em>bool</em>) – A boolean flag specifying whether to do weighted estimation.  <code class="docutils literal notranslate"><span class="pre">True</span></code> indicates
that the measurement weights (and a priori state covariance if applicable) should be
used in the estimation.</p></li>
<li><p><strong>max_iter</strong> (<em>int</em>) – The maximum number of iteration steps to attempt to reach convergence.  If convergence has not
been reached after attempting <code class="docutils literal notranslate"><span class="pre">max_iter</span></code> steps, a warning will be raised that the model has
not converged and <a class="reference internal" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.successful" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.successful"><code class="xref py py-attr docutils literal notranslate"><span class="pre">successful</span></code></a> will be set to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><strong>residual_atol</strong> (<em>float</em>) – The absolute convergence tolerance criteria for the sum of squares of the residuals</p></li>
<li><p><strong>residual_rtol</strong> (<em>float</em>) – The relative convergence tolerance criteria for the sum of squares of the residuals</p></li>
<li><p><strong>state_atol</strong> (<em>float</em>) – The absolute convergence tolerance criteria for the elements of the state vector</p></li>
<li><p><strong>state_rtol</strong> (<em>float</em>) – The relative convergence tolerance criteria for the elements of the state vector</p></li>
<li><p><strong>measurements</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>Sequence</em><em>, </em><em>numpy.ndarray</em><em>]</em><em>]</em>) – A 2xn numpy array of measurement pixel locations to be fit to</p></li>
<li><p><strong>camera_frame_directions</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Union</em><em>[</em><em>numpy.ndarray</em><em>, </em><em>List</em><em>[</em><em>List</em><em>]</em><em>]</em><em>]</em><em>]</em>) – A length m list of 3xj numpy arrays or empty 3x1 list of empty lists where m is
the number of unique images the data comes from (and is the same length as
<a class="reference internal" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.temperatures" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.temperatures"><code class="xref py py-attr docutils literal notranslate"><span class="pre">temperatures</span></code></a>) and j is the number of measurements from each image.  A
list of empty lists indicates that no measurements were identified for the
corresponding image.</p></li>
<li><p><strong>measurement_covariance</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>Sequence</em><em>, </em><em>numpy.ndarray</em><em>, </em><em>numbers.Real</em><em>]</em><em>]</em>) – An optional nxn numpy array containing the covariance matrix for the ravelled
measurement vector (in fortran order such that the ravelled measurement vector is
[x1, y1, x2, y2, … xk, yk] where k=n//2)</p></li>
<li><p><strong>a_priori_state_covariance</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>Sequence</em><em>, </em><em>numpy.ndarray</em><em>]</em><em>]</em>) – An optional lxl numpy array containing the a priori covariance matrix for the
a priori estimate of the state, where l is the number of parameters in the
state vector.  This is used only if <a class="reference internal" href="../../camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel.use_a_priori" title="giant.camera_models.camera_model.CameraModel.use_a_priori"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CameraModel.use_a_priori</span></code></a> is set
to <code class="docutils literal notranslate"><span class="pre">True</span></code>.  The length of the state vector can be determined by
<code class="docutils literal notranslate"><span class="pre">len(</span></code><a class="reference internal" href="../../camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel.state_vector" title="giant.camera_models.camera_model.CameraModel.state_vector"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CameraModel.state_vector</span></code></a><code class="docutils literal notranslate"><span class="pre">)</span></code></p></li>
<li><p><strong>temperatures</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>numbers.Real</em><em>]</em><em>]</em>) – A length m list of floats containing the camera temperature at the time of each
corresponding image.  These may be used by the <a class="reference internal" href="../../camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel" title="giant.camera_models.camera_model.CameraModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CameraModel</span></code></a> to perform temperature
dependent estimation of parameters like the focal length, depending on what is set for
<a class="reference internal" href="../../camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel.estimation_parameters" title="giant.camera_models.camera_model.CameraModel.estimation_parameters"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CameraModel.estimation_parameters</span></code></a></p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.estimators.IterativeNonlinearLSTSQ.max_iter">
<span class="sig-name descname"><span class="pre">max_iter</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.max_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum number of iteration steps to attempt for convergence</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.estimators.IterativeNonlinearLSTSQ.residual_atol">
<span class="sig-name descname"><span class="pre">residual_atol</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.residual_atol" title="Permalink to this definition">¶</a></dt>
<dd><p>The absolute tolerance for the sum of square of the residuals to indicate convergence</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.estimators.IterativeNonlinearLSTSQ.residual_rtol">
<span class="sig-name descname"><span class="pre">residual_rtol</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.residual_rtol" title="Permalink to this definition">¶</a></dt>
<dd><p>The relative tolerance for the sum of square of the residuals to indicate convergence</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.estimators.IterativeNonlinearLSTSQ.state_atol">
<span class="sig-name descname"><span class="pre">state_atol</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.state_atol" title="Permalink to this definition">¶</a></dt>
<dd><p>The absolute tolerance for the state vector to indicate convergence</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.estimators.IterativeNonlinearLSTSQ.state_rtol">
<span class="sig-name descname"><span class="pre">state_rtol</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.state_rtol" title="Permalink to this definition">¶</a></dt>
<dd><p>The relative tolerance for the state vector to indicate convergence</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.estimators.IterativeNonlinearLSTSQ.model">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">model</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../../camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel" title="giant.camera_models.camera_model.CameraModel"><span class="pre">giant.camera_models.camera_model.CameraModel</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.model" title="Permalink to this definition">¶</a></dt>
<dd><p>The camera model that is being estimated.</p>
<p>Typically this should be a subclass of <a class="reference internal" href="../../camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel" title="giant.camera_models.camera_model.CameraModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CameraModel</span></code></a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.estimators.IterativeNonlinearLSTSQ.successful">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">successful</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.successful" title="Permalink to this definition">¶</a></dt>
<dd><p>A boolean flag indicating whether the fit was successful or not.</p>
<p>If the fit was successful this should return <code class="docutils literal notranslate"><span class="pre">True</span></code>, and <code class="docutils literal notranslate"><span class="pre">False</span></code> if otherwise.  A fit is defined as
successful if convergence criteria were reached before the maximum number of iterations.  Divergence and
non-convergence are both considered an unsuccessful fit resulting in this being set to <code class="docutils literal notranslate"><span class="pre">False</span></code></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.estimators.IterativeNonlinearLSTSQ.weighted_estimation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">weighted_estimation</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.weighted_estimation" title="Permalink to this definition">¶</a></dt>
<dd><p>A boolean flag specifying whether to do weighted estimation.</p>
<p>If set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, the estimator will use the provided measurement weights in <a class="reference internal" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.measurement_covariance" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.measurement_covariance"><code class="xref py py-attr docutils literal notranslate"><span class="pre">measurement_covariance</span></code></a>
during the estimation process.  If set to <code class="docutils literal notranslate"><span class="pre">False</span></code>, then no measurement weights will be considered.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.estimators.IterativeNonlinearLSTSQ.measurement_covariance">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">measurement_covariance</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numbers.Real</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.measurement_covariance" title="Permalink to this definition">¶</a></dt>
<dd><p>A square numpy array containing the covariance matrix for the measurements or a scalar containing the variance
for all of the measurements.</p>
<p>If <a class="reference internal" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.weighted_estimation" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.weighted_estimation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">weighted_estimation</span></code></a> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> then this property will contain the measurement covariance
matrix as a square, full rank, numpy array or the measurement variance as a scalar float.  If
<a class="reference internal" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.weighted_estimation" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.weighted_estimation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">weighted_estimation</span></code></a> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code> then this property may be <code class="docutils literal notranslate"><span class="pre">None</span></code> and will be ignored.</p>
<p>If specified as a scalar, it is treated as the <strong>variance</strong> for each measurement (that is <code class="docutils literal notranslate"><span class="pre">cov</span> <span class="pre">=</span> <span class="pre">v*I(n,n)</span></code>
where <code class="docutils literal notranslate"><span class="pre">cov</span></code> is the covariance matrix, <code class="docutils literal notranslate"><span class="pre">v</span></code> is the specified scalar variance, and <code class="docutils literal notranslate"><span class="pre">I(n,n)</span></code> is a nxn identity
matrix) in a memory efficient way.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – When attempting to set an array that does not have the proper shape for the
<a class="reference internal" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.measurements" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.measurements"><code class="xref py py-attr docutils literal notranslate"><span class="pre">measurements</span></code></a> vector</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.estimators.IterativeNonlinearLSTSQ.a_priori_state_covariance">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">a_priori_state_covariance</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.a_priori_state_covariance" title="Permalink to this definition">¶</a></dt>
<dd><p>A square numpy array containing the covariance matrix for the a priori estimate of the state vector.</p>
<p>This is only considered if <a class="reference internal" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.weighted_estimation" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.weighted_estimation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">weighted_estimation</span></code></a> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> and if
<a class="reference internal" href="../../camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel.use_a_priori" title="giant.camera_models.camera_model.CameraModel.use_a_priori"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CameraModel.use_a_priori</span></code></a> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, otherwise it is ignored.  If both are set to <code class="docutils literal notranslate"><span class="pre">True</span></code> then
this should be set to a square, full rank, lxl numpy array where <code class="docutils literal notranslate"><span class="pre">l=len(model.state_vector)</span></code> containing the
covariance matrix for the a priori state vector.  The order of the parameters in the state vector can be
determined from <a class="reference internal" href="../../camera_model/giant.camera_models.camera_model.CameraModel.get_state_labels.html#giant.camera_models.camera_model.CameraModel.get_state_labels" title="giant.camera_models.camera_model.CameraModel.get_state_labels"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CameraModel.get_state_labels()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the shape of the input matrix is not appropriate for the size of the state vector</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.estimators.IterativeNonlinearLSTSQ.measurements">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">measurements</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.measurements" title="Permalink to this definition">¶</a></dt>
<dd><p>A nx2 numpy array of the observed pixel locations for stars across all images</p>
<p>Each column of this array corresponds to the same column of the <a class="reference internal" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.camera_frame_directions" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.camera_frame_directions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">camera_frame_directions</span></code></a> concatenated
down the last axis. (That is <code class="docutils literal notranslate"><span class="pre">measurements[:,</span> <span class="pre">i]</span> <span class="pre">&lt;-&gt;</span> <span class="pre">np.concatenate(camera_frame_directions,</span> <span class="pre">axis=-1)[:,</span> <span class="pre">i]</span></code>)</p>
<p>This must always be set before a call to <a class="reference internal" href="giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate.html#giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.estimators.IterativeNonlinearLSTSQ.camera_frame_directions">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">camera_frame_directions</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.camera_frame_directions" title="Permalink to this definition">¶</a></dt>
<dd><p>A length m list of unit vectors in the camera frame as numpy arrays for m images corresponding to the
<a class="reference internal" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.measurements" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.measurements"><code class="xref py py-attr docutils literal notranslate"><span class="pre">measurements</span></code></a> attribute.</p>
<p>Each element of this list corresponds to a unique image that is being considered for estimation and the
subsequent element in the <a class="reference internal" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.temperatures" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.temperatures"><code class="xref py py-attr docutils literal notranslate"><span class="pre">temperatures</span></code></a> list. Each column of this concatenated array will correspond to
the same column of the <a class="reference internal" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.measurements" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.measurements"><code class="xref py py-attr docutils literal notranslate"><span class="pre">measurements</span></code></a> array. (That is
<code class="docutils literal notranslate"><span class="pre">np.concatenate(camera_frame_directions,</span> <span class="pre">axis=-1)[:,</span> <span class="pre">i]</span> <span class="pre">&lt;-&gt;</span> <span class="pre">measurements[:,</span> <span class="pre">i]</span></code>).</p>
<p>Any images for which no stars were identified (due to any number of reasons) will have a list of empty arrays in
the corresponding element of this list (that is <code class="docutils literal notranslate"><span class="pre">camera_frame_directions[i]</span> <span class="pre">==</span> <span class="pre">[[],</span> <span class="pre">[],</span> <span class="pre">[]]</span></code> where <code class="docutils literal notranslate"><span class="pre">i</span></code> is an
image with no measurements identified).  These will be automatically dropped by numpy’s concatenate, but are
included to notify the which temperatures/misalignments to use.</p>
<p>This must always be set before a call to <a class="reference internal" href="giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate.html#giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.estimators.IterativeNonlinearLSTSQ.temperatures">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">temperatures</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">numbers.Real</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.temperatures" title="Permalink to this definition">¶</a></dt>
<dd><p>A length m list of temperatures of the camera for each image being considered in estimation.</p>
<p>Each element of this list corresponds to a unique image that is being considered for estimation and the
subsequent element in the <a class="reference internal" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.camera_frame_directions" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.camera_frame_directions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">camera_frame_directions</span></code></a> list.</p>
<p>This must always be set before a call to <a class="reference internal" href="giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate.html#giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a> (although sometimes it may be a list of all zeros if
temperature data is not available for the camera).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.estimators.IterativeNonlinearLSTSQ.postfit_covariance">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">postfit_covariance</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.postfit_covariance" title="Permalink to this definition">¶</a></dt>
<dd><p>The post-fit state covariance matrix, taking into account the measurement covariance matrix (if applicable).</p>
<p>This returns the post-fit state covariance matrix after a call to <a class="reference internal" href="giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate.html#giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a>.  The covariance matrix will
be in the order according to <a class="reference internal" href="../../camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel.estimation_parameters" title="giant.camera_models.camera_model.CameraModel.estimation_parameters"><code class="xref py py-attr docutils literal notranslate"><span class="pre">estimation_parameters</span></code></a> and if <a class="reference internal" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.weighted_estimation" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.weighted_estimation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">weighted_estimation</span></code></a> is
<code class="docutils literal notranslate"><span class="pre">True</span></code> will return the state covariance matrix taking into account the measurement covariance matrix.  If
<a class="reference internal" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.weighted_estimation" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.weighted_estimation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">weighted_estimation</span></code></a> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, then this will return the post-fit state covariance matrix assuming no
measurement weighting (that is a measurement covariance matrix of the identity matrix).  If <a class="reference internal" href="giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate.html#giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a>
has not been called yet or the fit was unsuccessful then this will return <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.estimators.IterativeNonlinearLSTSQ.postfit_residuals">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">postfit_residuals</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.estimators.IterativeNonlinearLSTSQ.postfit_residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>The post-fit observed-computed measurement residuals as a 2xn numpy array.</p>
<p>This returns the post-fit observed minus computed measurement residuals after a call to <a class="reference internal" href="giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate.html#giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a>.  If
<a class="reference internal" href="giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate.html#giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a> has not been called yet or the fit was unsuccessful then this will return <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

</dd></dl>

<p class="rubric">Summary of Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="giant.calibration.estimators.IterativeNonlinearLSTSQ.compute_residuals.html#giant.calibration.estimators.IterativeNonlinearLSTSQ.compute_residuals" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.compute_residuals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_residuals</span></code></a></p></td>
<td><p>This method computes the observed minus computed residuals for the current model (or an input model).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate.html#giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.estimate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate</span></code></a></p></td>
<td><p>Estimates an updated camera model that better transforms the camera frame directions into pixel locations to minimize the residuals between the observed and the predicted star locations.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="giant.calibration.estimators.IterativeNonlinearLSTSQ.reset.html#giant.calibration.estimators.IterativeNonlinearLSTSQ.reset" title="giant.calibration.estimators.IterativeNonlinearLSTSQ.reset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset</span></code></a></p></td>
<td><p>This method resets all of the data attributes to their default values to prepare for another estimation.</p></td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="giant.calibration.estimators.CalibrationEstimator.reset.html" title="Previous document">CalibrationEstimator.reset</a>
        </li>
        <li>
          <a href="giant.calibration.estimators.IterativeNonlinearLSTSQ.compute_residuals.html" title="Next document">IterativeNonlinearLSTSQ.compute_residuals</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2021 United States Government.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.3.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/calibration/estimators/giant.calibration.estimators.IterativeNonlinearLSTSQ.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>