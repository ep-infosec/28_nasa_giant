
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>giant.calibration.estimators.LMAEstimator &#8212; GIANT 1.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="copyright" title="Copyright" href="../../copyright.html" />
    <link rel="next" title="LMAEstimator.compute_residuals" href="giant.calibration.estimators.LMAEstimator.compute_residuals.html" />
    <link rel="prev" title="IterativeNonlinearLSTSQ.reset" href="giant.calibration.estimators.IterativeNonlinearLSTSQ.reset.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../index.html">
    <img class="logo" src="../../_static/logo.png" alt="Logo"/>
    
  </a>
</p>



<p class="blurb">A powerful API for Optical Navigation</p>






<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installing GIANT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../giant.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../giant.html#indices">Indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../copyright.html">Copyright</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../../giant.html">API Reference</a><ul>
  <li><a href="../../giant.calibration.html">giant.calibration</a><ul>
  <li><a href="../giant.calibration.estimators.html">giant.calibration.estimators</a><ul>
      <li>Previous: <a href="giant.calibration.estimators.IterativeNonlinearLSTSQ.reset.html" title="previous chapter">IterativeNonlinearLSTSQ.reset</a></li>
      <li>Next: <a href="giant.calibration.estimators.LMAEstimator.compute_residuals.html" title="next chapter">LMAEstimator.compute_residuals</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="giant.calibration.estimators.IterativeNonlinearLSTSQ.reset.html" title="Previous document">IterativeNonlinearLSTSQ.reset</a>
        </li>
        <li>
          <a href="giant.calibration.estimators.LMAEstimator.compute_residuals.html" title="Next document">LMAEstimator.compute_residuals</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <section id="giant-calibration-estimators-lmaestimator">
<h1>giant.calibration.estimators.LMAEstimator<a class="headerlink" href="#giant-calibration-estimators-lmaestimator" title="Permalink to this headline">¶</a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="giant.calibration.estimators.LMAEstimator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">giant.calibration.estimators.</span></span><span class="sig-name descname"><span class="pre">LMAEstimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighted_estimation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residual_atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residual_rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state_atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state_rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_divergence_steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurements</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">camera_frame_directions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_covariance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_priori_state_covariance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperatures</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/giant/calibration/estimators.html#LMAEstimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.estimators.LMAEstimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="giant.calibration.estimators.IterativeNonlinearLSTSQ.html#giant.calibration.estimators.IterativeNonlinearLSTSQ" title="giant.calibration.estimators.IterativeNonlinearLSTSQ"><code class="xref py py-class docutils literal notranslate"><span class="pre">giant.calibration.estimators.IterativeNonlinearLSTSQ</span></code></a></p>
<p>This implements a Levenberg-Marquardt Algorithm estimator, which is analogous to a damped iterative non-linear
least squares.</p>
<p>This class is nearly exactly the same as the <a class="reference internal" href="giant.calibration.estimators.IterativeNonlinearLSTSQ.html#giant.calibration.estimators.IterativeNonlinearLSTSQ" title="giant.calibration.estimators.IterativeNonlinearLSTSQ"><code class="xref py py-class docutils literal notranslate"><span class="pre">IterativeNonlinearLSTSQ</span></code></a> except that it adds damping to the
update step of the iterative non-linear least squares algorithm and allows a few diverging steps in a row where the
damping parameter is updated before failing.  The number of diverging steps that are allowed is controlled by the
<a class="reference internal" href="#giant.calibration.estimators.LMAEstimator.max_divergence_steps" title="giant.calibration.estimators.LMAEstimator.max_divergence_steps"><code class="xref py py-attr docutils literal notranslate"><span class="pre">max_divergence_steps</span></code></a> setting.  This represents only difference from the <a class="reference internal" href="giant.calibration.estimators.IterativeNonlinearLSTSQ.html#giant.calibration.estimators.IterativeNonlinearLSTSQ" title="giant.calibration.estimators.IterativeNonlinearLSTSQ"><code class="xref py py-class docutils literal notranslate"><span class="pre">IterativeNonlinearLSTSQ</span></code></a>
interface from the user’s perspective.</p>
<p>In general, this algorithm will result in the same answer as the <a class="reference internal" href="giant.calibration.estimators.IterativeNonlinearLSTSQ.html#giant.calibration.estimators.IterativeNonlinearLSTSQ" title="giant.calibration.estimators.IterativeNonlinearLSTSQ"><code class="xref py py-class docutils literal notranslate"><span class="pre">IterativeNonlinearLSTSQ</span></code></a> algorithm but at a
slower convergence rate.  In a few cases however, this estimator can be more robust to initial guess errors,
achieving convergence when the standard iterative nonlinear least squares diverges.  Therefore, it is likely best to
start with the <a class="reference internal" href="giant.calibration.estimators.IterativeNonlinearLSTSQ.html#giant.calibration.estimators.IterativeNonlinearLSTSQ" title="giant.calibration.estimators.IterativeNonlinearLSTSQ"><code class="xref py py-class docutils literal notranslate"><span class="pre">IterativeNonlinearLSTSQ</span></code></a> class an only switch to this if you experience convergence issues.</p>
<p>The implementation of the LMA in this class is inspired by
<a class="reference external" href="https://link.springer.com/article/10.1007/s40295-016-0091-3">https://link.springer.com/article/10.1007/s40295-016-0091-3</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="../../camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel" title="giant.camera_models.camera_model.CameraModel"><em>giant.camera_models.camera_model.CameraModel</em></a><em>]</em>) – The camera model instance to be estimated set with an initial guess of the state.</p></li>
<li><p><strong>weighted_estimation</strong> (<em>bool</em>) – A boolean flag specifying whether to do weighted estimation.  <code class="docutils literal notranslate"><span class="pre">True</span></code> indicates
that the measurement weights (and a priori state covariance if applicable) should be
used in the estimation.</p></li>
<li><p><strong>max_iter</strong> (<em>int</em>) – The maximum number of iteration steps to attempt to reach convergence.  If convergence has not
been reached after attempting <code class="docutils literal notranslate"><span class="pre">max_iter</span></code> steps, a warning will be raised that the model has
not converged and <a class="reference internal" href="#giant.calibration.estimators.LMAEstimator.successful" title="giant.calibration.estimators.LMAEstimator.successful"><code class="xref py py-attr docutils literal notranslate"><span class="pre">successful</span></code></a> will be set to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><strong>residual_atol</strong> (<em>float</em>) – The absolute convergence tolerance criteria for the sum of squares of the residuals</p></li>
<li><p><strong>residual_rtol</strong> (<em>float</em>) – The relative convergence tolerance criteria for the sum of squares of the residuals</p></li>
<li><p><strong>state_atol</strong> (<em>float</em>) – The absolute convergence tolerance criteria for the elements of the state vector</p></li>
<li><p><strong>state_rtol</strong> (<em>float</em>) – The relative convergence tolerance criteria for the elements of the state vector</p></li>
<li><p><strong>max_divergence_steps</strong> (<em>int</em>) – The maximum number of steps in a row that can diverge before breaking iteration</p></li>
<li><p><strong>measurements</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>Sequence</em><em>, </em><em>numpy.ndarray</em><em>]</em><em>]</em>) – A 2xn numpy array of measurement pixel locations to be fit to</p></li>
<li><p><strong>camera_frame_directions</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Union</em><em>[</em><em>numpy.ndarray</em><em>, </em><em>List</em><em>[</em><em>List</em><em>]</em><em>]</em><em>]</em><em>]</em>) – A length m list of 3xj numpy arrays or empty 3x1 list of empty lists where m is
the number of unique images the data comes from (and is the same length as
<a class="reference internal" href="#giant.calibration.estimators.LMAEstimator.temperatures" title="giant.calibration.estimators.LMAEstimator.temperatures"><code class="xref py py-attr docutils literal notranslate"><span class="pre">temperatures</span></code></a>) and j is the number of measurements from each image.  A
list of empty lists indicates that no measurements were identified for the
corresponding image.</p></li>
<li><p><strong>measurement_covariance</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>Sequence</em><em>, </em><em>numpy.ndarray</em><em>, </em><em>numbers.Real</em><em>]</em><em>]</em>) – An optional nxn numpy array containing the covariance matrix for the ravelled
measurement vector (in fortran order such that the ravelled measurement vector is
[x1, y1, x2, y2, … xk, yk] where k=n//2)</p></li>
<li><p><strong>a_priori_state_covariance</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>Sequence</em><em>, </em><em>numpy.ndarray</em><em>]</em><em>]</em>) – An optional lxl numpy array containing the a priori covariance matrix for the
a priori estimate of the state, where l is the number of parameters in the
state vector.  This is used only if <a class="reference internal" href="../../camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel.use_a_priori" title="giant.camera_models.camera_model.CameraModel.use_a_priori"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CameraModel.use_a_priori</span></code></a> is set
to <code class="docutils literal notranslate"><span class="pre">True</span></code>.  The length of the state vector can be determined by
<code class="docutils literal notranslate"><span class="pre">len(</span></code><a class="reference internal" href="../../camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel.state_vector" title="giant.camera_models.camera_model.CameraModel.state_vector"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CameraModel.state_vector</span></code></a><code class="docutils literal notranslate"><span class="pre">)</span></code></p></li>
<li><p><strong>temperatures</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>numbers.Real</em><em>]</em><em>]</em>) – A length m list of floats containing the camera temperature at the time of each
corresponding image.  These may be used by the <a class="reference internal" href="../../camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel" title="giant.camera_models.camera_model.CameraModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CameraModel</span></code></a> to perform temperature
dependent estimation of parameters like the focal length, depending on what is set for
<a class="reference internal" href="../../camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel.estimation_parameters" title="giant.camera_models.camera_model.CameraModel.estimation_parameters"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CameraModel.estimation_parameters</span></code></a></p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.estimators.LMAEstimator.a_priori_state_covariance">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">a_priori_state_covariance</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.estimators.LMAEstimator.a_priori_state_covariance" title="Permalink to this definition">¶</a></dt>
<dd><p>A square numpy array containing the covariance matrix for the a priori estimate of the state vector.</p>
<p>This is only considered if <a class="reference internal" href="#giant.calibration.estimators.LMAEstimator.weighted_estimation" title="giant.calibration.estimators.LMAEstimator.weighted_estimation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">weighted_estimation</span></code></a> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> and if
<a class="reference internal" href="../../camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel.use_a_priori" title="giant.camera_models.camera_model.CameraModel.use_a_priori"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CameraModel.use_a_priori</span></code></a> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, otherwise it is ignored.  If both are set to <code class="docutils literal notranslate"><span class="pre">True</span></code> then
this should be set to a square, full rank, lxl numpy array where <code class="docutils literal notranslate"><span class="pre">l=len(model.state_vector)</span></code> containing the
covariance matrix for the a priori state vector.  The order of the parameters in the state vector can be
determined from <a class="reference internal" href="../../camera_model/giant.camera_models.camera_model.CameraModel.get_state_labels.html#giant.camera_models.camera_model.CameraModel.get_state_labels" title="giant.camera_models.camera_model.CameraModel.get_state_labels"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CameraModel.get_state_labels()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the shape of the input matrix is not appropriate for the size of the state vector</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.estimators.LMAEstimator.camera_frame_directions">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">camera_frame_directions</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.estimators.LMAEstimator.camera_frame_directions" title="Permalink to this definition">¶</a></dt>
<dd><p>A length m list of unit vectors in the camera frame as numpy arrays for m images corresponding to the
<a class="reference internal" href="#giant.calibration.estimators.LMAEstimator.measurements" title="giant.calibration.estimators.LMAEstimator.measurements"><code class="xref py py-attr docutils literal notranslate"><span class="pre">measurements</span></code></a> attribute.</p>
<p>Each element of this list corresponds to a unique image that is being considered for estimation and the
subsequent element in the <a class="reference internal" href="#giant.calibration.estimators.LMAEstimator.temperatures" title="giant.calibration.estimators.LMAEstimator.temperatures"><code class="xref py py-attr docutils literal notranslate"><span class="pre">temperatures</span></code></a> list. Each column of this concatenated array will correspond to
the same column of the <a class="reference internal" href="#giant.calibration.estimators.LMAEstimator.measurements" title="giant.calibration.estimators.LMAEstimator.measurements"><code class="xref py py-attr docutils literal notranslate"><span class="pre">measurements</span></code></a> array. (That is
<code class="docutils literal notranslate"><span class="pre">np.concatenate(camera_frame_directions,</span> <span class="pre">axis=-1)[:,</span> <span class="pre">i]</span> <span class="pre">&lt;-&gt;</span> <span class="pre">measurements[:,</span> <span class="pre">i]</span></code>).</p>
<p>Any images for which no stars were identified (due to any number of reasons) will have a list of empty arrays in
the corresponding element of this list (that is <code class="docutils literal notranslate"><span class="pre">camera_frame_directions[i]</span> <span class="pre">==</span> <span class="pre">[[],</span> <span class="pre">[],</span> <span class="pre">[]]</span></code> where <code class="docutils literal notranslate"><span class="pre">i</span></code> is an
image with no measurements identified).  These will be automatically dropped by numpy’s concatenate, but are
included to notify the which temperatures/misalignments to use.</p>
<p>This must always be set before a call to <a class="reference internal" href="giant.calibration.estimators.LMAEstimator.estimate.html#giant.calibration.estimators.LMAEstimator.estimate" title="giant.calibration.estimators.LMAEstimator.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.estimators.LMAEstimator.measurement_covariance">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">measurement_covariance</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numbers.Real</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.estimators.LMAEstimator.measurement_covariance" title="Permalink to this definition">¶</a></dt>
<dd><p>A square numpy array containing the covariance matrix for the measurements or a scalar containing the variance
for all of the measurements.</p>
<p>If <a class="reference internal" href="#giant.calibration.estimators.LMAEstimator.weighted_estimation" title="giant.calibration.estimators.LMAEstimator.weighted_estimation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">weighted_estimation</span></code></a> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> then this property will contain the measurement covariance
matrix as a square, full rank, numpy array or the measurement variance as a scalar float.  If
<a class="reference internal" href="#giant.calibration.estimators.LMAEstimator.weighted_estimation" title="giant.calibration.estimators.LMAEstimator.weighted_estimation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">weighted_estimation</span></code></a> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code> then this property may be <code class="docutils literal notranslate"><span class="pre">None</span></code> and will be ignored.</p>
<p>If specified as a scalar, it is treated as the <strong>variance</strong> for each measurement (that is <code class="docutils literal notranslate"><span class="pre">cov</span> <span class="pre">=</span> <span class="pre">v*I(n,n)</span></code>
where <code class="docutils literal notranslate"><span class="pre">cov</span></code> is the covariance matrix, <code class="docutils literal notranslate"><span class="pre">v</span></code> is the specified scalar variance, and <code class="docutils literal notranslate"><span class="pre">I(n,n)</span></code> is a nxn identity
matrix) in a memory efficient way.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – When attempting to set an array that does not have the proper shape for the
<a class="reference internal" href="#giant.calibration.estimators.LMAEstimator.measurements" title="giant.calibration.estimators.LMAEstimator.measurements"><code class="xref py py-attr docutils literal notranslate"><span class="pre">measurements</span></code></a> vector</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.estimators.LMAEstimator.measurements">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">measurements</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.estimators.LMAEstimator.measurements" title="Permalink to this definition">¶</a></dt>
<dd><p>A nx2 numpy array of the observed pixel locations for stars across all images</p>
<p>Each column of this array corresponds to the same column of the <a class="reference internal" href="#giant.calibration.estimators.LMAEstimator.camera_frame_directions" title="giant.calibration.estimators.LMAEstimator.camera_frame_directions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">camera_frame_directions</span></code></a> concatenated
down the last axis. (That is <code class="docutils literal notranslate"><span class="pre">measurements[:,</span> <span class="pre">i]</span> <span class="pre">&lt;-&gt;</span> <span class="pre">np.concatenate(camera_frame_directions,</span> <span class="pre">axis=-1)[:,</span> <span class="pre">i]</span></code>)</p>
<p>This must always be set before a call to <a class="reference internal" href="giant.calibration.estimators.LMAEstimator.estimate.html#giant.calibration.estimators.LMAEstimator.estimate" title="giant.calibration.estimators.LMAEstimator.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.estimators.LMAEstimator.model">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">model</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../../camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel" title="giant.camera_models.camera_model.CameraModel"><span class="pre">giant.camera_models.camera_model.CameraModel</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.estimators.LMAEstimator.model" title="Permalink to this definition">¶</a></dt>
<dd><p>The camera model that is being estimated.</p>
<p>Typically this should be a subclass of <a class="reference internal" href="../../camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel" title="giant.camera_models.camera_model.CameraModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CameraModel</span></code></a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.estimators.LMAEstimator.postfit_covariance">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">postfit_covariance</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.estimators.LMAEstimator.postfit_covariance" title="Permalink to this definition">¶</a></dt>
<dd><p>The post-fit state covariance matrix, taking into account the measurement covariance matrix (if applicable).</p>
<p>This returns the post-fit state covariance matrix after a call to <a class="reference internal" href="giant.calibration.estimators.LMAEstimator.estimate.html#giant.calibration.estimators.LMAEstimator.estimate" title="giant.calibration.estimators.LMAEstimator.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a>.  The covariance matrix will
be in the order according to <a class="reference internal" href="../../camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel.estimation_parameters" title="giant.camera_models.camera_model.CameraModel.estimation_parameters"><code class="xref py py-attr docutils literal notranslate"><span class="pre">estimation_parameters</span></code></a> and if <a class="reference internal" href="#giant.calibration.estimators.LMAEstimator.weighted_estimation" title="giant.calibration.estimators.LMAEstimator.weighted_estimation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">weighted_estimation</span></code></a> is
<code class="docutils literal notranslate"><span class="pre">True</span></code> will return the state covariance matrix taking into account the measurement covariance matrix.  If
<a class="reference internal" href="#giant.calibration.estimators.LMAEstimator.weighted_estimation" title="giant.calibration.estimators.LMAEstimator.weighted_estimation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">weighted_estimation</span></code></a> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, then this will return the post-fit state covariance matrix assuming no
measurement weighting (that is a measurement covariance matrix of the identity matrix).  If <a class="reference internal" href="giant.calibration.estimators.LMAEstimator.estimate.html#giant.calibration.estimators.LMAEstimator.estimate" title="giant.calibration.estimators.LMAEstimator.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a>
has not been called yet or the fit was unsuccessful then this will return <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.estimators.LMAEstimator.postfit_residuals">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">postfit_residuals</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.estimators.LMAEstimator.postfit_residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>The post-fit observed-computed measurement residuals as a 2xn numpy array.</p>
<p>This returns the post-fit observed minus computed measurement residuals after a call to <a class="reference internal" href="giant.calibration.estimators.LMAEstimator.estimate.html#giant.calibration.estimators.LMAEstimator.estimate" title="giant.calibration.estimators.LMAEstimator.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a>.  If
<a class="reference internal" href="giant.calibration.estimators.LMAEstimator.estimate.html#giant.calibration.estimators.LMAEstimator.estimate" title="giant.calibration.estimators.LMAEstimator.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a> has not been called yet or the fit was unsuccessful then this will return <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.estimators.LMAEstimator.successful">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">successful</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#giant.calibration.estimators.LMAEstimator.successful" title="Permalink to this definition">¶</a></dt>
<dd><p>A boolean flag indicating whether the fit was successful or not.</p>
<p>If the fit was successful this should return <code class="docutils literal notranslate"><span class="pre">True</span></code>, and <code class="docutils literal notranslate"><span class="pre">False</span></code> if otherwise.  A fit is defined as
successful if convergence criteria were reached before the maximum number of iterations.  Divergence and
non-convergence are both considered an unsuccessful fit resulting in this being set to <code class="docutils literal notranslate"><span class="pre">False</span></code></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.estimators.LMAEstimator.temperatures">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">temperatures</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">numbers.Real</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.estimators.LMAEstimator.temperatures" title="Permalink to this definition">¶</a></dt>
<dd><p>A length m list of temperatures of the camera for each image being considered in estimation.</p>
<p>Each element of this list corresponds to a unique image that is being considered for estimation and the
subsequent element in the <a class="reference internal" href="#giant.calibration.estimators.LMAEstimator.camera_frame_directions" title="giant.calibration.estimators.LMAEstimator.camera_frame_directions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">camera_frame_directions</span></code></a> list.</p>
<p>This must always be set before a call to <a class="reference internal" href="giant.calibration.estimators.LMAEstimator.estimate.html#giant.calibration.estimators.LMAEstimator.estimate" title="giant.calibration.estimators.LMAEstimator.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a> (although sometimes it may be a list of all zeros if
temperature data is not available for the camera).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.estimators.LMAEstimator.weighted_estimation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">weighted_estimation</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#giant.calibration.estimators.LMAEstimator.weighted_estimation" title="Permalink to this definition">¶</a></dt>
<dd><p>A boolean flag specifying whether to do weighted estimation.</p>
<p>If set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, the estimator will use the provided measurement weights in <a class="reference internal" href="#giant.calibration.estimators.LMAEstimator.measurement_covariance" title="giant.calibration.estimators.LMAEstimator.measurement_covariance"><code class="xref py py-attr docutils literal notranslate"><span class="pre">measurement_covariance</span></code></a>
during the estimation process.  If set to <code class="docutils literal notranslate"><span class="pre">False</span></code>, then no measurement weights will be considered.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.estimators.LMAEstimator.max_divergence_steps">
<span class="sig-name descname"><span class="pre">max_divergence_steps</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#giant.calibration.estimators.LMAEstimator.max_divergence_steps" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum number of steps in a row that can diverge before breaking iteration</p>
</dd></dl>

</dd></dl>

<p class="rubric">Summary of Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="giant.calibration.estimators.LMAEstimator.compute_residuals.html#giant.calibration.estimators.LMAEstimator.compute_residuals" title="giant.calibration.estimators.LMAEstimator.compute_residuals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_residuals</span></code></a></p></td>
<td><p>This method computes the observed minus computed residuals for the current model (or an input model).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="giant.calibration.estimators.LMAEstimator.estimate.html#giant.calibration.estimators.LMAEstimator.estimate" title="giant.calibration.estimators.LMAEstimator.estimate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate</span></code></a></p></td>
<td><p>This method estimates the postfit residuals based on the model, weight matrix, lma coefficient, etc.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="giant.calibration.estimators.LMAEstimator.reset.html#giant.calibration.estimators.LMAEstimator.reset" title="giant.calibration.estimators.LMAEstimator.reset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset</span></code></a></p></td>
<td><p>This method resets all of the data attributes to their default values to prepare for another estimation.</p></td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="giant.calibration.estimators.IterativeNonlinearLSTSQ.reset.html" title="Previous document">IterativeNonlinearLSTSQ.reset</a>
        </li>
        <li>
          <a href="giant.calibration.estimators.LMAEstimator.compute_residuals.html" title="Next document">LMAEstimator.compute_residuals</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2021 United States Government.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.3.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/calibration/estimators/giant.calibration.estimators.LMAEstimator.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>