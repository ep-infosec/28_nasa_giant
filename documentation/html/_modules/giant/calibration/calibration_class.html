
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>giant.calibration.calibration_class &#8212; GIANT 1.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../copyright.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/logo.png" alt="Logo"/>
    
  </a>
</p>



<p class="blurb">A powerful API for Optical Navigation</p>






<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installing GIANT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../giant.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../giant.html#indices">Indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../copyright.html">Copyright</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <h1>Source code for giant.calibration.calibration_class</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2021 United States Government as represented by the Administrator of the National Aeronautics and Space</span>
<span class="c1"># Administration.  No copyright is claimed in the United States under Title 17, U.S. Code. All Other Rights Reserved.</span>


<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module provides a subclass of the :class:`.OpNav` class for performing stellar OpNav and camera calibration.</span>

<span class="sd">Interface Description</span>
<span class="sd">---------------------</span>

<span class="sd">In GIANT, calibration refers primarily to the process of estimating a model to map points in the 3D</span>
<span class="sd">world to the observed points in a 2D image.  This is done by estimating both a geometric</span>
<span class="sd">:mod:`camera model &lt;.camera_models&gt;` along with an optional pointing alignment between the camera frame and the base</span>
<span class="sd">frame the knowledge of the camera attitude is tied to (for instance the spacecraft bus frame).  For both of these, we</span>
<span class="sd">use observations of stars to get highly accurate models.</span>

<span class="sd">The :class:`Calibration` class is the main interface for performing calibration in GIANT, and in general is all the user</span>
<span class="sd">will need to interact with.  It is a subclass of the :class:`.StellarOpNav` class and as such provides a very similar</span>
<span class="sd">interface with only a few additional features. It provides direct access to the :class:`.ImageProcessing`,</span>
<span class="sd">:class:`.StarID`, :mod:`.stellar_opnav.estimators`, and :mod:`.calibration.estimators` objects and automatically</span>
<span class="sd">preforms the required data transfer between the objects for you.  To begin you simply provide the :class:`.StellarOpNav`</span>
<span class="sd">constructor a :class:`.Camera` instance, either a :class:`.ImageProcessing` instance or the keyword arguments to create</span>
<span class="sd">one, a :class:`.StarID` instance or the keyword arguments to creation one, the attitude estimation object you wish to</span>
<span class="sd">use to perform the attitude estimation, the static alignment estimation object you wish to use to perform the static</span>
<span class="sd">alignment estimation, the temperature dependent alignment estimation object you wish to use to perform the temperature</span>
<span class="sd">dependent alignment, and the calibration estimation object you wish to use to perform the calibration. You can then use</span>
<span class="sd">the :class:`Calibration` instance to perform all of the aspects of stellar OpNav and calibration with never having to</span>
<span class="sd">interact with the internal objects again.</span>

<span class="sd">For example, we could do something like the following (from the directory containing ``sample_data``):</span>

<span class="sd">    &gt;&gt;&gt; import pickle</span>
<span class="sd">    &gt;&gt;&gt; from giant.calibration import Calibration</span>
<span class="sd">    &gt;&gt;&gt; from giant.rotations import Rotation</span>
<span class="sd">    &gt;&gt;&gt; with open(&#39;sample_data/camera.pickle&#39;, &#39;rb&#39;) as ifile:</span>
<span class="sd">    ...     camera = pickle.load(ifile)</span>
<span class="sd">    &gt;&gt;&gt; # Returns the identity to signify the base frame is the inertial frame</span>
<span class="sd">    &gt;&gt;&gt; def base_frame(*args):</span>
<span class="sd">    ...     return Rotation([0, 0, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; cal = Calibration(camera, alignment_base_frame_func=base_frame)</span>
<span class="sd">    &gt;&gt;&gt; cal.id_stars()  # id the stars for each image</span>
<span class="sd">    &gt;&gt;&gt; cal.sid_summary()  # print out a summary of the star identification success for each image</span>
<span class="sd">    &gt;&gt;&gt; cal.estimate_attitude()  # estimate an updated attitude for each image</span>
<span class="sd">    &gt;&gt;&gt; cal.estimate_calibration()  # estimate an updated camera model</span>
<span class="sd">    &gt;&gt;&gt; cal.calib_summary()  # print out a summary of the star identification success for each image</span>
<span class="sd">    &gt;&gt;&gt; cal.estimate_static_alignment()  # estimate the alignment between the camera frame and hte base frame</span>
<span class="sd">    &gt;&gt;&gt; cal.estimate_temperature_dependent_alignment()  # estimate the temperature dependent alignment</span>

<span class="sd">For a more general description of the steps needed to perform calibration, refer to the :mod:`.calibration` package.</span>
<span class="sd">For a more in-depth examination of the :class:`Calibration` class see the following API Reference.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Callable</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">estimators</span> <span class="k">as</span> <span class="n">est</span>
<span class="kn">from</span> <span class="nn">..stellar_opnav.stellar_class</span> <span class="kn">import</span> <span class="n">StellarOpNav</span>
<span class="kn">from</span> <span class="nn">..image_processing</span> <span class="kn">import</span> <span class="n">ImageProcessing</span>
<span class="kn">from</span> <span class="nn">..stellar_opnav.star_identification</span> <span class="kn">import</span> <span class="n">StarID</span>
<span class="kn">from</span> <span class="nn">..stellar_opnav</span> <span class="kn">import</span> <span class="n">estimators</span> <span class="k">as</span> <span class="n">sopnavest</span>
<span class="kn">from</span> <span class="nn">..camera</span> <span class="kn">import</span> <span class="n">Camera</span>
<span class="kn">from</span> <span class="nn">..rotations</span> <span class="kn">import</span> <span class="n">Rotation</span>

<span class="kn">from</span> <span class="nn">.._typing</span> <span class="kn">import</span> <span class="n">NONEARRAY</span><span class="p">,</span> <span class="n">SCALAR_OR_ARRAY</span>


<span class="k">def</span> <span class="nf">_print_lr</span><span class="p">(</span><span class="n">labels</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This pretty prints the lower left triangle of a matrix with labels.</span>

<span class="sd">    This is used to print covariance and correlation matrices.</span>

<span class="sd">    :param labels: The labels for each row/column of the matrix</span>
<span class="sd">    :param values: The matrix to print</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># get the maximum length of the labels, with a minimum size of 10</span>
    <span class="n">max_label</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">labels</span><span class="p">)),</span> <span class="mi">10</span><span class="p">)</span>

    <span class="c1"># make the label format string based on the maximum label length</span>
    <span class="n">label_format</span> <span class="o">=</span> <span class="s1">&#39;{:&lt;&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">max_label</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;s}&#39;</span>

    <span class="c1"># make the value format string based on the maximum label length</span>
    <span class="n">value_format</span> <span class="o">=</span> <span class="s1">&#39;{:&gt;&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">max_label</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">max_label</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;e}&#39;</span>

    <span class="c1"># loop through the rows</span>
    <span class="k">for</span> <span class="n">rind</span><span class="p">,</span> <span class="n">rlabel</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
        <span class="c1"># print the label format at the beginning of each new row.  Don&#39;t use a new line after</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">label_format</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rlabel</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;  &#39;</span><span class="p">)</span>
        <span class="c1"># loop through the columns</span>
        <span class="k">for</span> <span class="n">cind</span><span class="p">,</span> <span class="n">clabel</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
            <span class="c1"># skip the upper right triangle</span>
            <span class="k">if</span> <span class="n">cind</span> <span class="o">&gt;</span> <span class="n">rind</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="c1"># print out the value using the format string.  Don&#39;t use a new line after</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">value_format</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">rind</span><span class="p">,</span> <span class="n">cind</span><span class="p">]),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;  &#39;</span><span class="p">)</span>

    <span class="c1"># print out a space to get the column labels in the right place</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">label_format</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="c1"># change the label format to be right aligned</span>
    <span class="n">label_format</span> <span class="o">=</span> <span class="n">label_format</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&lt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;&#39;</span><span class="p">)</span>

    <span class="c1"># print out a row of column labels</span>
    <span class="k">for</span> <span class="n">clabel</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">label_format</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">clabel</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;  &#39;</span><span class="p">)</span>

    <span class="c1"># print a new line</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">max_label</span>


<div class="viewcode-block" id="Calibration"><a class="viewcode-back" href="../../../giant.calibration.html#giant.calibration.calibration_class.Calibration">[docs]</a><span class="k">class</span> <span class="nc">Calibration</span><span class="p">(</span><span class="n">StellarOpNav</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class serves as the main user interface for performing geometric camera calibration and camera frame attitude</span>
<span class="sd">    alignment.</span>

<span class="sd">    The class acts as a container for the :class:`.Camera`, :class:`.ImageProcessing`, and</span>
<span class="sd">    :mod:`.stellar_opnav.estimators`, :mod:`.calibration.estimators` objects and also passes the correct and up-to-date</span>
<span class="sd">    data from one object to the other. In general, this class will be the exclusive interface to the mentioned objects</span>
<span class="sd">    and models for the user.</span>

<span class="sd">    This class provides a number of features that make doing stellar OpNav and camera calibration/alignment easy.  The</span>
<span class="sd">    first is it provides aliases to the image processing, star id, attitude estimation, calibration estimation, and</span>
<span class="sd">    alignment estimation objects. These aliases make it easy to quickly change/update the various tuning parameters that</span>
<span class="sd">    are necessary to make star identification and calibration a success. In addition to providing convenient access to</span>
<span class="sd">    the underlying settings, some of these aliases also update internal flags that specify whether individual images</span>
<span class="sd">    need to be reprocessed, saving computation time when you&#39;re trying to find the best tuning.</span>

<span class="sd">    This class also provides simple methods for performing star identification, attitude estimation, camera calibration,</span>
<span class="sd">    and aligment estimation after you have set the tuning parameters. These methods (:meth:`id_stars`,</span>
<span class="sd">    :meth:`sid_summary`, :meth:`estimate_attitude`, :meth:`estimate_calibration`, :meth:`calib_summary`,</span>
<span class="sd">    :meth:`estimate_static_alignment`, and :meth:`estimate_temperature_dependent_alignment`) combine all of the</span>
<span class="sd">    required steps into a few simple calls, and pass the resulting data from one object to the next. They also store off</span>
<span class="sd">    the results of the star identification in the :attr:`queried_catalogue_star_records`,</span>
<span class="sd">    :attr:`queried_catalogue_image_points`, :attr:`queried_catalogue_unit_vectors`, :attr:`ip_extracted_image_points`,</span>
<span class="sd">    :attr:`ip_image_illums`, :attr:`ip_psfs`, :attr:`ip_stats`, :attr:`ip_snrs`,</span>
<span class="sd">    :attr:`unmatched_catalogue_image_points`, :attr:`unmatched_image_illums`,</span>
<span class="sd">    :attr:`unmatched_psfs`, :attr:`unmatched_stats`, :attr:`unmatched_snrs`</span>
<span class="sd">    :attr:`unmatched_catalogue_star_records`,</span>
<span class="sd">    :attr:`unmatched_catalogue_unit_vectors`,</span>
<span class="sd">    :attr:`unmatched_extracted_image_points`,</span>
<span class="sd">    :attr:`matched_catalogue_image_points`, :attr:`matched_image_illums`,</span>
<span class="sd">    :attr:`matched_psfs`, :attr:`matched_stats`, :attr:`matched_snrs`</span>
<span class="sd">    :attr:`matched_catalogue_star_records`,</span>
<span class="sd">    :attr:`matched_catalogue_unit_vectors_inertial`,</span>
<span class="sd">    :attr:`matched_catalogue_unit_vectors_camera`, and</span>
<span class="sd">    :attr:`matched_extracted_image_points` attributes, enabling more advanced analysis to be performed external to the</span>
<span class="sd">    class.</span>

<span class="sd">    This class stores the updated attitude solutions in the image objects themselves, allowing you to directly</span>
<span class="sd">    pass your images from stellar OpNav to the :mod:`.relative_opnav` routines with updated attitude solutions. It also</span>
<span class="sd">    stores the estimated camera model in the original camera model itself, and store the estimated alignments in the</span>
<span class="sd">    :attr:`static_alignment` and :attr:`temperature_dependent_alignment` attributes. Finally, this class</span>
<span class="sd">    respects the :attr:`.image_mask` attribute of the :class:`.Camera` object, only considering images that are</span>
<span class="sd">    currently turned on.</span>

<span class="sd">    When initializing this class, most of the initial options can be set using the ``*_kwargs`` inputs with</span>
<span class="sd">    dictionaries specifying the keyword arguments and values. Alternatively, you can provide already initialized</span>
<span class="sd">    instances of the :class:`.ImageProcessing`, :class:`.AttitudeEstimator`, :class:`.StarID`,</span>
<span class="sd">    :class:`.CalibrationEstimator`, :class:`.StaticAlignmentEstimator`, or</span>
<span class="sd">    :class:`.TemperatureDependentAlignmentEstimator` classes or subclasses</span>
<span class="sd">    if you want a little more control.  You should see the documentation for these classes for more details on what you</span>
<span class="sd">    can do with them.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">camera</span><span class="p">:</span> <span class="n">Camera</span><span class="p">,</span> <span class="n">use_weights</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">image_processing</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ImageProcessing</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">image_processing_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">star_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">StarID</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">star_id_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">alignment_base_frame_func</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">attitude_estimator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">sopnavest</span><span class="o">.</span><span class="n">AttitudeEstimator</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">attitude_estimator_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">static_alignment_estimator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">est</span><span class="o">.</span><span class="n">StaticAlignmentEstimator</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">static_alignment_estimator_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">temperature_dependent_alignment_estimator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">est</span><span class="o">.</span><span class="n">TemperatureDependentAlignmentEstimator</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">temperature_dependent_alignment_estimator_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">calibration_estimator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">est</span><span class="o">.</span><span class="n">CalibrationEstimator</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">calibration_estimator_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param camera: The :class:`.Camera` object containing the camera model and images to be utilized</span>
<span class="sd">        :param use_weights: A flag specifying whether to use weighted estimation for attitude, alignment, and</span>
<span class="sd">                            calibration</span>
<span class="sd">        :param alignment_base_frame_func: A callable object which returns the orientation of the base frame with respect</span>
<span class="sd">                                          to the inertial frame the alignment of the camera frame is to be done with</span>
<span class="sd">                                          respect to for a given date.</span>
<span class="sd">        :param image_processing: An already initialized instance of :class:`.ImageProcessing` (or a subclass).  If not</span>
<span class="sd">                                 ``None`` then ``image_processing_kwargs`` are ignored.</span>
<span class="sd">        :param image_processing_kwargs: The keyword arguments to pass to the :class:`.ImageProcessing` class</span>
<span class="sd">                                        constructor.  These are ignored if argument ``image_processing`` is not ``None``</span>
<span class="sd">        :param star_id: An already initialized instance of :class:`.StarID` (or a subclass).  If not</span>
<span class="sd">                        ``None`` then ``star_id_kwargs`` are ignored.</span>
<span class="sd">        :param star_id_kwargs:  The keyword arguments to pass to the :class:`.StarID` class constructor as</span>
<span class="sd">                                a dictionary.  These are ignored if argument ``star_id`` is not ``None``.</span>
<span class="sd">        :param attitude_estimator: An already initialized instance of :class:`.AttitudeEstimator` (or a subclass).  If</span>
<span class="sd">                                   not ``None`` then ``attitude_estimator_kwargs`` are ignored.</span>
<span class="sd">        :param attitude_estimator_kwargs: The keyword arguments to pass to the :class:`.DavenportQMethod`</span>
<span class="sd">                                          constructor as a dictionary.  If argument ``attitude_estimator`` is not</span>
<span class="sd">                                          ``None`` then this is ignored.</span>
<span class="sd">        :param static_alignment_estimator: An already initialized instance of :class:`.StaticAlignmentEstimator` (or a</span>
<span class="sd">                                           subclass).  If not ``None`` then ``static_alignment_estimator_kwargs`` are</span>
<span class="sd">                                           ignored.</span>
<span class="sd">        :param static_alignment_estimator_kwargs: The keyword arguments to pass to the</span>
<span class="sd">                                                  :class:`.StaticAlignmentEstimator` constructor as a dictionary.  If</span>
<span class="sd">                                                  argument ``static_alignment_estimator`` is not ``None`` then this is</span>
<span class="sd">                                                  ignored.</span>
<span class="sd">        :param temperature_dependent_alignment_estimator: An already initialized instance of</span>
<span class="sd">                                                          :class:`.TemperatureDependentAlignmentEstimator` (or a</span>
<span class="sd">                                                          subclass).  If not ``None`` then</span>
<span class="sd">                                                          ``temperature_dependent_alignment_estimator_kwargs`` are</span>
<span class="sd">                                                          ignored.</span>
<span class="sd">        :param temperature_dependent_alignment_estimator_kwargs: The keyword arguments to pass to the</span>
<span class="sd">                                                                 :class:`.TemperatureDependentAlignmentEstimator`</span>
<span class="sd">                                                                 constructor as a dictionary.  If argument</span>
<span class="sd">                                                                 ``temperature_dependent_alignment_estimator`` is not</span>
<span class="sd">                                                                 ``None`` then this is ignored.</span>
<span class="sd">        :param calibration_estimator: An already initialized instance of :class:`.CalibrationEstimator` (or a</span>
<span class="sd">                                      subclass).  If not ``None`` then ``calibration_estimator_kwargs`` are ignored.</span>
<span class="sd">        :param calibration_estimator_kwargs: The keyword arguments to pass to the :class:`.IterativeNonlinearLSTSQ`</span>
<span class="sd">                                             constructor as a dictionary.  If argument ``static_alignment_estimator is</span>
<span class="sd">                                             not ``None`` then this is ignored.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># initialize the StellarOpNav super class</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">camera</span><span class="p">,</span> <span class="n">use_weights</span><span class="o">=</span><span class="n">use_weights</span><span class="p">,</span>
                         <span class="n">image_processing</span><span class="o">=</span><span class="n">image_processing</span><span class="p">,</span> <span class="n">image_processing_kwargs</span><span class="o">=</span><span class="n">image_processing_kwargs</span><span class="p">,</span>
                         <span class="n">star_id</span><span class="o">=</span><span class="n">star_id</span><span class="p">,</span> <span class="n">star_id_kwargs</span><span class="o">=</span><span class="n">star_id_kwargs</span><span class="p">,</span>
                         <span class="n">attitude_estimator</span><span class="o">=</span><span class="n">attitude_estimator</span><span class="p">,</span> <span class="n">attitude_estimator_kwargs</span><span class="o">=</span><span class="n">attitude_estimator_kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">calibration_estimator</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">calibration_estimator_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_calibration_est</span> <span class="o">=</span> <span class="n">est</span><span class="o">.</span><span class="n">IterativeNonlinearLSTSQ</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_camera</span><span class="o">.</span><span class="n">model</span><span class="p">,</span>
                                                                    <span class="o">**</span><span class="n">calibration_estimator_kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_calibration_est</span> <span class="o">=</span> <span class="n">est</span><span class="o">.</span><span class="n">IterativeNonlinearLSTSQ</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_camera</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calibration_est</span> <span class="o">=</span> <span class="n">calibration_estimator</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">alignment_base_frame_func</span> <span class="o">=</span> <span class="n">alignment_base_frame_func</span>  <span class="c1"># type: Optional[Callable]</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A callable object which returns the orientation of the base frame with respect  </span>
<span class="sd">        to the inertial frame the alignment of the camera frame is to be done with      </span>
<span class="sd">        respect to for a given date.                                                    </span>
<span class="sd">        </span>
<span class="sd">        This is used on calls to :meth:`estimate_static_alignment` and :meth`estimate_temperature_dependent_alignment` </span>
<span class="sd">        to determine the base frame the alignment is being done with respect to.  Typically this returns something like </span>
<span class="sd">        the spacecraft body frame with respect to the inertial frame (inertial to spacecraft body) or another camera </span>
<span class="sd">        frame.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">static_alignment_estimator</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">static_alignment_estimator_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_static_alignment_est</span> <span class="o">=</span> <span class="n">est</span><span class="o">.</span><span class="n">StaticAlignmentEstimator</span><span class="p">(</span><span class="o">**</span><span class="n">static_alignment_estimator_kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_static_alignment_est</span> <span class="o">=</span> <span class="n">est</span><span class="o">.</span><span class="n">StaticAlignmentEstimator</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_static_alignment_est</span> <span class="o">=</span> <span class="n">static_alignment_estimator</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">static_alignment</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: Optional[Rotation]</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The static alignment as a :class:`.Rotation` object.</span>
<span class="sd">        </span>
<span class="sd">        This will be none until the :meth:`estimate_static_alignment` method is called at which point it will contain </span>
<span class="sd">        the estimated alignment.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">temperature_dependent_alignment_estimator</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">temperature_dependent_alignment_estimator_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_temperature_dependent_alignment_est</span> <span class="o">=</span> <span class="n">est</span><span class="o">.</span><span class="n">TemperatureDependentAlignmentEstimator</span><span class="p">(</span>
                    <span class="o">**</span><span class="n">temperature_dependent_alignment_estimator_kwargs</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_temperature_dependent_alignment_est</span> <span class="o">=</span> <span class="n">est</span><span class="o">.</span><span class="n">TemperatureDependentAlignmentEstimator</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_temperature_dependent_alignment_est</span> <span class="o">=</span> <span class="n">temperature_dependent_alignment_estimator</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">temperature_dependent_alignment</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: NONEARRAY</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The temperature dependent alignment as a 3x2 numpy array.</span>

<span class="sd">        The temperature dependent alignment array is stored such that the first column is the</span>
<span class="sd">        static offset for the alignment, the second column is the temperature dependent slope, and each row represents</span>
<span class="sd">        the euler angle according to the requested order (so if the requested order is ``&#39;xyx&#39;`` then the rotation from</span>
<span class="sd">        the base frame to the camera frame at temperature ``t`` can be computed using:</span>

<span class="sd">            &gt;&gt;&gt; from giant.rotations import euler_to_rotmat, Rotation</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; temperature_dependent_alignment = np.arange(6).reshape(3, 2)  # temp array just to demonstrate</span>
<span class="sd">            &gt;&gt;&gt; t = -22.5  # temp temperature just to demonstrate</span>
<span class="sd">            &gt;&gt;&gt; angles =temperature_dependent_alignment@[1, t]</span>
<span class="sd">            &gt;&gt;&gt; order = &#39;xyx&#39;</span>
<span class="sd">            &gt;&gt;&gt; rotation_base_to_camera = Rotation(euler_to_rotmat(angles, order))</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_initial_calibration_est</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calibration_est</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initial_calibration_est_kwargs</span> <span class="o">=</span> <span class="n">calibration_estimator_kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initial_static_alignment_est</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_static_alignment_est</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initial_static_alignment_est_kwargs</span> <span class="o">=</span> <span class="n">static_alignment_estimator_kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initial_temperature_dependent_alignment_est</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_temperature_dependent_alignment_est</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initial_temperature_dependent_alignment_est_kwargs</span> <span class="o">=</span> <span class="n">temperature_dependent_alignment_estimator_kwargs</span>

    <span class="c1"># update the model setter to also update the sid model</span>
    <span class="nd">@StellarOpNav</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="c1"># dispatch to the super setter</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="fm">__set__</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calibration_est</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">calibration_estimator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">est</span><span class="o">.</span><span class="n">CalibrationEstimator</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The calibration estimator to use when estimating the geometric calibration</span>

<span class="sd">        This should typically be a subclass of the :class:`.CalibrationEstimator` meta class.</span>

<span class="sd">        See the :mod:`~.calibration.estimators` documentation for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calibration_est</span>

    <span class="nd">@calibration_estimator</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">calibration_estimator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">est</span><span class="o">.</span><span class="n">CalibrationEstimator</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calibration_est</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The calibration_estimator object should probably subclass the CalibrationEstimator &quot;</span>
                          <span class="s2">&quot;metaclass. We&#39;ll assume you know what you&#39;re doing for now, but see the &quot;</span>
                          <span class="s2">&quot;calibration.estimator documentation for details&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_calibration_est</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">static_alignment_estimator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">est</span><span class="o">.</span><span class="n">StaticAlignmentEstimator</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The static alignment estimator to use when estimating the static alignment</span>

<span class="sd">        This should typically be a subclass of the :class:`.StaticAlignmentEstimator` class.</span>

<span class="sd">        See the :mod:`~.calibration.estimators` documentation for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_static_alignment_est</span>

    <span class="nd">@static_alignment_estimator</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">static_alignment_estimator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">est</span><span class="o">.</span><span class="n">StaticAlignmentEstimator</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">est</span><span class="o">.</span><span class="n">StaticAlignmentEstimator</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_static_alignment_est</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The static alignment_estimator object should probably subclass the &quot;</span>
                          <span class="s2">&quot;StaticAlignmentEstimator class. We&#39;ll assume you know what you&#39;re doing for &quot;</span>
                          <span class="s2">&quot;now, but see the calibration.estimator documentation for details&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_static_alignment_est</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">temperature_dependent_alignment_estimator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">est</span><span class="o">.</span><span class="n">TemperatureDependentAlignmentEstimator</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The temperature_dependent_alignment estimator to use when estimating the temperature_dependent_alignment</span>

<span class="sd">        This should typically be a subclass of the :class:`.TemperatureDependentAlignmentEstimator` class.</span>

<span class="sd">        See the :mod:`~.calibration.estimators` documentation for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_temperature_dependent_alignment_est</span>

    <span class="nd">@temperature_dependent_alignment_estimator</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">temperature_dependent_alignment_estimator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">est</span><span class="o">.</span><span class="n">TemperatureDependentAlignmentEstimator</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">est</span><span class="o">.</span><span class="n">StaticAlignmentEstimator</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_temperature_dependent_alignment_est</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The temperature_dependent_alignment_estimator object should probably subclass the &quot;</span>
                          <span class="s2">&quot;TemperatureDependentAlignmentEstimator class. We&#39;ll assume you know what you&#39;re doing for &quot;</span>
                          <span class="s2">&quot;now, but see the calibration.estimator documentation for details&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_temperature_dependent_alignment_est</span> <span class="o">=</span> <span class="n">val</span>

    <span class="c1"># ____________________________________________________METHODS________________________________________________</span>

<div class="viewcode-block" id="Calibration.estimate_calibration"><a class="viewcode-back" href="../../../giant.calibration.html#giant.calibration.calibration_class.Calibration.estimate_calibration">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_calibration</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method estimates an updated camera model using all stars identified in all images that are turned on.</span>

<span class="sd">        For each turned on image in the :attr:`camera` attribute, this method provides the :attr:`calibration_estimator`</span>
<span class="sd">        with the :attr:`matched_extracted_image_points`, the :attr:`matched_catalogue_unit_vectors_camera`, and</span>
<span class="sd">        optionally the :attr:`matched_weights_picture` if :attr:`use_weights` is ``True``. The</span>
<span class="sd">        :meth:`~.CalibrationEstimator.estimate` method is then called and the resulting updated camera model is stored</span>
<span class="sd">        in the :attr:`model` attribute.  Finally, the updated camera model is used to update the following:</span>

<span class="sd">        * :attr:`matched_catalogue_image_points`</span>
<span class="sd">        * :attr:`queried_catalogue_image_points`</span>
<span class="sd">        * :attr:`unmatched_catalogue_image_points`</span>

<span class="sd">        For a more thorough description of the calibration estimation routines see the :mod:`.calibration.estimators`</span>
<span class="sd">        documentation.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            This method overwrites the camera model information in the :attr:`camera` attribute and</span>
<span class="sd">            does not save old information anywhere.  If you want this information saved be sure to store it yourself.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># reset things to make sure we don&#39;t mix information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calibration_est</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

        <span class="c1"># prepare the inputs</span>
        <span class="n">use_pois</span> <span class="o">=</span> <span class="p">[[[],</span> <span class="p">[]]]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="n">use_vecs</span> <span class="o">=</span> <span class="p">[[[],</span> <span class="p">[],</span> <span class="p">[]]]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="n">big_weights</span> <span class="o">=</span> <span class="p">[[[],</span> <span class="p">[]]]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="n">temperatures</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="p">:</span>
            <span class="n">pois</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matched_extracted_image_points</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">pois</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">use_pois</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">pois</span>
            <span class="n">vecs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matched_catalogue_unit_vectors_camera</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">vecs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">use_vecs</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">vecs</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_weights</span><span class="p">:</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matched_weights_picture</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">big_weights</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights</span>

            <span class="n">temperatures</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">temperature</span>

        <span class="c1"># update the attributes for the calibration estimator</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_weights</span><span class="p">:</span>
            <span class="n">big_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">big_weights</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calibration_est</span><span class="o">.</span><span class="n">weighted_estimation</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calibration_est</span><span class="o">.</span><span class="n">measurement_covariance</span> <span class="o">=</span> <span class="n">big_weights</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calibration_est</span><span class="o">.</span><span class="n">weighted_estimation</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_calibration_est</span><span class="o">.</span><span class="n">measurements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">use_pois</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_calibration_est</span><span class="o">.</span><span class="n">camera_frame_directions</span> <span class="o">=</span> <span class="n">use_vecs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_calibration_est</span><span class="o">.</span><span class="n">temperatures</span> <span class="o">=</span> <span class="n">temperatures</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_calibration_est</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># do the estimation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calibration_est</span><span class="o">.</span><span class="n">estimate</span><span class="p">()</span>

        <span class="c1"># store the updated camera model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_calibration_est</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>

        <span class="c1"># update the catalogue locations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reproject_stars</span><span class="p">()</span></div>

<div class="viewcode-block" id="Calibration.estimate_static_alignment"><a class="viewcode-back" href="../../../giant.calibration.html#giant.calibration.calibration_class.Calibration.estimate_static_alignment">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_static_alignment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method estimates a static (not temeprature dependent) alignment between a base frame and the camera frame</span>
<span class="sd">        over multiple images.</span>

<span class="sd">        This method uses the :attr:`alignment_base_frame_func` to retrieve the rotation from the inertial frame to the</span>
<span class="sd">        base frame the alignment is to be done with respect to for each image time. The inertial matched catalogue unit</span>
<span class="sd">        vectors are then rotated into the base frame. Then, the matched image points-of-interest are converted to unit</span>
<span class="sd">        vectors in the camera frame. These 2 sets of unit vectors are then provided to the</span>
<span class="sd">        :attr:`static_alignment_estimator` and its :meth:`~.StaticAlignmentEstimator.estimate` method is called to</span>
<span class="sd">        estimate the alignment between the frames.  The resulting alignment is stored in the :attr:`static_alignment`</span>
<span class="sd">        attribute.</span>

<span class="sd">        Note that to do alignment, the base frame and the camera frame should generally be fixed with respect to one</span>
<span class="sd">        another.  This means that you can&#39;t do alignment with respect to something like the inertial frame in general,</span>
<span class="sd">        unless your camera is magically fixed with respect to the inertial frame.</span>

<span class="sd">        Generally, this method should be called after you have estimated the geometric camera model, because the</span>
<span class="sd">        geometric camera model is used to convert the observed pixel locations in the image to unit vectors in the</span>
<span class="sd">        camera frame (using :meth:`~.CameraModel.pixels_to_unit`).</span>

<span class="sd">        .. Note::</span>
<span class="sd">            This method will attempt to account for misalignment estimated along with the camera model when performing</span>
<span class="sd">            the estimation; however, this is not recommended. Instead, once you have performed your camera model</span>
<span class="sd">            calibration, you should consider resetting the camera model misalignment to 0 and then calling</span>
<span class="sd">            :meth:`estimate_attitude` before a call to this function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># prepare the inputs</span>
        <span class="n">base_uvecs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cam_uvecs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matched_catalogue_unit_vectors_inertial</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="c1"># rotate the inertial catalogue directions into the base frame</span>
                <span class="n">rot_inertial2base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alignment_base_frame_func</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">observation_date</span><span class="p">)</span>

                <span class="n">base_uvecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">rot_inertial2base</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">_matched_catalogue_unit_vectors_inertial</span><span class="p">[</span><span class="n">ind</span><span class="p">]))</span>

                <span class="c1"># get the unit vectors in the camera frame using the camera model</span>
                <span class="n">cam_uvecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">pixels_to_unit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_matched_extracted_image_points</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>
                                                           <span class="n">temperature</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">temperature</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">ind</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_static_alignment_est</span><span class="o">.</span><span class="n">frame1_unit_vecs</span> <span class="o">=</span> <span class="n">base_uvecs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_static_alignment_est</span><span class="o">.</span><span class="n">frame2_unit_vecs</span> <span class="o">=</span> <span class="n">cam_uvecs</span>

        <span class="c1"># do the static alignment</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_static_alignment_est</span><span class="o">.</span><span class="n">estimate</span><span class="p">()</span>

        <span class="c1"># store the results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">static_alignment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_static_alignment_est</span><span class="o">.</span><span class="n">alignment</span></div>

<div class="viewcode-block" id="Calibration.estimate_temperature_dependent_alignment"><a class="viewcode-back" href="../../../giant.calibration.html#giant.calibration.calibration_class.Calibration.estimate_temperature_dependent_alignment">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_temperature_dependent_alignment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method estimates a temperature dependent (not static) alignment between a base frame and the camera frame</span>
<span class="sd">        over multiple images.</span>

<span class="sd">        This method uses the :attr:`alignment_base_frame_func` to retrieve the rotation from the inertial frame to the</span>
<span class="sd">        base frame the alignment is to be done with respect to for each image time. Then, the rotation from the</span>
<span class="sd">        inertial frame to the camera frame is retrieved for each image from the</span>
<span class="sd">        :attr:`.Image.rotation_inertial_to_camera` attribute for each image (which is updated by a call to</span>
<span class="sd">        :meth:`estimate_attitude`).  These frame definitions are then provided to the</span>
<span class="sd">        :attr:`temperature_dependent_alignment_estimator` whose</span>
<span class="sd">        :meth:`~.TemperatureDependentAlignmentEstimator.estimate` method is then called to estimate the temperature</span>
<span class="sd">        dependent alignment.  The estimated alignment is then stored as a 3x2 numpy array where the first column is the</span>
<span class="sd">        static offset for the alignment, the second column is the temperature dependent slope, and each row represents</span>
<span class="sd">        the euler angle according to the requested order (so if the requested order is ``&#39;xyx&#39;`` then the rotation from</span>
<span class="sd">        the base frame to the camera frame at temperature ``t`` can be computed using:</span>

<span class="sd">            &gt;&gt;&gt; from giant.rotations import euler_to_rotmat, Rotation</span>
<span class="sd">            &gt;&gt;&gt; from giant.calibration.calibration_class import Calibration</span>
<span class="sd">            &gt;&gt;&gt; cal = Calibration()</span>
<span class="sd">            &gt;&gt;&gt; cal.estimate_temperature_dependent_alignment()</span>
<span class="sd">            &gt;&gt;&gt; t = -22.5</span>
<span class="sd">            &gt;&gt;&gt; angles = cal.temperature_dependent_alignment@[1, t]</span>
<span class="sd">            &gt;&gt;&gt; order = cal.temperature_dependent_alignment_estimator.order</span>
<span class="sd">            &gt;&gt;&gt; rotation_base_to_camera = Rotation(euler_to_rotmat(angles, order))</span>

<span class="sd">        This example is obviously incomplete but gives the concept of how things could be used.</span>

<span class="sd">        Note that to do alignment, the base frame and the camera frame should generally be fixed with respect to one</span>
<span class="sd">        another (with the exception of small variations with temperature).  This means that you can&#39;t do alignment with</span>
<span class="sd">        respect to something like the inertial frame in general, unless your camera is magically fixed with respect to</span>
<span class="sd">        the inertial frame.</span>

<span class="sd">        Generally, this method should be called after you have estimated the attitude for each image, because the</span>
<span class="sd">        estimated image pointing is used to estimate the alignment.  As such, only images where there are successfully</span>
<span class="sd">        matched stars are used in the estimation.</span>

<span class="sd">        .. Note::</span>
<span class="sd">            This method will attempt to account for misalignment estimated along with the camera model when performing</span>
<span class="sd">            the estimation; however, this is not recommended. Instead, once you have performed your camera model</span>
<span class="sd">            calibration, you should consider resetting the camera model misalignment to 0 and then calling</span>
<span class="sd">            :meth:`estimate_attitude` before a call to this function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># prepare the inputs</span>
        <span class="n">base_frame_rotations</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">camera_frame_rotations</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">temperatures</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="p">:</span>
            <span class="c1"># only consider images where we have matched stars</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matched_catalogue_unit_vectors_inertial</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="c1"># rotate the inertial catalogue directions into the base frame</span>
                <span class="n">base_frame_rotations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alignment_base_frame_func</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">observation_date</span><span class="p">))</span>

                <span class="c1"># get the unit vectors in the camera frame using the camera model</span>
                <span class="n">camera_rotation</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">rotation_inertial_to_camera</span>
                <span class="c1"># handle the misalignment if it exists</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="s1">&#39;get_misalignment&#39;</span><span class="p">):</span>
                    <span class="n">camera_rotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">get_misalignment</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span><span class="o">*</span><span class="n">camera_rotation</span>

                <span class="n">camera_frame_rotations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">camera_rotation</span><span class="p">)</span>

                <span class="n">temperatures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">temperature</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_temperature_dependent_alignment_est</span><span class="o">.</span><span class="n">frame_1_rotations</span> <span class="o">=</span> <span class="n">base_frame_rotations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temperature_dependent_alignment_est</span><span class="o">.</span><span class="n">frame_2_rotations</span> <span class="o">=</span> <span class="n">camera_frame_rotations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temperature_dependent_alignment_est</span><span class="o">.</span><span class="n">temperatures</span> <span class="o">=</span> <span class="n">temperatures</span>

        <span class="c1"># do the static alignment</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temperature_dependent_alignment_est</span><span class="o">.</span><span class="n">estimate</span><span class="p">()</span>

        <span class="c1"># store the results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">temperature_dependent_alignment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">_temperature_dependent_alignment_est</span><span class="o">.</span><span class="n">angle_m_offset</span><span class="p">,</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">_temperature_dependent_alignment_est</span><span class="o">.</span><span class="n">angle_m_slope</span><span class="p">],</span>
             <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_temperature_dependent_alignment_est</span><span class="o">.</span><span class="n">angle_n_offset</span><span class="p">,</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">_temperature_dependent_alignment_est</span><span class="o">.</span><span class="n">angle_n_slope</span><span class="p">],</span>
             <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_temperature_dependent_alignment_est</span><span class="o">.</span><span class="n">angle_p_offset</span><span class="p">,</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">_temperature_dependent_alignment_est</span><span class="o">.</span><span class="n">angle_p_slope</span><span class="p">]</span>
             <span class="p">]</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Calibration.reset_calibration_estimator"><a class="viewcode-back" href="../../../giant.calibration.html#giant.calibration.calibration_class.Calibration.reset_calibration_estimator">[docs]</a>    <span class="k">def</span> <span class="nf">reset_calibration_estimator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method resets the existing calibration estimator instance with a new instance using the initial</span>
<span class="sd">        ``calibration_estimator_update`` argument passed to the constructor.</span>

<span class="sd">        A new instance of the object is created, therefore there is no backwards reference whatsoever to the state</span>
<span class="sd">        before a call to this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_calibration_est_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calibration_est</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_calibration_est</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_camera</span><span class="o">.</span><span class="n">model</span><span class="p">,</span>
                                                                  <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_initial_calibration_est_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calibration_est</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_calibration_est</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_camera</span><span class="o">.</span><span class="n">model</span><span class="p">)</span></div>

<div class="viewcode-block" id="Calibration.update_calibration_estimator"><a class="viewcode-back" href="../../../giant.calibration.html#giant.calibration.calibration_class.Calibration.update_calibration_estimator">[docs]</a>    <span class="k">def</span> <span class="nf">update_calibration_estimator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calibration_estimator_update</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method updates the attributes of the :attr:`calibration_estimator` attribute.</span>

<span class="sd">        See the :mod:`.calibration.estimators` documentation for accepted attribute values.</span>

<span class="sd">        If a supplied attribute is not found in the :attr:`calibration_estimator` attribute then this will print a</span>
<span class="sd">        warning and ignore the attribute. Any attributes that are not supplied are left alone.</span>

<span class="sd">        :param calibration_estimator_update: A dictionary of attribute-&gt;value pairs to update the</span>
<span class="sd">                                             :attr:`calibration_estimator` attribute with</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">calibration_estimator_update</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">calibration_estimator_update</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_calibration_est</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_calibration_est</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The attribute </span><span class="si">{0}</span><span class="s2"> was not found.</span><span class="se">\n</span><span class="s2">&quot;</span>
                                  <span class="s2">&quot;Cannot update calibration estimation instance&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span></div>

<div class="viewcode-block" id="Calibration.reset_static_alignment_estimator"><a class="viewcode-back" href="../../../giant.calibration.html#giant.calibration.calibration_class.Calibration.reset_static_alignment_estimator">[docs]</a>    <span class="k">def</span> <span class="nf">reset_static_alignment_estimator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method replaces the existing static alignment estimator instance with a new instance</span>
<span class="sd">        using the initial ``static_alignment_estimator_kwargs`` argument passed to the constructor.</span>

<span class="sd">        A new instance of the object is created, therefore there is no backwards reference whatsoever to the state</span>
<span class="sd">        before a call to this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_static_alignment_est_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_static_alignment_est</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_static_alignment_est</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_initial_static_alignment_est_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_static_alignment_est</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_static_alignment_est</span><span class="p">()</span></div>

<div class="viewcode-block" id="Calibration.update_static_alignment_estimator"><a class="viewcode-back" href="../../../giant.calibration.html#giant.calibration.calibration_class.Calibration.update_static_alignment_estimator">[docs]</a>    <span class="k">def</span> <span class="nf">update_static_alignment_estimator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alignment_estimator_update</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method updates the attributes of the :attr:`static_alignment_estimator` attribute.</span>

<span class="sd">        See the :mod:`.calibration.estimators` documentation for accepted attribute values.</span>

<span class="sd">        If a supplied attribute is not found in the :attr:`static_alignment_estimator` attribute then this will print a</span>
<span class="sd">        warning and ignore the attribute. Any attributes that are not supplied are left alone.</span>

<span class="sd">        :param alignment_estimator_update: A dictionary of attribute-&gt;value pairs to update the</span>
<span class="sd">                                           :attr:`static_alignment_estimator` attribute with</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">alignment_estimator_update</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">alignment_estimator_update</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_static_alignment_est</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_static_alignment_est</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The attribute </span><span class="si">{0}</span><span class="s2"> was not found.</span><span class="se">\n</span><span class="s2">&quot;</span>
                                  <span class="s2">&quot;Cannot update static alignment estimation instance&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span></div>

<div class="viewcode-block" id="Calibration.reset_temperature_dependent_alignment_estimator"><a class="viewcode-back" href="../../../giant.calibration.html#giant.calibration.calibration_class.Calibration.reset_temperature_dependent_alignment_estimator">[docs]</a>    <span class="k">def</span> <span class="nf">reset_temperature_dependent_alignment_estimator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method replaces the existing temperature_dependent_alignment estimator instance with a new instance</span>
<span class="sd">        using the initial ``temperature_dependent_alignment_estimator_kwargs`` argument passed to the constructor.</span>

<span class="sd">        A new instance of the object is created, therefore there is no backwards reference whatsoever to the state</span>
<span class="sd">        before a call to this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_temperature_dependent_alignment_est_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_temperature_dependent_alignment_est</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_temperature_dependent_alignment_est</span><span class="p">(</span>
                <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_initial_temperature_dependent_alignment_est_kwargs</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_temperature_dependent_alignment_est</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_temperature_dependent_alignment_est</span><span class="p">()</span></div>

<div class="viewcode-block" id="Calibration.update_temperature_dependent_alignment_estimator"><a class="viewcode-back" href="../../../giant.calibration.html#giant.calibration.calibration_class.Calibration.update_temperature_dependent_alignment_estimator">[docs]</a>    <span class="k">def</span> <span class="nf">update_temperature_dependent_alignment_estimator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                                         <span class="n">temperature_dependent_alignment_estimator_update</span><span class="p">:</span>
                                                         <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method updates the attributes of the :attr:`temperature_dependent_alignment_estimator` attribute.</span>

<span class="sd">        See the :mod:`.calibration.estimators` documentation for accepted attribute values.</span>

<span class="sd">        If a supplied attribute is not found in the :attr:`temperature_dependent_alignment_estimator` attribute then </span>
<span class="sd">        this will print a warning and ignore the attribute. Any attributes that are not supplied are left alone.</span>

<span class="sd">        :param temperature_dependent_alignment_estimator_update: A dictionary of attribute-&gt;value pairs to update the</span>
<span class="sd">                                                                 :attr:`temperature_dependent_alignment_estimator` </span>
<span class="sd">                                                                 attribute with</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">temperature_dependent_alignment_estimator_update</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">temperature_dependent_alignment_estimator_update</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_temperature_dependent_alignment_est</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_temperature_dependent_alignment_est</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The attribute </span><span class="si">{0}</span><span class="s2"> was not found.</span><span class="se">\n</span><span class="s2">&quot;</span>
                                  <span class="s2">&quot;Cannot update temperature_dependent_alignment estimation instance&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span></div>

<div class="viewcode-block" id="Calibration.reset_settings"><a class="viewcode-back" href="../../../giant.calibration.html#giant.calibration.calibration_class.Calibration.reset_settings">[docs]</a>    <span class="k">def</span> <span class="nf">reset_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method resets all settings to their initially provided values (at class construction)</span>

<span class="sd">        Specifically, the following are reset</span>

<span class="sd">        * :attr:`star_id`</span>
<span class="sd">        * :attr:`image_processing`</span>
<span class="sd">        * :attr:`attitude_estimator`</span>
<span class="sd">        * :attr:`calibration_estimator`</span>
<span class="sd">        * :attr:`static_alignment_estimator`</span>
<span class="sd">        * :attr:`temperature_dependent_alignment_estimator`</span>

<span class="sd">        In each case, a new instance of the object is created supplying the corresponding ``_kwargs`` argument supplied</span>
<span class="sd">        when this class what initialized.</span>

<span class="sd">        This is simply a shortcut to calling the ``reset_XXX``` methods individually.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_star_id</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_image_processing</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_attitude_estimator</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_calibration_estimator</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_static_alignment_estimator</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_temperature_dependent_alignment_estimator</span><span class="p">()</span></div>

<div class="viewcode-block" id="Calibration.update_settings"><a class="viewcode-back" href="../../../giant.calibration.html#giant.calibration.calibration_class.Calibration.update_settings">[docs]</a>    <span class="k">def</span> <span class="nf">update_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">star_id_update</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">image_processing_update</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">attitude_estimator_update</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">calibration_estimator_update</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">static_alignment_estimator_update</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">temperature_dependent_alignment_estimator_update</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method updates all settings to their provided values</span>

<span class="sd">        Specifically, the following are updated depending on the input</span>

<span class="sd">        * :attr:`star_id`</span>
<span class="sd">        * :attr:`image_processing`</span>
<span class="sd">        * :attr:`attitude_estimator`</span>
<span class="sd">        * :attr:`calibration_estimator`</span>
<span class="sd">        * :attr:`static_alignment_estimator`</span>

<span class="sd">        In each case, the existing instance is modified in place with the attributes provided.  Any attributes that are</span>
<span class="sd">        not specified are left as is.</span>

<span class="sd">        This is simply a shortcut to calling the ``update_XXX`` methods individually.</span>

<span class="sd">        :param star_id_update: The updates to :attr:`star_id`.</span>
<span class="sd">        :param attitude_estimator_update: The updates to :attr:`attitude_estimator`.</span>
<span class="sd">        :param image_processing_update: The updates to :attr:`image_processing`.</span>
<span class="sd">        :param calibration_estimator_update: The updates to :attr:`calibration_estimator`.</span>
<span class="sd">        :param static_alignment_estimator_update: The updates to :attr:`static_alignment_estimator`.</span>
<span class="sd">        :param temperature_dependent_alignment_estimator_update: The updates to</span>
<span class="sd">                                                                 :attr:`temperature_dependent_alignment_estimator`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_star_id</span><span class="p">(</span><span class="n">star_id_update</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_image_processing</span><span class="p">(</span><span class="n">image_processing_update</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_attitude_estimator</span><span class="p">(</span><span class="n">attitude_estimator_update</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_calibration_estimator</span><span class="p">(</span><span class="n">calibration_estimator_update</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_static_alignment_estimator</span><span class="p">(</span><span class="n">static_alignment_estimator_update</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_temperature_dependent_alignment_estimator</span><span class="p">(</span><span class="n">temperature_dependent_alignment_estimator_update</span><span class="p">)</span></div>

<div class="viewcode-block" id="Calibration.calib_summary"><a class="viewcode-back" href="../../../giant.calibration.html#giant.calibration.calibration_class.Calibration.calib_summary">[docs]</a>    <span class="k">def</span> <span class="nf">calib_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">measurement_covariance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SCALAR_OR_ARRAY</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This prints a summary of the results of calibration to the screen</span>

<span class="sd">        The resulting summary displays the labeled covariance matrix, followed by the labeled correlation coefficients,</span>
<span class="sd">        followed by the state parameters and their formal uncertainty.</span>

<span class="sd">        One optional inputs can be used to specify the uncertainty on the measurements if weighted estimation wasn&#39;t</span>
<span class="sd">        already used to ensure the post-fit covariance</span>
<span class="sd">        has the proper scaling.</span>

<span class="sd">        Note that if multiple misalignments were estimated in the calibration, only the first is printed in the</span>
<span class="sd">        correlation and covariance matrices.  For all misalignments, the values are replaced with NaN.</span>

<span class="sd">        :param measurement_covariance: The covariance for the measurements either as a nxn matrix or as a scalar.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">measurement_covariance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calibration_est</span><span class="o">.</span><span class="n">weighted_estimation</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calibration_est</span><span class="o">.</span><span class="n">measurement_covariance</span> <span class="o">=</span> <span class="n">measurement_covariance</span>
            <span class="n">covariance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calibration_estimator</span><span class="o">.</span><span class="n">postfit_covariance</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">covariance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calibration_estimator</span><span class="o">.</span><span class="n">postfit_covariance</span>

        <span class="c1"># get the uncertainty for each parameter</span>
        <span class="n">sigmas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">covariance</span><span class="p">))</span>

        <span class="c1"># compute the correlation coefficients</span>
        <span class="n">coefficients</span> <span class="o">=</span> <span class="n">covariance</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">covariance</span><span class="p">))]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># get the labels for each element</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">get_state_labels</span><span class="p">()</span>  <span class="c1"># type: list</span>

        <span class="c1"># if misalignment is in labels we need to do some fancy manipulation</span>
        <span class="k">if</span> <span class="s1">&#39;misalignment&#39;</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;misalignment&#39;</span><span class="p">)</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;align_x&#39;</span><span class="p">)</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;align_y&#39;</span><span class="p">)</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;align_z&#39;</span><span class="p">)</span>

        <span class="c1"># print the covariance matrix</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Covariance:&#39;</span><span class="p">)</span>
        <span class="n">_print_lr</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>

        <span class="c1"># print the correlation coefficient matrix and get the maximum label size</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Correlation coefficients:&#39;</span><span class="p">)</span>
        <span class="n">max_label</span> <span class="o">=</span> <span class="n">_print_lr</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">)</span>

        <span class="c1"># build the format strings for the parameter/formal uncertainty pairs</span>
        <span class="n">label_format</span> <span class="o">=</span> <span class="s1">&#39;{:&lt;&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">max_label</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;s}&#39;</span>
        <span class="n">number_format</span> <span class="o">=</span> <span class="s1">&#39;{:&gt;&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">max_label</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">max_label</span> <span class="o">-</span> <span class="mi">7</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;e}&#39;</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="n">label_format</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">number_format</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">number_format</span>
        <span class="n">state_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">state_vector</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Parameter value and formal uncertainty:&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">&#39;align&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">state_vector</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">sigmas</span><span class="p">[</span><span class="n">ind</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">sigmas</span><span class="p">[</span><span class="n">ind</span><span class="p">]))</span></div>

<div class="viewcode-block" id="Calibration.limit_magnitude"><a class="viewcode-back" href="../../../giant.calibration.html#giant.calibration.calibration_class.Calibration.limit_magnitude">[docs]</a>    <span class="k">def</span> <span class="nf">limit_magnitude</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_magnitude</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">max_magnitude</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Calibration&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method removes stars from the ``matched_...`` attributes that are not within the provided magnitude bounds.</span>

<span class="sd">        This method should be used rarely, as you can typically achieve the same functionality by use the</span>
<span class="sd">        :attr:`.StarID.max_magnitude` and :attr:`.StarID.min_magnitude` attributes before calling :meth:`id_stars`.  The</span>
<span class="sd">        most typical use case for this method is when you have already completed a full calibration and you now either</span>
<span class="sd">        want to filter out some of the stars for plotting purposes, or you want to filter out some of the stars to do an</span>
<span class="sd">        alignment analysis, where it is generally better to use only well exposed stars since fewer are needed to</span>
<span class="sd">        fully define the alignment.</span>

<span class="sd">        When you use this method, by default it will edit and return a copy of the current instance to preserve the</span>
<span class="sd">        current instance.  if you are using many images with many stars in them this can use a large amount of memory;</span>
<span class="sd">        however, so you can optionally specify ``in_place=True`` to modify the current instance in place.  Note however</span>
<span class="sd">        that this not a reversible operation (that is you cannot get back to the original state) so be cautious about</span>
<span class="sd">        using this option.</span>

<span class="sd">        :param min_magnitude: The minimum star magnitude to accept (recall that minimum magnitude limits the brightest</span>
<span class="sd">                              stars)</span>
<span class="sd">        :param max_magnitude: The maximum star magnitude to accept (recall that maximum magnitude limits the dimmest</span>
<span class="sd">                              stars)</span>
<span class="sd">        :param in_place: A flag specifying whether to work on a copy or the original</span>
<span class="sd">        :return: The edited Calibration instance (either a copy or a reference)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">camera</span><span class="p">:</span>
            <span class="c1"># test which stars don&#39;t meet the requirements</span>
            <span class="n">mag_test</span> <span class="o">=</span> <span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">matched_catalogue_star_records</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">mag</span><span class="o">.</span><span class="n">values</span> <span class="o">&gt;=</span> <span class="n">max_magnitude</span><span class="p">)</span> <span class="o">|</span> \
                       <span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">matched_catalogue_star_records</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">mag</span><span class="o">.</span><span class="n">values</span> <span class="o">&lt;=</span> <span class="n">min_magnitude</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">mag_test</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">indicies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">mag_test</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

                <span class="n">out</span><span class="o">.</span><span class="n">remove_matched_stars</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">indicies</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div></div>
</pre></div>

          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2021 United States Government.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>