
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>giant.stellar_opnav.star_identification &#8212; GIANT 1.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../copyright.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/logo.png" alt="Logo"/>
    
  </a>
</p>



<p class="blurb">A powerful API for Optical Navigation</p>






<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installing GIANT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../giant.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../giant.html#indices">Indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../copyright.html">Copyright</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <h1>Source code for giant.stellar_opnav.star_identification</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2021 United States Government as represented by the Administrator of the National Aeronautics and Space</span>
<span class="c1"># Administration.  No copyright is claimed in the United States under Title 17, U.S. Code. All Other Rights Reserved.</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module provides the star identification routines for GIANT through the :class:`StarID` class.</span>

<span class="sd">Algorithm Description</span>
<span class="sd">_____________________</span>

<span class="sd">Star Identification refers to the process of matching observed stars in an image with a corresponding set of known star</span>
<span class="sd">locations from a star catalogue. Making this identification is the first step in performing a number of OpNav tasks,</span>
<span class="sd">including attitude estimation, geometric camera calibration, and camera alignment, as well as a number of photometry</span>
<span class="sd">tasks like linearity checks and point spread function modelling.</span>

<span class="sd">In GIANT, star identification is handled using a random sampling and consensus (RANSAC) approach using the following</span>
<span class="sd">steps:</span>

<span class="sd">#. The *a priori* attitude information for each image is used to query the star catalogue for the expected stars in the</span>
<span class="sd">   field of view of each image.</span>
<span class="sd">#. The retrieved catalogue stars are transformed into the camera frame and projected onto the image using the *a priori*</span>
<span class="sd">   image attitude and camera model.</span>
<span class="sd">#. The projected catalogue locations are paired with points in the image that were identified in the image by the image</span>
<span class="sd">   processing algorithm as potential stars using a nearest neighbor approach.</span>
<span class="sd">#. The initial pairs are thresholded based on the distance between the points, as well as for stars that are matched</span>
<span class="sd">   with 2 image points and image points that are close to 2 stars.</span>
<span class="sd">#. The remaining pairs are randomly sampled for 4 star pairs</span>
<span class="sd">#. The sample is used to estimate a new attitude for the image using the :class:`.DavenportQMethod` routines.</span>
<span class="sd">#. The new solved for attitude is used to re-rotate and project the catalogue stars onto the image.</span>
<span class="sd">#. The new projections are compared with their matched image points and the number of inlier pairs (pairs whose distance</span>
<span class="sd">   is less than some ransac threshold) are counted.</span>
<span class="sd">#. The number of inliers is compared to the maximum number of inliers found by any sample to this point (set to 0 if</span>
<span class="sd">   this is the first sample) and:</span>

<span class="sd">   * if there are more inliers</span>

<span class="sd">     * the maximum number of inliers is set to the number of inliers generated for this sample</span>
<span class="sd">     * the inliers for this sample are stored as correctly identified stars</span>
<span class="sd">     * the sum of the squares of the distances between the inlier pairs for this sample is stored</span>

<span class="sd">   * if there are an equivalent number of inliers to the previous maximum number of inliers then the sum of the squares</span>
<span class="sd">     of the distance between the pairs of inliers is compared to the sum of the squares of the previous inliers and if</span>
<span class="sd">     the new sum of squares is less than the old sum of squares</span>

<span class="sd">     * the maximum number of inliers is set to the number of inliers generated for this sample</span>
<span class="sd">     * the inliers are stored as correctly identified stars</span>
<span class="sd">     * the sum of the squares of the distances between the inlier pairs is stored</span>

<span class="sd">#. Steps 5-9 are repeated for a number of iterations, and the final set of stars stored as correctly identified stars</span>
<span class="sd">   become the identified stars for the image.</span>

<span class="sd">It is also possible to skip the RANSAC algorithm, stopping at step 4 above and marking any pairs that remain after the</span>
<span class="sd">check as correctly identified stars.</span>

<span class="sd">.. note::</span>
<span class="sd">    For the above algorithm an *a priori* attitude is needed for each image in which stars are being identified.  While </span>
<span class="sd">    most OpNav images will have an *a priori* attitude, in some cases they may not due to anomalies on the spacecraft.  </span>
<span class="sd">    This is known as the *lost-in-space* problem.  Currently GIANT does not have the ability to handle the lost-in-space</span>
<span class="sd">    problem and the user will first need to use other software to determine an *a priori* attitude for the images (such </span>
<span class="sd">    as `astrometry.net &lt;http://astrometry.net&gt;`_).  We are currently developing the algorithms required to perform lost</span>
<span class="sd">    in space star identification using hash code based pattern matching (similar to the techniques used by </span>
<span class="sd">    *astrometry.net*) in GIANT, but they are unfortunately not complete yet.</span>

<span class="sd">Unfortunately, the star identification routines do require some human input to be successful.  This involves tuning</span>
<span class="sd">various parameters to get a good initial match.  Luckily, once these parameters are tuned for a few images for a</span>
<span class="sd">certain camera set under certain conditions, they largely should apply well to all similar images from that camera.</span>
<span class="sd">Below we discuss the different tuning parameters that are available in the :class:`StarID` class, and also some</span>
<span class="sd">techniques for getting successful identifications.</span>

<span class="sd">Tuning the StarID routines</span>
<span class="sd">__________________________</span>

<span class="sd">There are a few different parameters that can be tuned in the :class:`StarID` class when attempting to get a successful</span>
<span class="sd">star identification for a set of images.  Each of these parameters and what they control are described in the following</span>
<span class="sd">table.</span>

<span class="sd">.. _tuning-parameters-table:</span>

<span class="sd">===================================== ==================================================================================</span>
<span class="sd">Parameter                             Description</span>
<span class="sd">===================================== ==================================================================================</span>
<span class="sd">:attr:`~.StarID.max_magnitude`        The maximum magnitude to query the star catalogue to.  This is useful for</span>
<span class="sd">                                      limiting the number of catalogue stars that are being matched against.</span>
<span class="sd">                                      Remember that stellar magnitude is on an inverse logarithmic scale, therefore</span>
<span class="sd">                                      the higher you set this number the dimmer stars that will be returned.</span>
<span class="sd">:attr:`~.StarID.min_magnitude`        The minimum magnitude to query the star catalogue to.  This is useful for</span>
<span class="sd">                                      limiting the number of catalogue stars that are being matched against.</span>
<span class="sd">                                      Remember that stellar magnitude is on an inverse logarithmic scale, therefore</span>
<span class="sd">                                      the lower you set this number the brighter stars that will be returned.</span>
<span class="sd">                                      Typically this should be left alone.</span>
<span class="sd">:attr:`~.StarID.max_combos`           The maximum number of samples to try in the RANSAC algorithm.  The RANSAC</span>
<span class="sd">                                      algorithm will try at most :attr:`~StarID.max_combos` combinations when</span>
<span class="sd">                                      attempting to identify stars. The only way it will try less than</span>
<span class="sd">                                      :attr:`~.StarID.max_combos` is if there are less unique sample combinations</span>
<span class="sd">                                      possible, in which case the RANSAC algorithm will try every possible sample</span>
<span class="sd">                                      (and becomes just a simple Sampling and Consensus algorithm).  This parameter</span>
<span class="sd">                                      is also used to turn off the RANSAC algorithm by setting it to 0.  This stops</span>
<span class="sd">                                      the star identification process at step 4 from above.</span>
<span class="sd">:attr:`~.StarID.tolerance`            The maximum initial distance that a catalogue-image poi pair can have for it to be</span>
<span class="sd">                                      considered a potential match in units of pixels. This is the tolerance that is</span>
<span class="sd">                                      applied before the RANSAC to filter out nearest neighbor pairs that are too far</span>
<span class="sd">                                      apart to be potential matches.</span>
<span class="sd">:attr:`~.StarID.ransac_tolerance`     The maximum post-fit distance that a catalogue-image poi pair can have for it to</span>
<span class="sd">                                      be considered an inlier in the RANSAC algorithm in units of pixels.  This is</span>
<span class="sd">                                      the tolerance used inside of the RANSAC algorithm to determine the number of</span>
<span class="sd">                                      inliers for a given attitude solution from a sample.  This should always be</span>
<span class="sd">                                      less than the :attr:`~.StarID.tolerance` parameter.</span>
<span class="sd">:attr:`~.StarID.second_closest_check` A flag specifying whether to check if the second closest catalogue star to an</span>
<span class="sd">                                      image poi is also within the :attr:`~.StarID.tolerance` distance.  This is</span>
<span class="sd">                                      useful for throwing out potential pairs that may be ambiguous.  In general you</span>
<span class="sd">                                      should set this flag to ``False`` when your initial attitude/camera model error is</span>
<span class="sd">                                      larger, and ``True`` after removing those large errors.</span>
<span class="sd">:attr:`~.StarID.unique_check`         A flag specifying whether to allow a single catalogue star to be potentially</span>
<span class="sd">                                      paired with multiple image points of interest.  In general you</span>
<span class="sd">                                      should set this flag to ``False`` when your initial attitude/camera model error is</span>
<span class="sd">                                      larger, and ``True`` after removing those large errors.</span>
<span class="sd">===================================== ==================================================================================</span>

<span class="sd">By tuning these parameters, you should be able to identify stars in nearly any image with an *a priori* attitude that is</span>
<span class="sd">remotely close.  There are a few suggestions that may help you to find the proper tuning faster:</span>

<span class="sd">* Getting the initial identification is generally the most difficult; therefore, you should generally have 2 tunings</span>
<span class="sd">  for an image set.</span>
<span class="sd">* The first tuning should be fairly conservative in order to get a good refined attitude estimate for the image.  </span>
<span class="sd">  (Remember that we really only need 4 or 5 correctly identified stars to get a good attitude estimate.) </span>

<span class="sd">  * a large initial :attr:`~.StarID.tolerance`--greater than 10 pixels.  Note that this initial tolerance should include</span>
<span class="sd">    the errors in the star projections due to both the *a priori* attitude uncertainty and the camera model</span>
<span class="sd">  * a smaller but still relatively large :attr:`~.StarID.ransac_tolerance`--on the order of about 1-5 pixels. This</span>
<span class="sd">    tolerance should mostly reflect a very conservative estimate on the errors caused by the camera model as the</span>
<span class="sd">    attitude errors should largely be removed</span>
<span class="sd">  * a small :attr:`~.StarID.max_magnitude`--only allowing bright stars.  Bright stars generally have more accurate</span>
<span class="sd">    catalogue positions and are more likely to be picked up by the :class:`.ImageProcessing` algorithms</span>
<span class="sd">  * the :attr:`~.StarID.max_combos` set fairly large--on the order of 500-1000</span>
<span class="sd">  </span>
<span class="sd">* After getting the initial pairing and updating</span>
<span class="sd">  the attitude for the images (note that this is done external to the :class:`StarID` class), you can then attempt a </span>
<span class="sd">  larger identification with dimmer stars</span>

<span class="sd">  * decreasing the :attr:`~.StarID.tolerance` to be about the same as your previous :attr:`~.StarID.ransac_tolerance`</span>
<span class="sd">  * turning the RANSAC algorithm off by setting the :attr:`~.StarID.max_combos` to 0</span>
<span class="sd">  * increasing the :attr:`~.StarID.max_magnitude`.</span>
<span class="sd">  </span>
<span class="sd">* If you are having problems getting the identification to work it can be useful to visually examine the results for a</span>
<span class="sd">  couple of images using the :func:`.show_id_results` function.</span>

<span class="sd">.. warning::</span>

<span class="sd">    This script loads the lost in space catalogue from python pickle files.  Pickle files can be used to execute</span>
<span class="sd">    arbitrary code, so you should never open one from an untrusted source.  While this code should only be reading</span>
<span class="sd">    pickle files generated by GIANT itself that are safe, you should verify that the :attr:`LIS_FILE` and the file it</span>
<span class="sd">    points to have not been tampered with to be absolutely sure.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="c1"># import random</span>
<span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">it</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="c1"># added warning to documentation</span>
<span class="kn">import</span> <span class="nn">pickle</span>  <span class="c1"># nosec</span>

<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">spatial</span> <span class="k">as</span> <span class="n">spat</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">comb</span>

<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">scipy.misc</span> <span class="kn">import</span> <span class="n">comb</span>

<span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">DataFrame</span>

<span class="kn">from</span> <span class="nn">giant.stellar_opnav.estimators</span> <span class="kn">import</span> <span class="n">DavenportQMethod</span>
<span class="kn">from</span> <span class="nn">giant</span> <span class="kn">import</span> <span class="n">catalogues</span> <span class="k">as</span> <span class="n">cat</span>
<span class="kn">from</span> <span class="nn">giant.ray_tracer.scene</span> <span class="kn">import</span> <span class="n">correct_stellar_aberration</span>
<span class="kn">from</span> <span class="nn">giant.camera_models</span> <span class="kn">import</span> <span class="n">CameraModel</span>
<span class="kn">from</span> <span class="nn">giant.rotations</span> <span class="kn">import</span> <span class="n">Rotation</span>
<span class="kn">from</span> <span class="nn">giant.catalogues.meta_catalogue</span> <span class="kn">import</span> <span class="n">Catalogue</span>
<span class="kn">from</span> <span class="nn">giant.catalogues.utilities</span> <span class="kn">import</span> <span class="n">radec_to_unit</span>
<span class="kn">from</span> <span class="nn">giant._typing</span> <span class="kn">import</span> <span class="n">NONEARRAY</span><span class="p">,</span> <span class="n">Real</span><span class="p">,</span> <span class="n">PATH</span>
<span class="kn">from</span> <span class="nn">giant.catalogues.utilities</span> <span class="kn">import</span> <span class="n">RAD2DEG</span><span class="p">,</span> <span class="n">unit_to_radec</span>
<span class="kn">from</span> <span class="nn">giant.utilities.random_combination</span> <span class="kn">import</span> <span class="n">RandomCombinations</span>


<span class="n">LIS_FILE</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span> <span class="o">/</span> <span class="s2">&quot;catalogues&quot;</span> <span class="o">/</span> <span class="s2">&quot;data&quot;</span> <span class="o">/</span> <span class="s1">&#39;lis.pickle&#39;</span>  <span class="c1"># type: Path</span>


<span class="c1"># def random_combination(n: int, r: int) -&gt; tuple:</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     This returns a random sample of r indices from n objects</span>
<span class="c1">#</span>
<span class="c1">#     :param n: The number of objects to choose from</span>
<span class="c1">#     :param r: The number of objects to choose for each sample</span>
<span class="c1">#     :return: The indices for a random sample as a tuple</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     return random.sample(range(n), r)</span>


<div class="viewcode-block" id="StarID"><a class="viewcode-back" href="../../../stellar_opnav/star_identification/giant.stellar_opnav.star_identification.StarID.html#giant.calibration.StarID">[docs]</a><span class="k">class</span> <span class="nc">StarID</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The StarID class operates on the result of image processing algorithms to attempt to match image points of interest</span>
<span class="sd">    with catalogue star records.</span>

<span class="sd">    This is a necessary step in all forms of stellar OpNav and is a critical component of</span>
<span class="sd">    GIANT.</span>

<span class="sd">    In general, the user will not directly interface with the :class:`StarID` class and instead will use the</span>
<span class="sd">    :class:`.StellarOpNav` class.  Below we give a brief description of how to use this class directly for users who</span>
<span class="sd">    are just curious or need more direct control over the class.</span>

<span class="sd">    There are a couple things that the :class:`StarID` class needs to operate.  The first is a camera model, which</span>
<span class="sd">    should be a subclass of :class:`.CameraModel`.  The camera model is used to both project catalogue star locations</span>
<span class="sd">    onto the image, as well as generate unit vectors through the image points of interest in the camera frame.  The</span>
<span class="sd">    next thing the :class:`StarID` class needs is a star catalogue to query.  This should come from the</span>
<span class="sd">    :mod:`.catalogues` package and provides all of the necessary information for retrieving and projecting the expected</span>
<span class="sd">    stars in an image. Both the star catalogue and camera model are generally set at the construction of the class</span>
<span class="sd">    and apply to every image being considered, so they are rarely updated.  The camera model is stored in the</span>
<span class="sd">    :attr:`model` attribute and is also specified as the first positional argument for the class constructor.  The</span>
<span class="sd">    catalogue is stored in the :attr:`catalogue` attribute and can also be specified in the class constructor as a</span>
<span class="sd">    keyword argument of the same name.</span>

<span class="sd">    The :class:`StarID` class also needs some information about the current image being considered.  This information</span>
<span class="sd">    includes points of interest for the image that need to be matched to stars, the *a priori* attitude of the image,</span>
<span class="sd">    and the position/velocity of the camera at the time the image was captured.  The points of interest are generally</span>
<span class="sd">    returned from the :class:`.ImageProcessing` routines, although they don&#39;t need to be.  The camera attitude,</span>
<span class="sd">    position, and velocity are generally passed from the :class:`.OpNavImage` metadata.  The image attitude is used for</span>
<span class="sd">    querying the catalogue and rotating the catalogue stars into the image frame.  The camera positions and velocity</span>
<span class="sd">    are used for correcting the star locations for parallax and stellar aberration. The camera position and velocity are</span>
<span class="sd">    not required but are generally recommended as they will give a more accurate representation.  All of these</span>
<span class="sd">    attributes need to be updated for each new image being considered (the :class:`StarID` class does not directly</span>
<span class="sd">    operate on the :class:`.OpNavImage` objects).  The image points of interest are stored and updated in the</span>
<span class="sd">    :attr:`extracted_image_points` attribute, the camera attitude is stored in the :attr:`a_priori_rotation_cat2camera`</span>
<span class="sd">    attribute, and the camera position and velocity are stored in the :attr:`camera_position` and</span>
<span class="sd">    :attr:`camera_velocity` attributes respectively.  They can also be specified in the class constructor as keyword</span>
<span class="sd">    arguments of the same name.</span>

<span class="sd">    Finally, there are a number of tuning parameters that need set.  These parameters are discussed in depth in the</span>
<span class="sd">    :ref:`Tuning Parameters Table &lt;tuning-parameters-table&gt;`.</span>

<span class="sd">    When everything is correctly set in an instance of :class:`StarID`, then generally all that needs to be called</span>
<span class="sd">    is the :meth:`id_stars` method, which accepts the observation date of the image being considered as an</span>
<span class="sd">    optional ``epoch`` keyword argument.  This method will go through the whole processed detailed above, storing the</span>
<span class="sd">    results in a number of attributes that are detailed below.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        This class will load data for the lost in space catalogue.  The lost is space catalogue is a pickle file. Pickle</span>
<span class="sd">        files can be used to execute arbitrary code, so you should never open one from an untrusted source.  While this</span>
<span class="sd">        code should only be reading pickle files generated by GIANT itself that are safe, you should verify that the</span>
<span class="sd">        :attr:`lost_in_space_catalogue_file` and the file it points to have not been tampered with to be absolutely</span>
<span class="sd">        sure.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">CameraModel</span><span class="p">,</span> <span class="n">extracted_image_points</span><span class="p">:</span> <span class="n">NONEARRAY</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">catalogue</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Catalogue</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">max_magnitude</span><span class="p">:</span> <span class="n">Real</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="n">min_magnitude</span><span class="p">:</span> <span class="n">Real</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span>
                 <span class="n">max_combos</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">:</span> <span class="n">Real</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">a_priori_rotation_cat2camera</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Rotation</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">ransac_tolerance</span><span class="p">:</span> <span class="n">Real</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">second_closest_check</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">camera_velocity</span><span class="p">:</span> <span class="n">NONEARRAY</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">camera_position</span><span class="p">:</span> <span class="n">NONEARRAY</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">unique_check</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">use_mp</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">lost_in_space_catalogue_file</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">PATH</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param model: The camera model to use to relate vectors in the camera frame with points on the image</span>
<span class="sd">        :param extracted_image_points: A 2xn array of the image points of interest to be identified.  The first row</span>
<span class="sd">                                       should correspond to the y locations (rows) and the second row should correspond</span>
<span class="sd">                                       to the x locations (columns).</span>
<span class="sd">        :param catalogue: The catalogue object to use to query for potential stars in an image.</span>
<span class="sd">        :param max_magnitude:  the maximum magnitude to return when querying the star catalogue</span>
<span class="sd">        :param min_magnitude:  the minimum magnitude to return when querying the star catalogue</span>
<span class="sd">        :param max_combos: The maximum number of random samples to try in the RANSAC routine</span>
<span class="sd">        :param tolerance: The maximum distance between a catalogue star and a image point of interest for a potential</span>
<span class="sd">                          pair to be formed before the RANSAC algorithm</span>
<span class="sd">        :param a_priori_rotation_cat2camera: The rotation matrix to go from the inertial frame to the camera frame</span>
<span class="sd">        :param ransac_tolerance: The maximum distance between a catalogue star and an image point of interest after</span>
<span class="sd">                                 correcting the attitude for a pair to be considered an inlier in the RANSAC algorithm.</span>
<span class="sd">        :param second_closest_check: A flag specifying whether to reject pairs where 2 catalogue stars are close to an</span>
<span class="sd">                                     image point of interest</span>
<span class="sd">        :param camera_velocity: The velocity of the camera in km/s with respect to the solar system barycenter in the</span>
<span class="sd">                                inertial frame at the time the image was taken</span>
<span class="sd">        :param camera_position: The position of the camera in km with respect to the solar system barycenter in the</span>
<span class="sd">                                inertial frame at the time the image was taken</span>
<span class="sd">        :param unique_check: A flag specifying whether to allow a single catalogue star to be potentially paired with</span>
<span class="sd">                             multiple image points of interest</span>
<span class="sd">        :param use_mp: A flag specifying whether to use the multi-processing library to accelerate the RANSAC algorithm</span>
<span class="sd">        :param lost_in_space_catalogue_file: The file containing the lost in space catalogue</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># initialize temporary attributes to make multiprocessing easier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_image_locs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_image_dirs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_catalogue_dirs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_temperature</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_image_number</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_combinations</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_att_est</span> <span class="o">=</span> <span class="n">DavenportQMethod</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>  <span class="c1"># type: CameraModel</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The camera model which relates points in the camera frame to points in the image and vice-versa.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">camera_position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>  <span class="c1"># type: np.ndarray</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The position of the camera with respect to the solar system barycenter in the inertial frame at the time the </span>
<span class="sd">        image was captured as a length 3 numpy array of floats.</span>

<span class="sd">        Typically this is stored in the :attr:`.OpNavImage.position` attribute</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">camera_position</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">camera_position</span> <span class="o">=</span> <span class="n">camera_position</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">camera_velocity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>  <span class="c1"># type: np.ndarray</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The velocity of the camera with respect to the solar system barycenter in the inertial frame at the time the </span>
<span class="sd">        image was captured as a length 3 numpy array of floats.</span>
<span class="sd">        </span>
<span class="sd">        Typically this is stored in the :attr:`.OpNavImage.velocity` attribute</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">camera_velocity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">camera_velocity</span> <span class="o">=</span> <span class="n">camera_velocity</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">extracted_image_points</span> <span class="o">=</span> <span class="n">extracted_image_points</span>  <span class="c1"># type: np.ndarray</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        a 2xn array of the image points of interest to be paired with catalogue stars.  </span>
<span class="sd">        </span>
<span class="sd">        the first row should correspond to the x locations (columns) and the second row should correspond</span>
<span class="sd">        to the y locations (rows).</span>
<span class="sd">        </span>
<span class="sd">        typically this is retrieved from a call to :meth:`.ImageProcessing.locate_subpixel_poi_in_roi`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">catalogue</span> <span class="o">=</span> <span class="n">catalogue</span>  <span class="c1"># type: Catalogue</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The star catalogue to use when pairing image points with star locations.</span>
<span class="sd">        </span>
<span class="sd">        This typically should be a subclass of the :class:`.Catalogue` class.  It defaults to the </span>
<span class="sd">        :class:`.GIANTCatalogue`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalogue</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">catalogue</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">GIANTCatalogue</span><span class="p">()</span>

        <span class="c1"># store the a priori attitude of the camera</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a_priori_rotation_cat2camera</span> <span class="o">=</span> <span class="n">a_priori_rotation_cat2camera</span>  <span class="c1"># type: Rotation</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This contains the a priori rotation knowledge from the catalogue frame (typically the inertial frame) to the</span>
<span class="sd">        camera frame at the time of the image.</span>
<span class="sd">        </span>
<span class="sd">        This typically is stored as the :attr:`.OpNavImage.rotation_inertial_to_camera` attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">max_magnitude</span> <span class="o">=</span> <span class="n">max_magnitude</span>  <span class="c1"># type: Real</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The maximum star magnitude to query from the star catalogue.</span>

<span class="sd">        This specifies how dim stars are expected to be in the :attr:`extracted_image_points` data set.  This is </span>
<span class="sd">        typically dependent on both the detector and the exposure length of the image under consideration.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">min_magnitude</span> <span class="o">=</span> <span class="n">min_magnitude</span>  <span class="c1"># type: Real</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The minimum star magnitude to query from the star catalogue.</span>
<span class="sd">        </span>
<span class="sd">        This specifies how dim stars are expected to be in the :attr:`extracted_image_points` data set.  This is </span>
<span class="sd">        typically dependent on both the detector and the exposure length of the image under consideration.</span>
<span class="sd">        </span>
<span class="sd">        Generally this should be left alone unless you are worried about over exposed stars (in which case </span>
<span class="sd">        :attr:`.ImageProcessing.reject_saturation` may be more useful) or you are doing some special analysis.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">tolerance</span>  <span class="c1"># type: Real</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The maximum distance in units of pixels between a projected catalogue location and an extracted image point</span>
<span class="sd">        for a possible pairing to be made for consideration in the RANSAC algorithm.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># store the maximum number of ransac samples to try</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_combos</span> <span class="o">=</span> <span class="n">max_combos</span>  <span class="c1"># type: int</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The maximum number of random combinations to try in the RANSAC algorithm.  </span>
<span class="sd">        </span>
<span class="sd">        If the total possible number of combinations is less than this attribute then an exhaustive search will be </span>
<span class="sd">        performed instead</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ransac_tolerance</span> <span class="o">=</span> <span class="n">ransac_tolerance</span>  <span class="c1"># type: Real</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The tolerance that is required after correcting for attitude errors for a pair to be considered an inlier</span>
<span class="sd">        in the RANSAC algorithm in units of pixels.</span>
<span class="sd">        </span>
<span class="sd">        This should always be less than the :attr:`tolerance` attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># store the second closest check and uniqueness flags</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">second_closest_check</span> <span class="o">=</span> <span class="n">second_closest_check</span>  <span class="c1"># type: bool</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A boolean specifying whether to ignore extracted image points where multiple catalogue points are within the</span>
<span class="sd">        specified tolerance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">unique_check</span> <span class="o">=</span> <span class="n">unique_check</span>  <span class="c1"># type: bool</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A boolean specifying whether to ignore possible catalogue to image point pairs where multiple image points are </span>
<span class="sd">        within the specified tolerance of a single catalogue point.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">use_mp</span> <span class="o">=</span> <span class="n">use_mp</span>  <span class="c1"># type: bool</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A boolean flag specifying whether to use multi-processing to speed up the RANSAC process.</span>
<span class="sd">        </span>
<span class="sd">        If this is set to True then all available CPU cores will be utilized to parallelize the RANSAC algorithm </span>
<span class="sd">        computations.  For small combinations, the overhead associated with this can swamp any benefit that may be </span>
<span class="sd">        realized.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># initialize the attributes for storing the star identification results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalogue_image_points</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: NONEARRAY</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A 2xn numpy array of points containing the projected image points for all catalogue stars that were queried from </span>
<span class="sd">        the star catalogue  with x (columns) in the first row and y (rows) in the second row.  </span>
<span class="sd">        </span>
<span class="sd">        Each column corresponds to the same row in :attr:`queried_catalogue_star_records`.</span>
<span class="sd">        </span>
<span class="sd">        Until :meth:`project_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalogue_star_records</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: Optional[DataFrame]</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A pandas DataFrame of all the catalogue star records that were queried.  </span>

<span class="sd">        See the :class:`.Catalogue` class for a description of the columns of the dataframe.</span>
<span class="sd">        </span>
<span class="sd">        Until :meth:`project_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalogue_unit_vectors</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: NONEARRAY</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A 3xn numpy array of unit vectors in the inertial frame for all catalogue stars that were queried from </span>
<span class="sd">        the star catalogue.  </span>
<span class="sd">        </span>
<span class="sd">        Each column corresponds to the same row in :attr:`queried_catalogue_star_records`.</span>

<span class="sd">        Until :meth:`project_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_inertial</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: NONEARRAY</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This contains the formal total uncertainty for each unit vector from the queried catalogue stars.  </span>
<span class="sd">        </span>
<span class="sd">        Each element in this array corresponds to the same row in the :attr:`queried_catalogue_star_records`.</span>
<span class="sd">        </span>
<span class="sd">        Until :meth:`id_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_picture</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: NONEARRAY</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This contains the formal total uncertainty for each projected pixel location from the queried catalogue stars in</span>
<span class="sd">        units of pixels..  </span>
<span class="sd">        </span>
<span class="sd">        Each element in this array corresponds to the same row in the :attr:`queried_catalogue_star_records`.</span>

<span class="sd">        Until :meth:`id_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_catalogue_image_points</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A 2xn numpy array of points containing the projected image points for all catalogue stars that not matched</span>
<span class="sd">        with an extracted image point, with x (columns) in the first row and y (rows) in the second row.  </span>

<span class="sd">        Each column corresponds to the same row in :attr:`unmatched_catalogue_star_records`.</span>

<span class="sd">        Until :meth:`id_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_catalogue_star_records</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: NONEARRAY</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A pandas DataFrame of all the catalogue star records that were not matched to an extracted image point in the </span>
<span class="sd">        star identification routine.  </span>

<span class="sd">        See the :class:`.Catalogue` class for a description of the columns of the dataframe.</span>

<span class="sd">        Until :meth:`id_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_catalogue_unit_vectors</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: NONEARRAY</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A 3xn numpy array of unit vectors in the inertial frame for all catalogue stars that were not matched to an</span>
<span class="sd">        extracted image point in the star identification routine.  </span>

<span class="sd">        Each column corresponds to the same row in :attr:`matched_catalogue_star_records`.</span>

<span class="sd">        Until :meth:`id_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_extracted_image_points</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: NONEARRAY</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A 2xn array of the image points of interest that were not paired with a catalogue star in the star </span>
<span class="sd">        identification routine.</span>

<span class="sd">        The first row corresponds to the x locations (columns) and the second row corresponds to the y locations (rows).</span>
<span class="sd">        </span>
<span class="sd">        Until :meth:`id_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_weights_inertial</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: NONEARRAY</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This contains the formal total uncertainty for each unit vector from the queried catalogue stars</span>
<span class="sd">        that were not matched with an extracted image point.  </span>
<span class="sd">        </span>
<span class="sd">        Each element in this array corresponds to the same row in the :attr:`unmatched_catalogue_star_records`.</span>

<span class="sd">        Until method :meth:`id_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_weights_picture</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: NONEARRAY</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This contains the formal total uncertainty for each projected pixel location from the queried catalogue stars </span>
<span class="sd">        that were not matched with an extracted image point in units of pixels. </span>
<span class="sd">        </span>
<span class="sd">        Each element in this array corresponds to the same row in the :attr:`unmatched_catalogue_star_records`.</span>

<span class="sd">        Until method :meth:`id_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">matched_catalogue_image_points</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: NONEARRAY</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A 2xn numpy array of points containing the projected image points for all catalogue stars that were matched</span>
<span class="sd">        with an extracted image point, with x (columns) in the first row and y (rows) in the second row.  </span>

<span class="sd">        Each column corresponds to the same row in :attr:`matched_catalogue_star_records`.</span>

<span class="sd">        Until :meth:`id_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">matched_catalogue_star_records</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: NONEARRAY</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A pandas DataFrame of all the catalogue star records that were matched to an extracted image point in the </span>
<span class="sd">        star identification routine.  </span>

<span class="sd">        See the :class:`.Catalogue` class for a description of the columns of the dataframe.</span>
<span class="sd">        </span>
<span class="sd">        Each row of the dataframe corresponds to the same column index in the :attr:`matched_extracted_image_points`.</span>

<span class="sd">        Until :meth:`id_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">matched_catalogue_unit_vectors</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: NONEARRAY</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A 3xn numpy array of unit vectors in the inertial frame for all catalogue stars that were matched to an</span>
<span class="sd">        extracted image point in the star identification routine.  </span>

<span class="sd">        Each column corresponds to the same row in :attr:`matched_catalogue_star_records`.</span>

<span class="sd">        Until :meth:`id_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">matched_extracted_image_points</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: NONEARRAY</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A 2xn array of the image points of interest that were not paired with a catalogue star in the star </span>
<span class="sd">        identification routine.</span>

<span class="sd">        The first row contains to the x locations (columns) and the second row contains to the y locations (rows).</span>
<span class="sd">        </span>
<span class="sd">        Each column corresponds to the same row in the :attr:`matched_catalogue_star_records` for its pairing.</span>

<span class="sd">        Until :meth:`id_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">matched_weights_inertial</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: NONEARRAY</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This contains the formal total uncertainty for each unit vector from the queried catalogue stars</span>
<span class="sd">        that were matched with an extracted image point.  </span>

<span class="sd">        Each element in this array corresponds to the same row in the :attr:`matched_catalogue_star_records`.</span>

<span class="sd">        Until methods :meth:`id_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">matched_weights_picture</span> <span class="o">=</span> <span class="kc">None</span>   <span class="c1"># type: NONEARRAY</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This contains the formal total uncertainty for each projected pixel location from the queried catalogue stars </span>
<span class="sd">        that were matched with an extracted image point in units of pixels. </span>

<span class="sd">        Each element in this array corresponds to the same row in the :attr:`matched_catalogue_star_records`.</span>

<span class="sd">        Until method :meth:`id_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">lost_in_space_catalogue_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lis_file</span> <span class="o">=</span> <span class="n">LIS_FILE</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lis_file</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">lost_in_space_catalogue_file</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lis_catalogue</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># type: Tuple[Optional[spat.cKDTree], NONEARRAY]</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The lost in space catalogue.</span>
<span class="sd">        </span>
<span class="sd">        Contains a scipy cKDTree containing hash codes as the first element and a numpy array containing star ids</span>
<span class="sd">        for each hash element for the second element.</span>
<span class="sd">        </span>
<span class="sd">        .. warning::</span>

<span class="sd">            The lost is space catalogue is a pickle file. Pickle files can be used to execute</span>
<span class="sd">            arbitrary code, so you should never open one from an untrusted source.  </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">lis_file</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="k">with</span> <span class="n">lis_file</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">in_file</span><span class="p">:</span>
                <span class="c1"># added warning to documentation</span>
                <span class="n">tree</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">in_file</span><span class="p">)</span>  <span class="c1"># nosec</span>
                <span class="n">inds</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">in_file</span><span class="p">)</span>  <span class="c1"># nosec</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lis_catalogue</span> <span class="o">=</span> <span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">inds</span><span class="p">)</span>

<div class="viewcode-block" id="StarID.query_catalogue"><a class="viewcode-back" href="../../../stellar_opnav/star_identification/giant.stellar_opnav.star_identification.StarID.query_catalogue.html#giant.calibration.StarID.query_catalogue">[docs]</a>    <span class="k">def</span> <span class="nf">query_catalogue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">datetime</span><span class="p">,</span> <span class="n">Real</span><span class="p">]</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method queries stars from the catalogue within the field of view.</span>

<span class="sd">        The stars are queried such that any stars within 1.3*the :attr:`.CameraModel.field_of_view` value radial</span>
<span class="sd">        distance of the camera frame z axis converted to right ascension and declination are returned between</span>
<span class="sd">        :attr:`min_magnitude` and :attr:`max_magnitude`.  The queried stars are updated to the ``epoch`` value</span>
<span class="sd">        using proper motion.  They are stored in the :attr:`queried_catalogue_star_records` attribute. The stars are</span>
<span class="sd">        stored as a pandas DataFrame.  For more information about this format see the :class:`.Catalogue` class</span>
<span class="sd">        documentation.</span>

<span class="sd">        The epoch input should either be a python datetime object representation of the UTC time or a float value of the</span>
<span class="sd">        MJD years.</span>

<span class="sd">        In general, this method does not need to be directly called by the user as it is automatically called in the</span>
<span class="sd">        :meth:`project_stars` method.</span>

<span class="sd">        :param epoch: The new epoch to move the stars to using proper motion</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get the ra and dec of the camera frame z axis</span>
        <span class="n">ra_dec_cat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compute_pointing</span><span class="p">())</span>

        <span class="c1"># query the catalogue and store the results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalogue_star_records</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalogue</span><span class="o">.</span><span class="n">query_catalogue</span><span class="p">(</span>
            <span class="n">search_center</span><span class="o">=</span><span class="n">ra_dec_cat</span><span class="p">,</span>
            <span class="n">search_radius</span><span class="o">=</span><span class="mf">1.3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">field_of_view</span><span class="p">,</span>
            <span class="n">min_mag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_magnitude</span><span class="p">,</span>
            <span class="n">max_mag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_magnitude</span><span class="p">,</span>
            <span class="n">new_epoch</span><span class="o">=</span><span class="n">epoch</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="StarID.compute_pointing"><a class="viewcode-back" href="../../../stellar_opnav/star_identification/giant.stellar_opnav.star_identification.StarID.compute_pointing.html#giant.calibration.StarID.compute_pointing">[docs]</a>    <span class="k">def</span> <span class="nf">compute_pointing</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method computes the right ascension and declination of an axis of the camera frame in units of degrees.</span>

<span class="sd">        The pointing is computed by extracting the camera frame z axis expressed in the inertial frame from the</span>
<span class="sd">        :attr:`a_priori_rotation_cat2camera` and then converting that axis to a right ascension and declination.</span>
<span class="sd">        The conversion to right ascension and declination is given as</span>

<span class="sd">        .. math::</span>
<span class="sd">            ra=\text{atan2}(\mathbf{c}_{yI}, \mathbf{c}_{xI})\\</span>
<span class="sd">            dec=\text{asin}(\mathbf{c}_{zI})</span>

<span class="sd">        where atan2 is the quadrant aware arc tangent function, asin is the arc sin and :math:`\mathbf{c}_{jI}` is the</span>
<span class="sd">        :math:`j^{th}` component of the camera frame axis expressed in the Inertial frame.</span>

<span class="sd">        In general this method is not used by the user as it is automatically called in the :meth:`query_catalogue`</span>
<span class="sd">        method.</span>

<span class="sd">        :return:  The right ascension and declination of the specified axis in the inertial frame as a tuple (ra, dec)</span>
<span class="sd">                  in units of degrees.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">boresight_cat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_priori_rotation_cat2camera</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">ra</span><span class="p">,</span> <span class="n">dec</span> <span class="o">=</span> <span class="n">unit_to_radec</span><span class="p">(</span><span class="n">boresight_cat</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">RAD2DEG</span> <span class="o">*</span> <span class="n">ra</span><span class="p">,</span> <span class="n">RAD2DEG</span> <span class="o">*</span> <span class="n">dec</span></div>

<div class="viewcode-block" id="StarID.project_stars"><a class="viewcode-back" href="../../../stellar_opnav/star_identification/giant.stellar_opnav.star_identification.StarID.project_stars.html#giant.calibration.StarID.project_stars">[docs]</a>    <span class="k">def</span> <span class="nf">project_stars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">datetime</span><span class="p">,</span> <span class="n">Real</span><span class="p">]</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">compute_weights</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                      <span class="n">temperature</span><span class="p">:</span> <span class="n">Real</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image_number</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method queries the star catalogue for predicted stars within the field of view and projects those stars</span>
<span class="sd">        onto the image using the camera model.</span>

<span class="sd">        The star catalogue is queried using the :meth:`query_catalogue` method and the stars are updated to the epoch</span>
<span class="sd">        specified by ``epoch`` using the proper motion from the catalogue.  The ``epoch`` should be specified as either</span>
<span class="sd">        a datetime object representing the UTC time the stars should be transformed to, or a float value representing</span>
<span class="sd">        the MJD year.  The queried Pandas Dataframe containing the star catalogue records is stored in the</span>
<span class="sd">        :attr:`queried_catalogue_star_records` attribute.</span>

<span class="sd">        After the stars are queried from the catalogue, they are converted to inertial unit vectors and corrected for</span>
<span class="sd">        stellar aberration and parallax using the :attr:`camera_position` and :attr:`camera_velocity` values.  The</span>
<span class="sd">        corrected inertial vectors are stored in the :attr:`queried_catalogue_unit_vectors`.</span>

<span class="sd">        Finally, the unit vectors are rotated into the camera frame using the :attr:`a_priori_rotation_cat2camera`</span>
<span class="sd">        attribute, and then projected onto the image using the :attr:`model` attribute.  The projected points are stored</span>
<span class="sd">        in the :attr:`queried_catalogue_image_points` attribute.</span>

<span class="sd">        If requested, the formal uncertainties for the catalogue unit vectors and pixel locations are computed and</span>
<span class="sd">        stored in the :attr:`queried_weights_inertial` and :attr:`queried_weights_picture`.  These are computed by</span>
<span class="sd">        transforming the formal uncertainty on the right ascension, declination, and proper motion specified in the</span>
<span class="sd">        star catalogue into the proper frame.</span>

<span class="sd">        In general this method is not called directly by the user and instead is called in the :meth:`id_stars` method.</span>

<span class="sd">        :param epoch: The epoch to get the star locations for</span>
<span class="sd">        :param compute_weights: A boolean specifying whether to compute the formal uncertainties for the unit vectors</span>
<span class="sd">                                and the pixel locations of the catalogue stars.</span>
<span class="sd">        :param temperature: The temperature of the camera at the time of the image being processed</span>
<span class="sd">        :param image_number: The number of the image being processed</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># query the star catalogue for predicted stars in the field of view</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">query_catalogue</span><span class="p">(</span><span class="n">epoch</span><span class="o">=</span><span class="n">epoch</span><span class="p">)</span>

        <span class="c1"># convert the star locations into unit vectors in the inertial frame</span>
        <span class="n">ra_rad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalogue_star_records</span><span class="p">[</span><span class="s1">&#39;ra&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">/</span> <span class="n">RAD2DEG</span>
        <span class="n">dec_rad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalogue_star_records</span><span class="p">[</span><span class="s1">&#39;dec&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">/</span> <span class="n">RAD2DEG</span>
        <span class="n">catalogue_unit_vectors</span> <span class="o">=</span> <span class="n">radec_to_unit</span><span class="p">(</span><span class="n">ra_rad</span><span class="p">,</span> <span class="n">dec_rad</span><span class="p">)</span>

        <span class="c1"># correct the unit vectors for parallax using the distance attribute of the star records and the camera inertial</span>
        <span class="c1"># location</span>
        <span class="n">catalogue_points</span> <span class="o">=</span> <span class="n">catalogue_unit_vectors</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalogue_star_records</span><span class="p">[</span><span class="s1">&#39;distance&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="n">camera2stars_inertial</span> <span class="o">=</span> <span class="n">catalogue_points</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera_position</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># correct the stellar aberration</span>
        <span class="n">camera2stars_inertial</span> <span class="o">=</span> <span class="n">correct_stellar_aberration</span><span class="p">(</span><span class="n">camera2stars_inertial</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera_velocity</span><span class="p">)</span>

        <span class="c1"># form the corrected unit vectors</span>
        <span class="n">camera2stars_inertial</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">camera2stars_inertial</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># rotate the unit vectors into the camera frame</span>
        <span class="n">rot2camera</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_priori_rotation_cat2camera</span><span class="o">.</span><span class="n">matrix</span>
        <span class="n">catalogue_unit_vectors_camera</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">rot2camera</span><span class="p">,</span> <span class="n">camera2stars_inertial</span><span class="p">)</span>

        <span class="c1"># store the inertial corrected unit vectors and the projected image locations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalogue_unit_vectors</span> <span class="o">=</span> <span class="n">camera2stars_inertial</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalogue_image_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">project_onto_image</span><span class="p">(</span><span class="n">catalogue_unit_vectors_camera</span><span class="p">,</span>
                                                                            <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image_number</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">compute_weights</span><span class="p">:</span>
            <span class="c1"># compute the covariance of the inertial catalogue unit vectors</span>
            <span class="n">cos_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dec_rad</span><span class="p">)</span>
            <span class="n">cos_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ra_rad</span><span class="p">)</span>
            <span class="n">sin_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dec_rad</span><span class="p">)</span>
            <span class="n">sin_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ra_rad</span><span class="p">)</span>
            <span class="n">zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">cos_d</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

            <span class="n">dv_da</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">cos_d</span> <span class="o">*</span> <span class="n">sin_a</span><span class="p">,</span> <span class="n">cos_d</span> <span class="o">*</span> <span class="n">sin_a</span><span class="p">,</span> <span class="n">zero</span><span class="p">])</span>
            <span class="n">dv_dd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">sin_d</span> <span class="o">*</span> <span class="n">cos_a</span><span class="p">,</span> <span class="o">-</span><span class="n">sin_d</span> <span class="o">*</span> <span class="n">sin_a</span><span class="p">,</span> <span class="n">cos_d</span><span class="p">])</span>

            <span class="n">cov_v</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,jk-&gt;jik&#39;</span><span class="p">,</span> <span class="n">dv_da</span><span class="p">,</span> <span class="n">dv_da</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span>
                     <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queried_catalogue_star_records</span><span class="p">[</span><span class="s1">&#39;ra_sigma&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">/</span> <span class="n">RAD2DEG</span> <span class="o">/</span> <span class="n">cos_d</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                     <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,jk-&gt;jik&#39;</span><span class="p">,</span> <span class="n">dv_dd</span><span class="p">,</span> <span class="n">dv_dd</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span>
                     <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queried_catalogue_star_records</span><span class="p">[</span><span class="s1">&#39;dec_sigma&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">RAD2DEG</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

            <span class="c1"># compute the covariance of the projected catalogue points</span>
            <span class="n">cov_xc</span> <span class="o">=</span> <span class="n">rot2camera</span> <span class="o">@</span> <span class="n">cov_v</span> <span class="o">@</span> <span class="n">rot2camera</span><span class="o">.</span><span class="n">T</span>
            <span class="n">pj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">compute_pixel_jacobian</span><span class="p">(</span><span class="n">catalogue_unit_vectors_camera</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">,</span>
                                                   <span class="n">image</span><span class="o">=</span><span class="n">image_number</span><span class="p">)</span>
            <span class="n">cov_xp</span> <span class="o">=</span> <span class="n">pj</span> <span class="o">@</span> <span class="n">cov_xc</span> <span class="o">@</span> <span class="n">pj</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_inertial</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">cov_v</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_picture</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">cov_xp</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="StarID.solve_lis"><a class="viewcode-back" href="../../../giant.calibration.html#giant.calibration.StarID.solve_lis">[docs]</a>    <span class="k">def</span> <span class="nf">solve_lis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">datetime</span><span class="p">,</span> <span class="n">Real</span><span class="p">]</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                  <span class="n">temperature</span><span class="p">:</span> <span class="n">Real</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image_number</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solves the lost in space problem (no a priori knowledge) for the orientation between the catalogue and camera</span>
<span class="sd">        frames.</span>

<span class="sd">        The lost in space problem is solved by first generating hash codes of observed possible star quads in an image</span>
<span class="sd">        using  :meth:`_generate_hash`.  Given the hash codes, they are compared with a precomputed database of hash</span>
<span class="sd">        codes (see :mod:`.build_lost_in_space_catalogue`) to identify the closest matches.  The closest matches are then</span>
<span class="sd">        used to make a guess at the rotation from the catalogue frame to the camera frame, and the usual star ID</span>
<span class="sd">        routines (:meth:`.id_stars`) are called using the guess as the a priori attitude knowledge.  The number of</span>
<span class="sd">        identified stars found using the usual methods is then compared with the best number of stars found so far,</span>
<span class="sd">        and if more stars are found the rotation is kept as the best available.  This is done using the settings already</span>
<span class="sd">        provided to the class, so you need to ensure that you have a good setup even when solving the lost in space</span>
<span class="sd">        problem.  This continues until all possible hash code pairs have been considered, or until a pair produces an</span>
<span class="sd">        a priori attitude that successfully identifies half of the queried stars from the catalogue in the FOV of the</span>
<span class="sd">        camera and one quarter of the possible stars.</span>

<span class="sd">        The result is saved to the :attr:`.a_priori_rotation_cat2camera` attribute and then the usual star ID routines</span>
<span class="sd">        are run again to finish off the identification.</span>

<span class="sd">        :param epoch: the epoch of the image</span>
<span class="sd">        :param temperature: the temperature of the camera at the time the image was captured</span>
<span class="sd">        :param image_number: The number of the image being processed</span>
<span class="sd">        :return: The boolean index into the image points that met the original pairing criterion, and a second boolean</span>
<span class="sd">                 index into the the result from the previous boolean index that extracts the image points that were</span>
<span class="sd">                 successfully matched in the RANSAC algorithms</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lis_catalogue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The lost in space catalogue has not been loaded.  Cannot solve lost in space problem.&#39;</span>
                             <span class="s1">&#39;See build_lost_in_space_catalogue interface for details.&#39;</span><span class="p">)</span>

        <span class="n">ip_hash</span><span class="p">,</span> <span class="n">ip_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extracted_image_points</span><span class="p">)</span>

        <span class="n">distances</span><span class="p">,</span> <span class="n">pair_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lis_catalogue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">ip_hash</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">distance_upper_bound</span><span class="o">=</span><span class="mf">0.02</span><span class="p">)</span>

        <span class="n">sorted_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">sorted_dist</span><span class="p">]</span>
        <span class="n">pair_indices</span> <span class="o">=</span> <span class="n">pair_indices</span><span class="p">[</span><span class="n">sorted_dist</span><span class="p">]</span>

        <span class="n">lis_sid</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">best_inliers</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">best_rotation</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">keep_out</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">inliers_out</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">ip_ind</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">pairs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ip_inds</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">pair_indices</span><span class="p">):</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
            <span class="n">pairs</span> <span class="o">=</span> <span class="n">pairs</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_temp_att_est</span><span class="o">.</span><span class="n">target_frame_directions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">pixels_to_unit</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">extracted_image_points</span><span class="p">[:,</span> <span class="n">ip_ind</span><span class="p">],</span> <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image_number</span><span class="p">)</span>

            <span class="n">done</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>

                <span class="n">cat_stars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalogue</span><span class="o">.</span><span class="n">query_catalogue</span><span class="p">(</span><span class="n">ids</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lis_catalogue</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">pair</span><span class="p">])</span>

                <span class="n">ra_rad</span><span class="p">,</span> <span class="n">dec_rad</span> <span class="o">=</span> <span class="p">(</span><span class="n">cat_stars</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">[</span><span class="s2">&quot;ra&quot;</span><span class="p">,</span> <span class="s2">&quot;dec&quot;</span><span class="p">]]</span><span class="o">/</span><span class="n">RAD2DEG</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">T</span>

                <span class="n">unit_inertial</span> <span class="o">=</span> <span class="n">radec_to_unit</span><span class="p">(</span><span class="n">ra_rad</span><span class="p">,</span> <span class="n">dec_rad</span><span class="p">)</span>

                <span class="n">cam2stars_inertial</span> <span class="o">=</span> <span class="n">correct_stellar_aberration</span><span class="p">(</span><span class="n">unit_inertial</span> <span class="o">*</span> <span class="n">cat_stars</span><span class="p">[</span><span class="s1">&#39;distance&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span>
                                                                <span class="bp">self</span><span class="o">.</span><span class="n">camera_position</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                                                                <span class="bp">self</span><span class="o">.</span><span class="n">camera_velocity</span><span class="p">)</span>

                <span class="n">cam2stars_inertial</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">cam2stars_inertial</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_temp_att_est</span><span class="o">.</span><span class="n">base_frame_directions</span> <span class="o">=</span> <span class="n">cam2stars_inertial</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_temp_att_est</span><span class="o">.</span><span class="n">estimate</span><span class="p">()</span>

                <span class="n">lis_sid</span><span class="o">.</span><span class="n">a_priori_rotation_cat2camera</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_temp_att_est</span><span class="o">.</span><span class="n">rotation</span>

                <span class="n">keeps</span><span class="p">,</span> <span class="n">inliers</span> <span class="o">=</span> <span class="n">lis_sid</span><span class="o">.</span><span class="n">id_stars</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">lis_sid</span><span class="o">.</span><span class="n">matched_catalogue_image_points</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">lis_sid</span><span class="o">.</span><span class="n">matched_catalogue_image_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">best_inliers</span><span class="p">:</span>
                        <span class="n">best_rotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_temp_att_est</span><span class="o">.</span><span class="n">rotation</span>
                        <span class="n">best_inliers</span> <span class="o">=</span> <span class="n">lis_sid</span><span class="o">.</span><span class="n">matched_catalogue_image_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                        <span class="n">in_fov</span> <span class="o">=</span> <span class="p">((</span><span class="n">lis_sid</span><span class="o">.</span><span class="n">queried_catalogue_image_points</span> <span class="o">&gt;</span> <span class="p">[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">&amp;</span>
                                  <span class="p">(</span><span class="n">lis_sid</span><span class="o">.</span><span class="n">queried_catalogue_image_points</span> <span class="o">&lt;</span>
                                   <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">n_cols</span><span class="p">],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">n_rows</span><span class="p">]]))</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                        <span class="n">keep_out</span> <span class="o">=</span> <span class="n">keeps</span>
                        <span class="n">inliers_out</span> <span class="o">=</span> <span class="n">inliers</span>

                        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">lis_sid</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>

                        <span class="k">if</span> <span class="n">best_inliers</span><span class="o">/</span><span class="n">in_fov</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">best_inliers</span> <span class="o">/</span> <span class="n">lis_sid</span><span class="o">.</span><span class="n">extracted_image_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.25</span><span class="p">:</span>
                                <span class="n">done</span> <span class="o">=</span> <span class="kc">True</span>
                                <span class="k">break</span>
            <span class="k">if</span> <span class="n">done</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">best_rotation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a_priori_rotation_cat2camera</span> <span class="o">=</span> <span class="n">best_rotation</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Unable to solve lost in space problem&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">keep_out</span><span class="p">,</span> <span class="n">inliers_out</span></div>

<div class="viewcode-block" id="StarID.id_stars"><a class="viewcode-back" href="../../../stellar_opnav/star_identification/giant.stellar_opnav.star_identification.StarID.id_stars.html#giant.calibration.StarID.id_stars">[docs]</a>    <span class="k">def</span> <span class="nf">id_stars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">datetime</span><span class="p">,</span> <span class="n">Real</span><span class="p">]</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">compute_weights</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">temperature</span><span class="p">:</span> <span class="n">Real</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image_number</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="n">lost_in_space</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method attempts to match the image points of interest with catalogue stars.</span>

<span class="sd">        The :meth:`id_stars` method is the primary interface of the :class:`StarID` class.  It performs all the tasks of</span>
<span class="sd">        querying the star catalogue, performing the initial pairing using a nearest neighbor search, refining the</span>
<span class="sd">        initial pairings with the :attr:`second_closest_check` and :attr:`unique_check`, and passing the refined</span>
<span class="sd">        pairings to the RANSAC routines.  The matched and unmatched catalogue stars and image points of interest are</span>
<span class="sd">        stored in the appropriate attributes.</span>

<span class="sd">        This method also returns a boolean index in the image points of interest vector, which extracts the image points</span>
<span class="sd">        that met the initial match criterion, and another boolean index into the image points of interest which</span>
<span class="sd">        extracts the image points of interest that were matched by the RANSAC algorithms.  This can be used to select</span>
<span class="sd">        the appropriate meta data about catalogue stars or stars found in an image that isn&#39;t explicitly considered by</span>
<span class="sd">        this class (as is done in the :class:`.StellarOpNav` class), but if you do not have extra information you need</span>
<span class="sd">        to keep in sync, then you can ignore the output.</span>

<span class="sd">        If requested, the formal uncertainties for the catalogue unit vectors and pixel locations are computed and</span>
<span class="sd">        stored in the :attr:`queried_weights_inertial` and :attr:`queried_weights_picture`.  These are computed by</span>
<span class="sd">        transforming the formal uncertainty on the right ascension, declination, and proper motion specified in the</span>
<span class="sd">        star catalogue into the proper frame.</span>

<span class="sd">        :param epoch: The new epoch to move the stars to using proper motion</span>
<span class="sd">        :param compute_weights: a flag specifying whether to compute weights for the attitude estimation and</span>
<span class="sd">                                calibration estimation.</span>
<span class="sd">        :param temperature: The temperature of the camera at the time of the image being processed</span>
<span class="sd">        :param image_number: The number of the image being processed</span>
<span class="sd">        :param lost_in_space: A flag specifying whether the lost in space algorithm needs to be used</span>
<span class="sd">        :return: The boolean index into the image points that met the original pairing criterion, and a second boolean</span>
<span class="sd">                 index into the the result from the previous boolean index that extracts the image points that were</span>
<span class="sd">                 successfully matched in the RANSAC algorithms</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">lost_in_space</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_priori_rotation_cat2camera</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_lis</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">temperature</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_priori_rotation_cat2camera</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Unable to proceed with star id.  No a priori point knowledge available.&#39;</span><span class="p">)</span>

        <span class="c1"># first get the unit vectors and image locations for the stars in the field of view</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">project_stars</span><span class="p">(</span><span class="n">epoch</span><span class="o">=</span><span class="n">epoch</span><span class="p">,</span> <span class="n">compute_weights</span><span class="o">=</span><span class="n">compute_weights</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">,</span>
                           <span class="n">image_number</span><span class="o">=</span><span class="n">image_number</span><span class="p">)</span>

        <span class="c1"># create a kdtree of the catalogue image locations for faster searching</span>
        <span class="c1"># noinspection PyArgumentList</span>
        <span class="n">catalogue_image_locations_kdtree</span> <span class="o">=</span> <span class="n">spat</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queried_catalogue_image_points</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># query the kdtree to get the 2 closest catalogue image locations to each image point of interest</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">extracted_image_points</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="n">distance</span><span class="p">,</span> <span class="n">inds</span> <span class="o">=</span> <span class="n">catalogue_image_locations_kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extracted_image_points</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># check to see which pairs are less than the user specified matching tolerance</span>
        <span class="n">dist_check</span> <span class="o">=</span> <span class="n">distance</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span>

        <span class="c1"># throw out pairs where multiple catalogue locations are &lt; the tolerance to the image points of interest</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_closest_check</span><span class="p">:</span>
            <span class="n">dist_check</span> <span class="o">&amp;=</span> <span class="n">distance</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span>

        <span class="n">keep_stars</span> <span class="o">=</span> <span class="n">dist_check</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># throw out points that are matched twice</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_check</span><span class="p">:</span>
            <span class="n">keep_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">inds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">kin</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inds</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]):</span>
                <span class="n">keep_unique</span><span class="p">[</span><span class="n">kin</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ind</span> <span class="o">==</span> <span class="n">inds</span><span class="p">[</span><span class="n">dist_check</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span>

            <span class="n">keep_stars</span> <span class="o">&amp;=</span> <span class="n">keep_unique</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_stars</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="c1"># either return our current matches or further filter using ransac if desired</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_combos</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">matched_extracted_image_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_catalogue_unit_vectors</span><span class="p">,</span> <span class="n">keep_inliers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ransac</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">extracted_image_points</span><span class="p">[:,</span> <span class="n">keep_stars</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalogue_unit_vectors</span><span class="p">[:,</span> <span class="n">inds</span><span class="p">[</span><span class="n">keep_stars</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
                <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">,</span> <span class="n">image_number</span><span class="o">=</span><span class="n">image_number</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">keep_inliers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># if none of the stars met the ransac criteria then throw everything out</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;no stars found for epoch </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">epoch</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">matched_catalogue_star_records</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">matched_catalogue_image_points</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">compute_weights</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">matched_weights_inertial</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">matched_weights_picture</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># update the matched catalogue star records and image points</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">matched_catalogue_star_records</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalogue_star_records</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span>
                    <span class="n">inds</span><span class="p">[</span><span class="n">keep_stars</span><span class="p">,</span> <span class="mi">0</span><span class="p">]][</span><span class="n">keep_inliers</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">matched_catalogue_image_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalogue_image_points</span><span class="p">[</span>
                                                      <span class="p">:,</span> <span class="n">inds</span><span class="p">[</span><span class="n">keep_stars</span><span class="p">,</span> <span class="mi">0</span><span class="p">]][:,</span> <span class="n">keep_inliers</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">compute_weights</span><span class="p">:</span>
                    <span class="c1"># noinspection PyTypeChecker</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">matched_weights_inertial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_inertial</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">keep_stars</span><span class="p">,</span> <span class="mi">0</span><span class="p">]][</span><span class="n">keep_inliers</span><span class="p">]</span>
                    <span class="c1"># noinspection PyTypeChecker</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">matched_weights_picture</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_picture</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">keep_stars</span><span class="p">,</span> <span class="mi">0</span><span class="p">]][</span><span class="n">keep_inliers</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># set the matches in the proper places</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">matched_extracted_image_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extracted_image_points</span><span class="p">[:,</span> <span class="n">keep_stars</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">matched_catalogue_image_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalogue_image_points</span><span class="p">[:,</span> <span class="n">inds</span><span class="p">[</span><span class="n">keep_stars</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">matched_catalogue_unit_vectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalogue_unit_vectors</span><span class="p">[:,</span> <span class="n">inds</span><span class="p">[</span><span class="n">keep_stars</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">matched_catalogue_star_records</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalogue_star_records</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">keep_stars</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">compute_weights</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">matched_weights_inertial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_inertial</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">keep_stars</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">matched_weights_picture</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_picture</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">keep_stars</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

            <span class="n">keep_inliers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matched_extracted_image_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># use python set notation to determine the list of stars and image points that were never matched</span>
        <span class="k">if</span> <span class="n">keep_inliers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># get the stars that weren&#39;t matched</span>
            <span class="n">unmatched_inds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">({</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queried_catalogue_image_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])}</span> <span class="o">-</span>
                                  <span class="p">{</span><span class="o">*</span><span class="p">(</span><span class="n">inds</span><span class="p">[</span><span class="n">keep_stars</span><span class="p">,</span> <span class="mi">0</span><span class="p">][</span><span class="n">keep_inliers</span><span class="p">])})</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_catalogue_image_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalogue_image_points</span><span class="p">[:,</span> <span class="n">unmatched_inds</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_catalogue_star_records</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalogue_star_records</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">unmatched_inds</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_catalogue_unit_vectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalogue_unit_vectors</span><span class="p">[:,</span> <span class="n">unmatched_inds</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">compute_weights</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_weights_inertial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_inertial</span><span class="p">[</span><span class="n">unmatched_inds</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_weights_picture</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_picture</span><span class="p">[</span><span class="n">unmatched_inds</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># get the points of interest that weren&#39;t matched</span>
            <span class="n">camera_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extracted_image_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">unmatched_centroid_inds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">({</span><span class="o">*</span><span class="n">camera_inds</span><span class="p">}</span> <span class="o">-</span> <span class="p">{</span><span class="o">*</span><span class="n">camera_inds</span><span class="p">[</span><span class="n">keep_stars</span><span class="p">][</span><span class="n">keep_inliers</span><span class="p">]})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_extracted_image_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extracted_image_points</span><span class="p">[:,</span> <span class="n">unmatched_centroid_inds</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># nothing was matched</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_extracted_image_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extracted_image_points</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_catalogue_star_records</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalogue_star_records</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_catalogue_unit_vectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalogue_unit_vectors</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_catalogue_image_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalogue_image_points</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">compute_weights</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_weights_inertial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_inertial</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_weights_picture</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_picture</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">keep_stars</span><span class="p">,</span> <span class="n">keep_inliers</span></div>

<div class="viewcode-block" id="StarID.ransac"><a class="viewcode-back" href="../../../stellar_opnav/star_identification/giant.stellar_opnav.star_identification.StarID.ransac.html#giant.calibration.StarID.ransac">[docs]</a>    <span class="k">def</span> <span class="nf">ransac</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_locs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">catalogue_dirs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
               <span class="n">temperature</span><span class="p">:</span> <span class="n">Real</span><span class="p">,</span> <span class="n">image_number</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method performs RANSAC on the image poi-catalogue location pairs.</span>

<span class="sd">        The RANSAC algorithm is described below</span>

<span class="sd">        #. The pairs are randomly sampled for 4 star pairs</span>
<span class="sd">        #. The sample is used to estimate a new attitude for the image using the :class:`.DavenportQMethod` routines.</span>
<span class="sd">        #. The new solved for attitude is used to re-rotate and project the catalogue stars onto the image.</span>
<span class="sd">        #. The new projections are compared with their matched image points and the number of inlier pairs (pairs whose</span>
<span class="sd">           distance is less than some ransac threshold) are counted.</span>
<span class="sd">        #. The number of inliers is compared to the maximum number of inliers found by any sample to this point (set to</span>
<span class="sd">           0 if this is the first sample) and:</span>

<span class="sd">           * if there are more inliers</span>

<span class="sd">             * the maximum number of inliers is set to the number of inliers generated for this sample</span>
<span class="sd">             * the inliers for this sample are stored as correctly identified stars</span>
<span class="sd">             * the sum of the squares of the distances between the inlier pairs for this sample is stored</span>

<span class="sd">           * if there are an equivalent number of inliers to the previous maximum number of inliers then the sum of the</span>
<span class="sd">             squares of the distance between the pairs of inliers is compared to the sum of the squares of the previous</span>
<span class="sd">             inliers and if the new sum of squares is less than the old sum of squares</span>

<span class="sd">             * the maximum number of inliers is set to the number of inliers generated for this sample</span>
<span class="sd">             * the inliers are stored as correctly identified stars</span>
<span class="sd">             * the sum of the squares of the distances between the inlier pairs is stored</span>

<span class="sd">        #. Steps 1-5 are repeated for a number of iterations, and the final set of stars stored as correctly identified</span>
<span class="sd">           stars become the identified stars for the image.</span>

<span class="sd">        In order to use this method, the ``image_locs`` input and the ``catalogue_dirs`` input should represent the</span>
<span class="sd">        initial pairings between the image points found using image processing and the predicted catalogue star unit</span>
<span class="sd">        vectors in the inertial frame. The columns in these 2 arrays should represent the matched pairs (that is column</span>
<span class="sd">        10 of ``image_locs`` should correspond to column 10 in ``catalogue_dirs``).</span>

<span class="sd">        This method returns the paired image locations and catalogue directions from the best RANSAC iteration</span>
<span class="sd">        and the boolean index into the input arrays that extract these values.</span>

<span class="sd">        In general this method is not used directly by the user and instead is called as part of the :meth:`id_stars`</span>
<span class="sd">        method.</span>

<span class="sd">        :param image_locs:  The image points of interest that met the initial matching criteria as a 2xn array</span>
<span class="sd">        :param catalogue_dirs:  The catalogue inertial unit vectors that met the initial matching criteria in the same</span>
<span class="sd">                                order as the ``image_locs`` input as a 3xn array.</span>
<span class="sd">        :param temperature: The temperature of the camera at the time of the image being processed</span>
<span class="sd">        :param image_number: The number of the image being processed</span>
<span class="sd">        :return: The matched image points of interest, the matched catalogue unit vectors, and the boolean index that</span>
<span class="sd">                 represents these arrays</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># initialize the maximum number of inliers and minimum sum of squares variables.</span>
        <span class="n">max_inliers</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">max_rs</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ransac_tolerance</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">image_locs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># get the maximum number of combinations that are available to sample</span>
        <span class="n">n_comb</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">comb</span><span class="p">(</span><span class="n">image_locs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="n">image_locs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>

        <span class="c1"># convert the image points of interest to unit vectors in the camera frame</span>
        <span class="n">image_dirs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">pixels_to_unit</span><span class="p">(</span><span class="n">image_locs</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image_number</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_image_locs</span> <span class="o">=</span> <span class="n">image_locs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_image_dirs</span> <span class="o">=</span> <span class="n">image_dirs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_catalogue_dirs</span> <span class="o">=</span> <span class="n">catalogue_dirs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_temperature</span> <span class="o">=</span> <span class="n">temperature</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_image_number</span> <span class="o">=</span> <span class="n">image_number</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_combinations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">RandomCombinations</span><span class="p">(</span><span class="n">image_locs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                                          <span class="nb">min</span><span class="p">(</span><span class="n">image_locs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
                                                          <span class="nb">min</span><span class="p">(</span><span class="n">n_comb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_combos</span><span class="p">)))</span>

        <span class="c1"># perform the ransac</span>
        <span class="n">iters</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">n_comb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_combos</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mp</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">Pool</span><span class="p">()</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ransac_iter_test</span><span class="p">,</span> <span class="n">iters</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ransac_iter_test</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">iters</span><span class="p">]</span>

        <span class="c1"># initialize the return values in case the RANSAC fails</span>
        <span class="n">keep_image_locs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">keep_catalogue_dirs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">keep_inliers</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># find the best iteration and keep it</span>
        <span class="k">for</span> <span class="n">num_inliers</span><span class="p">,</span> <span class="n">filtered_image_locs</span><span class="p">,</span> <span class="n">filtered_catalogue_dirs</span><span class="p">,</span> <span class="n">inliers</span><span class="p">,</span> <span class="n">rs</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>

            <span class="c1"># check to see if this is the best ransac iteration yet</span>
            <span class="k">if</span> <span class="n">num_inliers</span> <span class="o">&gt;</span> <span class="n">max_inliers</span><span class="p">:</span>

                <span class="n">max_inliers</span> <span class="o">=</span> <span class="n">num_inliers</span>

                <span class="n">keep_image_locs</span> <span class="o">=</span> <span class="n">filtered_image_locs</span>

                <span class="n">keep_catalogue_dirs</span> <span class="o">=</span> <span class="n">filtered_catalogue_dirs</span>

                <span class="n">keep_inliers</span> <span class="o">=</span> <span class="n">inliers</span>

                <span class="n">max_rs</span> <span class="o">=</span> <span class="n">rs</span>

            <span class="k">elif</span> <span class="n">num_inliers</span> <span class="o">==</span> <span class="n">max_inliers</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">rs</span> <span class="o">&lt;</span> <span class="n">max_rs</span><span class="p">:</span>
                    <span class="n">max_inliers</span> <span class="o">=</span> <span class="n">num_inliers</span>

                    <span class="n">keep_image_locs</span> <span class="o">=</span> <span class="n">filtered_image_locs</span>

                    <span class="n">keep_catalogue_dirs</span> <span class="o">=</span> <span class="n">filtered_catalogue_dirs</span>

                    <span class="n">keep_inliers</span> <span class="o">=</span> <span class="n">inliers</span>

                    <span class="n">max_rs</span> <span class="o">=</span> <span class="n">rs</span>

        <span class="c1"># clear out the temp data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_image_locs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_image_dirs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_catalogue_dirs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_temperature</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_image_number</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># return the matched results and the boolean index</span>
        <span class="k">return</span> <span class="n">keep_image_locs</span><span class="p">,</span> <span class="n">keep_catalogue_dirs</span><span class="p">,</span> <span class="n">keep_inliers</span></div>

<div class="viewcode-block" id="StarID.ransac_iter_test"><a class="viewcode-back" href="../../../stellar_opnav/star_identification/giant.stellar_opnav.star_identification.StarID.ransac_iter_test.html#giant.calibration.StarID.ransac_iter_test">[docs]</a>    <span class="k">def</span> <span class="nf">ransac_iter_test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iter_num</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">NONEARRAY</span><span class="p">,</span> <span class="n">NONEARRAY</span><span class="p">,</span> <span class="n">NONEARRAY</span><span class="p">,</span> <span class="n">NONEARRAY</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This performs a single ransac iteration.</span>

<span class="sd">        See the :meth:`ransac` method for more details.</span>

<span class="sd">        :param iter_num: the iteration number for retrieving the combination to try</span>
<span class="sd">        :return: the number of inliers for this iteration, the image location inliers for this iteration, the</span>
<span class="sd">                 catalogue direction inliers for this iteration, the boolean index for the inliers for this iteration,</span>
<span class="sd">                 and the sum of the squares of the residuals for this iteration</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">image_locs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_temp_image_locs</span>
        <span class="n">image_dirs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_temp_image_dirs</span>
        <span class="n">catalogue_dirs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_temp_catalogue_dirs</span>

        <span class="c1"># get a random combination of indices into the image_locs and catalogue_dirs arrays</span>
        <span class="c1"># inds = random_combination(image_locs.shape[1], min(image_locs.shape[1] - 1, 4))</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_temp_combinations</span><span class="p">[</span><span class="n">iter_num</span><span class="p">]</span>

        <span class="c1"># extract the image directions to use for this ransac iteration</span>
        <span class="n">image_dirs_use</span> <span class="o">=</span> <span class="n">image_dirs</span><span class="p">[:,</span> <span class="n">inds</span><span class="p">]</span>

        <span class="c1"># extract the catalogue directions ot use for this ransac iteration</span>
        <span class="n">catalogue_dirs_use</span> <span class="o">=</span> <span class="n">catalogue_dirs</span><span class="p">[:,</span> <span class="n">inds</span><span class="p">]</span>

        <span class="c1"># store the unit vectors into the attitude estimator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_att_est</span><span class="o">.</span><span class="n">target_frame_directions</span> <span class="o">=</span> <span class="n">image_dirs_use</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_att_est</span><span class="o">.</span><span class="n">base_frame_directions</span> <span class="o">=</span> <span class="n">catalogue_dirs_use</span>

        <span class="c1"># estimate an updated attitude</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_att_est</span><span class="o">.</span><span class="n">estimate</span><span class="p">()</span>

        <span class="c1"># get the updated attitude rotation matrix</span>
        <span class="n">new_rot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_temp_att_est</span><span class="o">.</span><span class="n">rotation</span><span class="o">.</span><span class="n">matrix</span>

        <span class="c1"># rotate the catalogue directions into the camera frame and project them onto the image using the new</span>
        <span class="c1"># attitude</span>
        <span class="n">catalogue_dirs_cam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">new_rot</span><span class="p">,</span> <span class="n">catalogue_dirs</span><span class="p">)</span>

        <span class="n">catalogue_locs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">project_onto_image</span><span class="p">(</span><span class="n">catalogue_dirs_cam</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_temp_temperature</span><span class="p">,</span>
                                                       <span class="n">image</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_temp_image_number</span><span class="p">)</span>

        <span class="c1"># compute the residual distance in all of the pairs</span>
        <span class="n">resids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">catalogue_locs</span> <span class="o">-</span> <span class="n">image_locs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># check to see which pairs meet the ransac tolerance</span>
        <span class="n">inliers</span> <span class="o">=</span> <span class="n">resids</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ransac_tolerance</span>

        <span class="c1"># get the sum of the squares of the residuals</span>
        <span class="n">rs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">resids</span><span class="p">[</span><span class="n">inliers</span><span class="p">]</span> <span class="o">*</span> <span class="n">resids</span><span class="p">[</span><span class="n">inliers</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">inliers</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">inliers</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">image_locs</span><span class="p">[:,</span> <span class="n">inliers</span><span class="p">],</span> <span class="n">catalogue_dirs</span><span class="p">[:,</span> <span class="n">inliers</span><span class="p">],</span> <span class="n">inliers</span><span class="p">,</span> <span class="n">rs</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_generate_hash</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">max_pairs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function generates a 4d hash code given an array of points.  The points can be in any units so long as both</span>
<span class="sd">        the first and second component have the same units, and they can be expressed in any conformal coordinate system</span>
<span class="sd">        (most typically expressed as right ascension, declination angular coordinates, or row, column pixel coordinates)</span>

<span class="sd">        This method is still under development and should not be used</span>

<span class="sd">        :param points: an array like input containing the first component of each point in the first row and the second</span>
<span class="sd">                       component in the second row</span>
<span class="sd">        :return hash_code: a numpy array containing the hash codes for all permutations of the input points.  Each</span>
<span class="sd">                           column corresponds to an element of the hash_code and each row is a hash code for a specific</span>
<span class="sd">                           permutation</span>
<span class="sd">        :return hash_inds: a numpy array containing the corresponding indices to stars A, B, C, D used to generate each</span>
<span class="sd">                           hash code.  Each row corresponds to the same row in hash_code</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># # start by forming all possible combinations of 4 of the input points using the itertools combinations tool</span>
        <span class="c1"># if (max_pairs is None) or (max_pairs &gt; comb(points.shape[1], 4)):</span>
        <span class="c1">#     # combos_array = np.array([combo for combo in it.combinations(points.T, 4)]).transpose((0, 2, 1))</span>
        <span class="c1">#     combos_inds = np.array([combo for combo in it.combinations(np.arange(points.shape[1]), 4)])</span>
        <span class="c1"># else:</span>
        <span class="c1">#     # combos_inds = np.random.choice(points.shape[-1], (max_pairs, 4), replace=False)</span>
        <span class="c1">#     combos_inds_s = set()</span>
        <span class="c1">#     while len(combos_inds_s) &lt; max_pairs:</span>
        <span class="c1">#         combos_inds_s.add(tuple(sorted(random_combination(points.shape[-1], 4))))</span>
        <span class="c1">#</span>
        <span class="c1">#     combos_inds = np.array(list(combos_inds_s), dtype=int)</span>
        <span class="c1">#     # combos_inds = np.array([random_combination(points.shape[-1], 4) for i in range(max_pairs)])</span>
        <span class="n">combos_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">RandomCombinations</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">,</span> <span class="n">max_pairs</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">combos_inds</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="n">combos_array</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">combos_inds</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># set up the data type for the numpy arrays that will contain information about the combinations</span>
        <span class="c1"># start by determining which pair of points form the a,b pair, and which form the c,d pair</span>
        <span class="n">internal_dtype_ab</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;second&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)]</span>
        <span class="n">internal_dtype_cd</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;third&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;fourth&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)]</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

        <span class="c1"># create numpy arrays containing all possible combinations that could be ab pairs, do the same for cd pairs</span>
        <span class="n">ab_sets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">internal_dtype_ab</span><span class="p">)</span>
        <span class="n">cd_sets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">((</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">k</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ab_sets</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">internal_dtype_cd</span><span class="p">)</span>

        <span class="c1"># check the distances between all the points in each set of 4</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">combos_array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">combos_array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="mi">2</span><span class="p">),</span>
                                             <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">ab_sets</span><span class="p">])</span>

        <span class="c1"># determine which pair of points is spaced the furthest apart</span>
        <span class="n">pairing_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># store which pair of points is spaced furthest apart</span>
        <span class="n">ab_pairings</span> <span class="o">=</span> <span class="n">ab_sets</span><span class="p">[</span><span class="n">pairing_inds</span><span class="p">]</span>
        <span class="n">cd_pairings</span> <span class="o">=</span> <span class="n">cd_sets</span><span class="p">[</span><span class="n">pairing_inds</span><span class="p">]</span>

        <span class="c1"># generate a numpy array containing subscripts for each combination</span>
        <span class="n">hash_subscripts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">combos_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># determine the xy points if the &#39;first&#39; point in each pair is point A</span>
        <span class="n">xy01</span> <span class="o">=</span> <span class="p">(</span><span class="n">combos_array</span><span class="p">[</span><span class="n">hash_subscripts</span><span class="p">,</span> <span class="p">:,</span> <span class="n">ab_pairings</span><span class="p">[</span><span class="s1">&#39;second&#39;</span><span class="p">]]</span> <span class="o">-</span>
                <span class="n">combos_array</span><span class="p">[</span><span class="n">hash_subscripts</span><span class="p">,</span> <span class="p">:,</span> <span class="n">ab_pairings</span><span class="p">[</span><span class="s1">&#39;first&#39;</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># and the same for if the &#39;second&#39; point in point A</span>
        <span class="n">xy02</span> <span class="o">=</span> <span class="o">-</span><span class="n">xy01</span>

        <span class="c1"># calculate the rotation angle needed to enter into the hash space</span>
        <span class="n">theta01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">4.</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">xy01</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">xy01</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">theta02</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">4.</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">xy02</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">xy02</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># form the rotation matrices to enter into hash space</span>
        <span class="n">r1t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta01</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta01</span><span class="p">)))</span>
        <span class="n">r1b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta01</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta01</span><span class="p">)))</span>
        <span class="n">rotation1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">r1t</span><span class="p">,</span> <span class="n">r1b</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="n">r2t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta02</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta02</span><span class="p">)))</span>
        <span class="n">r2b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta02</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta02</span><span class="p">)))</span>
        <span class="n">rotation2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">r2t</span><span class="p">,</span> <span class="n">r2b</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="c1"># rotate all of the points into hash space</span>
        <span class="n">coords1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">rotation1</span><span class="p">,</span> <span class="n">combos_array</span> <span class="o">-</span>
                            <span class="n">combos_array</span><span class="p">[</span><span class="n">hash_subscripts</span><span class="p">,</span> <span class="p">:,</span> <span class="n">ab_pairings</span><span class="p">[</span><span class="s1">&#39;first&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="n">coords2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">rotation2</span><span class="p">,</span> <span class="n">combos_array</span> <span class="o">-</span>
                            <span class="n">combos_array</span><span class="p">[</span><span class="n">hash_subscripts</span><span class="p">,</span> <span class="p">:,</span> <span class="n">ab_pairings</span><span class="p">[</span><span class="s1">&#39;second&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>

        <span class="c1"># scale all of the points into hash space</span>
        <span class="n">coords1</span> <span class="o">/=</span> <span class="n">coords1</span><span class="p">[</span><span class="n">hash_subscripts</span><span class="p">,</span> <span class="p">:,</span> <span class="n">ab_pairings</span><span class="p">[</span><span class="s1">&#39;second&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">coords2</span> <span class="o">/=</span> <span class="n">coords2</span><span class="p">[</span><span class="n">hash_subscripts</span><span class="p">,</span> <span class="p">:,</span> <span class="n">ab_pairings</span><span class="p">[</span><span class="s1">&#39;first&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># initialize a numpy array to store the hash codes</span>
        <span class="n">hash_code</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">coords1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">hash_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">coords1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># check to see points where the sum of the x coordinates for the &#39;third&#39; and &#39;fourth&#39; points is less than 1</span>
        <span class="c1"># this indicates that the first hash space is correct for these point quads</span>
        <span class="n">x_coord_check</span> <span class="o">=</span> <span class="p">(</span><span class="n">coords1</span><span class="p">[</span><span class="n">hash_subscripts</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cd_pairings</span><span class="p">[</span><span class="s1">&#39;third&#39;</span><span class="p">]]</span> <span class="o">+</span>
                         <span class="n">coords1</span><span class="p">[</span><span class="n">hash_subscripts</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cd_pairings</span><span class="p">[</span><span class="s1">&#39;fourth&#39;</span><span class="p">]])</span> <span class="o">&lt;=</span> <span class="mi">1</span>  <span class="c1"># type: np.ndarray</span>

        <span class="c1"># determine the points with the minimum x coordinate in the first hash code space</span>
        <span class="n">min_subs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">([</span><span class="n">coords1</span><span class="p">[</span><span class="n">hash_subscripts</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cd_pairings</span><span class="p">[</span><span class="s1">&#39;third&#39;</span><span class="p">]],</span>
                              <span class="n">coords1</span><span class="p">[</span><span class="n">hash_subscripts</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cd_pairings</span><span class="p">[</span><span class="s1">&#39;fourth&#39;</span><span class="p">]]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># form a &quot;dictionary&quot; to translate the minimum subscripts into structured array fields</span>
        <span class="n">cd_dict</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;third&#39;</span><span class="p">,</span> <span class="s1">&#39;fourth&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">x_coord_check</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="c1"># form the hash codes for all points in which the first hash code space is correct</span>
            <span class="n">temp_hash</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">coords1</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cd_pairings</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">cd_dict</span><span class="p">[</span><span class="n">min_subs</span><span class="p">[</span><span class="n">ind</span><span class="p">]]]],</span>
                                   <span class="n">coords1</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cd_pairings</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">cd_dict</span><span class="p">[</span><span class="n">min_subs</span><span class="p">[</span><span class="n">ind</span><span class="p">]]]],</span>
                                   <span class="n">coords1</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cd_pairings</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">cd_dict</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">min_subs</span><span class="p">[</span><span class="n">ind</span><span class="p">]]]],</span>
                                   <span class="n">coords1</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cd_pairings</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">cd_dict</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">min_subs</span><span class="p">[</span><span class="n">ind</span><span class="p">]]]]]</span>
                                  <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">check</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">x_coord_check</span><span class="p">)</span> <span class="k">if</span> <span class="n">check</span><span class="p">])</span>

            <span class="n">temp_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">combos_inds</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="n">ab_pairings</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="s1">&#39;first&#39;</span><span class="p">]],</span>
                                   <span class="n">combos_inds</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="n">ab_pairings</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="s1">&#39;second&#39;</span><span class="p">]],</span>
                                   <span class="n">combos_inds</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="n">cd_pairings</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">cd_dict</span><span class="p">[</span><span class="n">min_subs</span><span class="p">[</span><span class="n">ind</span><span class="p">]]]],</span>
                                   <span class="n">combos_inds</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="n">cd_pairings</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">cd_dict</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">min_subs</span><span class="p">[</span><span class="n">ind</span><span class="p">]]]]]</span>
                                  <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">check</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">x_coord_check</span><span class="p">)</span> <span class="k">if</span> <span class="n">check</span><span class="p">])</span>

            <span class="c1"># store those hash codes</span>
            <span class="n">hash_code</span><span class="p">[</span><span class="n">x_coord_check</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">temp_hash</span><span class="p">)</span>
            <span class="n">hash_inds</span><span class="p">[</span><span class="n">x_coord_check</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">temp_inds</span><span class="p">)</span>

            <span class="c1"># now find the minimum x coordinates in the second hash code space</span>
            <span class="n">min_subs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">([</span><span class="n">coords2</span><span class="p">[</span><span class="n">hash_subscripts</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cd_pairings</span><span class="p">[</span><span class="s1">&#39;third&#39;</span><span class="p">]],</span>
                                  <span class="n">coords2</span><span class="p">[</span><span class="n">hash_subscripts</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cd_pairings</span><span class="p">[</span><span class="s1">&#39;fourth&#39;</span><span class="p">]]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">x_coord_check</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="c1"># generate hash codes for all quads for which the second has code space is correct</span>
            <span class="n">temp_hash</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">coords2</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cd_pairings</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">cd_dict</span><span class="p">[</span><span class="n">min_subs</span><span class="p">[</span><span class="n">ind</span><span class="p">]]]],</span>
                                   <span class="n">coords2</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cd_pairings</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">cd_dict</span><span class="p">[</span><span class="n">min_subs</span><span class="p">[</span><span class="n">ind</span><span class="p">]]]],</span>
                                   <span class="n">coords2</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cd_pairings</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">cd_dict</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">min_subs</span><span class="p">[</span><span class="n">ind</span><span class="p">]]]],</span>
                                   <span class="n">coords2</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cd_pairings</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">cd_dict</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">min_subs</span><span class="p">[</span><span class="n">ind</span><span class="p">]]]]]</span>
                                  <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">check</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="o">~</span><span class="n">x_coord_check</span><span class="p">)</span> <span class="k">if</span> <span class="n">check</span><span class="p">])</span>

            <span class="n">temp_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">combos_inds</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="n">ab_pairings</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="s1">&#39;second&#39;</span><span class="p">]],</span>
                                   <span class="n">combos_inds</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="n">ab_pairings</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="s1">&#39;first&#39;</span><span class="p">]],</span>
                                   <span class="n">combos_inds</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="n">cd_pairings</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">cd_dict</span><span class="p">[</span><span class="n">min_subs</span><span class="p">[</span><span class="n">ind</span><span class="p">]]]],</span>
                                   <span class="n">combos_inds</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="n">cd_pairings</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">cd_dict</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">min_subs</span><span class="p">[</span><span class="n">ind</span><span class="p">]]]]]</span>
                                  <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">check</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="o">~</span><span class="n">x_coord_check</span><span class="p">)</span> <span class="k">if</span> <span class="n">check</span><span class="p">])</span>

            <span class="c1"># store those hash codes and return the full result.</span>
            <span class="n">hash_code</span><span class="p">[</span><span class="o">~</span><span class="n">x_coord_check</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">temp_hash</span>
            <span class="n">hash_inds</span><span class="p">[</span><span class="o">~</span><span class="n">x_coord_check</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">temp_inds</span>

        <span class="k">return</span> <span class="n">hash_code</span><span class="p">,</span> <span class="n">hash_inds</span></div>
</pre></div>

          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2021 United States Government.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>