
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>giant.image_processing &#8212; GIANT 1.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="copyright" title="Copyright" href="../../copyright.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../index.html">
    <img class="logo" src="../../_static/logo.png" alt="Logo"/>
    
  </a>
</p>



<p class="blurb">A powerful API for Optical Navigation</p>






<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installing GIANT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../giant.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../giant.html#indices">Indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../copyright.html">Copyright</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <h1>Source code for giant.image_processing</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2021 United States Government as represented by the Administrator of the National Aeronautics and Space</span>
<span class="c1"># Administration.  No copyright is claimed in the United States under Title 17, U.S. Code. All Other Rights Reserved.</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module provides a number of image processing techniques for use throughout GIANT.</span>

<span class="sd">The class provided by this module, :class:`ImageProcessing`, is the primary tool used for working with image data</span>
<span class="sd">throughout GIANT. This class provides routines to identify point sources in an image (:meth:`.find_poi_in_roi`,</span>
<span class="sd">:meth:`.refine_locations`, :meth:`.locate_subpixel_poi_in_roi`), detect subpixel edges in an image (:meth:`.pae_edges`),</span>
<span class="sd">perform template matching through cross correlation (:meth:`.correlate`), and denoise/flatten an image and get its noise</span>
<span class="sd">level (:meth:`.flatten_image_and_get_noise_level`, :meth:`.denoise_image`).</span>

<span class="sd">For many of these methods, there are multiple algorithms that can be used to perform the same task.  The</span>
<span class="sd">:class:`ImageProcessing` class makes it easy to change what algorithm is being used by simply switching out one function</span>
<span class="sd">object for another.  There are a few selections of different algorithms that can be used already provided by this</span>
<span class="sd">module, and users can easily write their own algorithms and swap them in by following the instructions in the</span>
<span class="sd">:class:`ImageProcessing` class.</span>

<span class="sd">A general user will usually not directly interact with the classes and functions in this class and instead will rely on</span>
<span class="sd">the OpNav classes to interact for them.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>

<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span> <span class="k">as</span> <span class="nn">sig</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">fmin</span>
<span class="kn">from</span> <span class="nn">scipy.fftpack.helper</span> <span class="kn">import</span> <span class="n">next_fast_len</span>


<span class="kn">from</span> <span class="nn">giant._typing</span> <span class="kn">import</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">ARRAY_LIKE_2D</span><span class="p">,</span> <span class="n">Real</span>
<span class="kn">from</span> <span class="nn">giant.utilities.outlier_identifier</span> <span class="kn">import</span> <span class="n">get_outliers</span>
<span class="kn">from</span> <span class="nn">giant.point_spread_functions</span> <span class="kn">import</span> <span class="n">PointSpreadFunction</span><span class="p">,</span> <span class="n">Gaussian</span>


<span class="c1"># fix for Serializing</span>
<span class="n">cv2</span><span class="o">.</span><span class="n">GaussianBlur</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="s1">&#39;cv2&#39;</span>


<span class="c1"># compute the image sobel masks</span>
<span class="n">HORIZONTAL_KERNEL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                              <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span>
                              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The horizontal Sobel kernel for convolving with an image when computing the horizontal image gradients.</span>

<span class="sd">https://www.researchgate.net/publication/239398674_An_Isotropic_3x3_Image_Gradient_Operator</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">VERTICAL_KERNEL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                            <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The vertical Sobel kernel for convolving with an image when computing the vertical image gradients.</span>

<span class="sd">https://www.researchgate.net/publication/239398674_An_Isotropic_3x3_Image_Gradient_Operator</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">PAE_A01</span> <span class="o">=</span> <span class="mf">0.125</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The 0, 1 coefficient (upper middle) of the Gaussian kernel representing the blurring experienced in the images being </span>
<span class="sd">processed for the PAE sub-pixel edge method.</span>

<span class="sd">By default this is set to 0.125 assuming a 2D gaussian kernel with a sigma of 1 pixel in each axis.  If you know a </span>
<span class="sd">better approximation of the gaussian kernel that represents the point spread function in the image (combined with any </span>
<span class="sd">gaussian blurring applied to the image to smooth out noise) then you may get better results from the PAE method by </span>
<span class="sd">updating this value.</span>

<span class="sd">https://www.researchgate.net/publication/233397974_Accurate_Subpixel_Edge_Location_based_on_Partial_Area_Effect</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">PAE_A11</span> <span class="o">=</span> <span class="mf">0.0625</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The 1, 1 coefficient (upper left) of the Gaussian kernel representing the blurring experienced in the images being </span>
<span class="sd">processed for the PAE sub-pixel edge method.</span>

<span class="sd">By default this is set to 0.0625 assuming a 2D gaussian kernel with a sigma of 1 pixel in each axis.  If you know a </span>
<span class="sd">better approximation of the gaussian kernel that represents the point spread function in the image (combined with any </span>
<span class="sd">gaussian blurring applied to the image to smooth out noise) then you may get better results from the PAE method by </span>
<span class="sd">updating this value.</span>

<span class="sd">https://www.researchgate.net/publication/233397974_Accurate_Subpixel_Edge_Location_based_on_Partial_Area_Effect</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Store the Zernike Moments</span>
<span class="n">FIRST_ORDER_REAL_MOMENTS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">.0147</span><span class="p">,</span> <span class="o">-</span><span class="mf">.0469</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">.0469</span><span class="p">,</span> <span class="mf">.0147</span><span class="p">],</span>
                                     <span class="p">[</span><span class="o">-</span> <span class="mf">.0933</span><span class="p">,</span> <span class="o">-</span><span class="mf">.0640</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">.0640</span><span class="p">,</span> <span class="mf">.0933</span><span class="p">],</span>
                                     <span class="p">[</span><span class="o">-</span><span class="mf">.1253</span><span class="p">,</span> <span class="o">-</span><span class="mf">.0640</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">.0640</span><span class="p">,</span> <span class="mf">.1253</span><span class="p">],</span>
                                     <span class="p">[</span><span class="o">-</span><span class="mf">.0933</span><span class="p">,</span> <span class="o">-</span><span class="mf">.0640</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">.0640</span><span class="p">,</span> <span class="mf">.0933</span><span class="p">],</span>
                                     <span class="p">[</span><span class="o">-</span><span class="mf">.0147</span><span class="p">,</span> <span class="o">-</span><span class="mf">.0469</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">.0469</span><span class="p">,</span> <span class="mf">.0147</span><span class="p">]])</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">First order real component of Zernike Moments</span>

<span class="sd">This is used in the zernike moment sub-pixel edge detection routines</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">FIRST_ORDER_IMAGINARY_MOMENTS</span> <span class="o">=</span> <span class="n">FIRST_ORDER_REAL_MOMENTS</span><span class="o">.</span><span class="n">T</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">First order imaginary component of Zernike Moments</span>

<span class="sd">This is used in the zernike moment sub-pixel edge detection routines</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">SECOND_ORDER_MOMENTS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">.0177</span><span class="p">,</span> <span class="mf">.0595</span><span class="p">,</span> <span class="mf">.0507</span><span class="p">,</span> <span class="mf">.0595</span><span class="p">,</span> <span class="mf">.0177</span><span class="p">],</span>
                                 <span class="p">[</span><span class="mf">.0595</span><span class="p">,</span> <span class="o">-</span><span class="mf">.0492</span><span class="p">,</span> <span class="o">-</span><span class="mf">.1004</span><span class="p">,</span> <span class="o">-</span><span class="mf">.0492</span><span class="p">,</span> <span class="mf">.0595</span><span class="p">],</span>
                                 <span class="p">[</span><span class="mf">.0507</span><span class="p">,</span> <span class="o">-</span><span class="mf">.1004</span><span class="p">,</span> <span class="o">-</span><span class="mf">.1516</span><span class="p">,</span> <span class="o">-</span><span class="mf">.1004</span><span class="p">,</span> <span class="mf">.0507</span><span class="p">],</span>
                                 <span class="p">[</span><span class="mf">.0595</span><span class="p">,</span> <span class="o">-</span><span class="mf">.0492</span><span class="p">,</span> <span class="o">-</span><span class="mf">.1004</span><span class="p">,</span> <span class="o">-</span><span class="mf">.0492</span><span class="p">,</span> <span class="mf">.0595</span><span class="p">],</span>
                                 <span class="p">[</span><span class="mf">.0177</span><span class="p">,</span> <span class="mf">.0595</span><span class="p">,</span> <span class="mf">.0507</span><span class="p">,</span> <span class="mf">.0595</span><span class="p">,</span> <span class="mf">.0177</span><span class="p">]])</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Second order Zernike Moments</span>

<span class="sd">This is used in the zernike moment sub-pixel edge detection routines</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="SubpixelEdgeMethods"><a class="viewcode-back" href="../../image_processing/giant.image_processing.SubpixelEdgeMethods.html#giant.image_processing.SubpixelEdgeMethods">[docs]</a><span class="k">class</span> <span class="nc">SubpixelEdgeMethods</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This enumeration provides the valid options for subpixel edge detection methods.</span>

<span class="sd">    You should be sure to use one of these values when setting to the :attr:`.subpixel_method` attribute of the</span>
<span class="sd">    :class:`.ImageProcessing` class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">PIXEL</span> <span class="o">=</span> <span class="s2">&quot;PIXEL&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pixel level edges, no refining</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">PAE</span> <span class="o">=</span> <span class="s2">&quot;PAE&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use Partial Area Effect to compute subpixel edge locations.</span>
<span class="sd">    </span>
<span class="sd">    See :meth:`.refine_edges_pae` for details.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ZERNIKE_RAMP</span> <span class="o">=</span> <span class="s2">&quot;ZERNIKE_RAMP&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use Zernike Ramp to compute subpixel edge locations</span>
<span class="sd">    </span>
<span class="sd">    See :meth:`.refine_edges_zernike_ramp` for details.</span>
<span class="sd">    &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="ImageFlatteningNoiseApprox"><a class="viewcode-back" href="../../image_processing/giant.image_processing.ImageFlatteningNoiseApprox.html#giant.image_processing.ImageFlatteningNoiseApprox">[docs]</a><span class="k">class</span> <span class="nc">ImageFlatteningNoiseApprox</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This enumeration provides the valid options for flattening an image and determining the noise levels when</span>
<span class="sd">    identifying points of interest in :meth:`.ImageProcessing.find_poi_in_roi`</span>

<span class="sd">    You should be sure to use one of these values when setting to the :attr:`.image_flattening_noise_approximation`</span>
<span class="sd">    attribute of the :class:`.ImageProcessing` class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">GLOBAL</span> <span class="o">=</span> <span class="s2">&quot;GLOBAL&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Globally flatten the image and estimate the noise level from it.</span>
<span class="sd">    </span>
<span class="sd">    In this the image in flattened by subtracting a median filtered version of the image from it and a single noise </span>
<span class="sd">    level is approximated for the entire image either through sampling or through the :attr:`.dark_pixels` of the image.</span>
<span class="sd">    </span>
<span class="sd">    For most OpNav cases this is sufficient and fast.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">LOCAL</span> <span class="o">=</span> <span class="s2">&quot;LOCAL&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Locally flatten the image and estimate the noise levels for each local region</span>

<span class="sd">    In this the image in flattened by splitting it into regions, estimating a linear background gradient in each region,</span>
<span class="sd">    and the subtracting the estimated background gradient from the region to get the flattened region.  An individual </span>
<span class="sd">    noise level is estimated for each of these regions through sampling.</span>

<span class="sd">    This technique allows much dimmer points of interest to be extracted without overwhelming with noise, but it is </span>
<span class="sd">    generally much slower and is unnecessary for all but detailed analyses.</span>
<span class="sd">    &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="local_maxima"><a class="viewcode-back" href="../../image_processing/giant.image_processing.local_maxima.html#giant.image_processing.local_maxima">[docs]</a><span class="k">def</span> <span class="nf">local_maxima</span><span class="p">(</span><span class="n">data_grid</span><span class="p">:</span> <span class="n">ARRAY_LIKE_2D</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function returns a boolean mask selecting all local maxima from a 2d array.</span>

<span class="sd">    A local maxima is defined as any value that is greater than or equal to all of the values surrounding it.  That is,</span>
<span class="sd">    given:</span>

<span class="sd">    .. code::</span>

<span class="sd">        +---+---+---+</span>
<span class="sd">        | 1 | 2 | 3 |</span>
<span class="sd">        +---+---+---+</span>
<span class="sd">        | 4 | 5 | 6 |</span>
<span class="sd">        +---+---+---+</span>
<span class="sd">        | 7 | 8 | 9 |</span>
<span class="sd">        +---+---+---+</span>

<span class="sd">    value 5 is a local maxima if and only if it is greater than or equal to values 1, 2, 3, 4, 6, 7, 8, 9.</span>

<span class="sd">    For edge cases, only the valid cells are checked (ie value 1 would be checked against values 2, 4, 5 only).</span>

<span class="sd">    &gt;&gt;&gt; from giant.image_processing import local_maxima</span>
<span class="sd">    &gt;&gt;&gt; im = [[0, 1, 2, 20, 1],</span>
<span class="sd">    ...       [5, 2, 1, 3, 1],</span>
<span class="sd">    ...       [0, 1, 2, 10, 1],</span>
<span class="sd">    ...       [1, 2, -1, -2, -5]]</span>
<span class="sd">    &gt;&gt;&gt; local_maxima(im)</span>
<span class="sd">    array([[False, False, False,  True, False],</span>
<span class="sd">           [ True, False, False, False, False],</span>
<span class="sd">           [False, False, False,  True, False],</span>
<span class="sd">           [False,  True, False, False, False]], dtype=bool)</span>

<span class="sd">    :param data_grid: The grid of values to search for local maximas</span>
<span class="sd">    :return: A 2d boolean array with `True` where the data_grid values are local maximas</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># make sure the array is numpy</span>
    <span class="n">array2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">data_grid</span><span class="p">)</span>

    <span class="c1"># check the interior points</span>
    <span class="n">test</span> <span class="o">=</span> <span class="p">((</span><span class="n">array2d</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">array2d</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">array2d</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">array2d</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">array2d</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">array2d</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">array2d</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">array2d</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">array2d</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">array2d</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">array2d</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">array2d</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">array2d</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">array2d</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">array2d</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">array2d</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="p">)</span>

    <span class="c1"># test the edges</span>
    <span class="c1"># test the top</span>
    <span class="n">test</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">array2d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">array2d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">test</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">array2d</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">array2d</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">array2d</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">array2d</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:])</span>
    <span class="n">test</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">array2d</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">&gt;=</span> <span class="n">array2d</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">array2d</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">&gt;=</span> <span class="n">array2d</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># test the left</span>
    <span class="n">test</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">array2d</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">array2d</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">test</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">array2d</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">array2d</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">array2d</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">array2d</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">test</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">array2d</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">array2d</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">array2d</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">array2d</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="c1"># test the right</span>
    <span class="n">test</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">array2d</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">array2d</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">test</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">array2d</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">array2d</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">array2d</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">array2d</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">test</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">array2d</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">array2d</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">array2d</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">array2d</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">])</span>

    <span class="c1"># test the bottom</span>
    <span class="n">test</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">array2d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">array2d</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">test</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">array2d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">array2d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">array2d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">array2d</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:])</span>
    <span class="n">test</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">array2d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">&gt;=</span> <span class="n">array2d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">array2d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">&gt;=</span> <span class="n">array2d</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># send out the results</span>
    <span class="k">return</span> <span class="n">test</span></div>


<div class="viewcode-block" id="cv2_correlator_2d"><a class="viewcode-back" href="../../image_processing/giant.image_processing.cv2_correlator_2d.html#giant.image_processing.cv2_correlator_2d">[docs]</a><span class="k">def</span> <span class="nf">cv2_correlator_2d</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">template</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">flag</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">TM_CCOEFF_NORMED</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function performs a 2D cross correlation between ``image`` and ``template`` and returns the correlation surface</span>
<span class="sd">    using the `OpenCV matchTemplate function &lt;http://docs.opencv.org/3.1.0/d4/dc6/tutorial_py_template_matching.html&gt;`_.</span>

<span class="sd">    The input ``image`` and ``template`` are first converted to single precision (as is required by matchTemplate) and</span>
<span class="sd">    then given to the matchTemplate function.</span>

<span class="sd">    The flag indicates the correlation coefficients to calculate (in general you will want ``cv2.TM_CCOEFF_NORMED`` for</span>
<span class="sd">    normalized cross correlation).  For more information about this function see the OpenCV documentation at</span>
<span class="sd">    https://docs.opencv.org/master/d4/dc6/tutorial_py_template_matching.html</span>

<span class="sd">    Each pixel of the correlation surface returned by this function represents the correlation value when the center of</span>
<span class="sd">    the template is placed at this location.  Thus, the location of any point in the template can be found by</span>

<span class="sd">    &gt;&gt;&gt; import numpy</span>
<span class="sd">    &gt;&gt;&gt; from giant.image_processing import cv2_correlator_2d</span>
<span class="sd">    &gt;&gt;&gt; example_image = numpy.random.randn(200, 200)</span>
<span class="sd">    &gt;&gt;&gt; example_template = example_image[30:60, 45:60]</span>
<span class="sd">    &gt;&gt;&gt; surf = cv2_correlator_2d(example_image, example_template)</span>
<span class="sd">    &gt;&gt;&gt; temp_middle = numpy.floor(numpy.array(example_template.shape)/2)</span>
<span class="sd">    &gt;&gt;&gt; template_point = numpy.array([0, 0])  # upper left corner</span>
<span class="sd">    &gt;&gt;&gt; template_point - temp_middle + numpy.unravel_index(surf.argmax(), surf.shape)</span>
<span class="sd">    array([30., 45.])</span>

<span class="sd">    :param image: The image that the template is to be matched against</span>
<span class="sd">    :param template: the template that is to be matched against the image</span>
<span class="sd">    :param flag: A flag indicating the correlation coefficient to be calculated</span>
<span class="sd">    :return: A surface of the correlation coefficients for each overlap between the template and the image.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># calculate what the size of the correlation surface should be and pad the image with 0s</span>
    <span class="n">size_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">template</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">size_diff</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">lower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">size_diff</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="n">original_shape</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="p">[(</span><span class="n">lower</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">upper</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="n">lower</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">upper</span><span class="p">[</span><span class="mi">1</span><span class="p">])],</span> <span class="s1">&#39;constant&#39;</span><span class="p">)</span>

    <span class="c1"># perform the correlation</span>
    <span class="n">cor_surf</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">matchTemplate</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">template</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">flag</span><span class="p">)</span>

    <span class="c1"># return the correlation surface of the appropriate size</span>
    <span class="k">return</span> <span class="n">cor_surf</span><span class="p">[:</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span></div>


<span class="k">def</span> <span class="nf">_normalize_xcorr_2d</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">zero_mean_temp</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">corr_surf</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates normalized correlation coefficients between the template and the image based off of the</span>
<span class="sd">    non-normalized correlation between temp and image.</span>

<span class="sd">    This method works by computing the local standard deviation and mean of the image for each overlay of the template,</span>
<span class="sd">    then dividing the correlation surface by the difference of these values (roughly at least).</span>

<span class="sd">    This function is used inside of both :func:`spatial_correlator_2d` and :func:`fft_correlator_2d` to normalize the</span>
<span class="sd">    correlation surfaces.  Typically it is not used explicitly by the user.</span>

<span class="sd">    :param image: the image that was correlated against</span>
<span class="sd">    :param zero_mean_temp: the zero mean version of the template that was correlated</span>
<span class="sd">    :param corr_surf: the non-normalized correlation surface to be normalized</span>
<span class="sd">    :return: the normalized correlation surface</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># the following code is based off of MATLAB&#39;s normxcorr2 which is based off of</span>
    <span class="c1"># Lewis, J. P. &quot;Fast normalized cross-correlation.&quot; Vision interface. Vol. 10. No. 1. 1995.</span>
    <span class="k">def</span> <span class="nf">local_sum</span><span class="p">(</span><span class="n">in_mat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the integral of in_mat over the given search areas.</span>

<span class="sd">        :param in_mat: the matrix to be integrated</span>
<span class="sd">        :param shape: the size of the search areas</span>
<span class="sd">        :return: a matrix containing the integral of in_mat for a search area overlaid starting at each pixel of in_mat</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># first, pad in_mat so that the template can be overlaid on the borders as well</span>
        <span class="n">in_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">in_mat</span><span class="p">,</span> <span class="p">[(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])],</span> <span class="s1">&#39;constant&#39;</span><span class="p">)</span>

        <span class="c1"># calculate the cumulative summation along the first axis (down each row)</span>
        <span class="n">sum1</span> <span class="o">=</span> <span class="n">in_mat</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># calculate the running sums for the rows</span>
        <span class="n">temp1</span> <span class="o">=</span> <span class="n">sum1</span><span class="p">[</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">sum1</span><span class="p">[:(</span><span class="o">-</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="c1"># calculate the cumulative summation along the second axis (down each column)</span>
        <span class="n">sum2</span> <span class="o">=</span> <span class="n">temp1</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># calculate the running sums for the cols</span>
        <span class="k">return</span> <span class="n">sum2</span><span class="p">[:,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">sum2</span><span class="p">[:,</span> <span class="p">:(</span><span class="o">-</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>

    <span class="c1"># get the integral of the images under the template for each overlay</span>
    <span class="n">local_means</span> <span class="o">=</span> <span class="n">local_sum</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">zero_mean_temp</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># this is the template.size*mean of the image within the</span>
    <span class="c1"># template window for every overlay of the template</span>
    <span class="n">local_sum_squares</span> <span class="o">=</span> <span class="n">local_sum</span><span class="p">(</span><span class="n">image</span> <span class="o">*</span> <span class="n">image</span><span class="p">,</span>
                                  <span class="n">zero_mean_temp</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># this is the sum of the squares of the image within</span>
    <span class="c1"># the template window for every overlay of the template</span>

    <span class="c1"># calculate the variance of the image under the template for the area overlaid under each image and ensure the</span>
    <span class="c1"># variance is positive or zero (it will only be negative due to numerical precision issues)</span>
    <span class="n">local_variance</span> <span class="o">=</span> <span class="n">local_sum_squares</span> <span class="o">-</span> <span class="n">local_means</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">zero_mean_temp</span><span class="o">.</span><span class="n">size</span>
    <span class="n">local_variance</span><span class="p">[</span><span class="n">local_variance</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># calculate the variance of the template itself</span>
    <span class="n">temp_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">zero_mean_temp</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="c1"># calculate the product of the local standard deviations of the image and the standard deviation of the template</span>
    <span class="c1"># (this is the same as the square root of the product of the variances)</span>
    <span class="n">std_image_std_template</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">local_variance</span> <span class="o">*</span> <span class="n">temp_variance</span><span class="p">)</span>

    <span class="c1"># calculate the normalized correlation coefficients</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">corr_surf</span> <span class="o">/</span> <span class="n">std_image_std_template</span>

    <span class="c1"># check to make sure that machine precision and divide by zero errors haven&#39;t given us any invalid answers</span>
    <span class="n">res</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># this step shouldn&#39;t be necessary due to the previous step but its basically instantaneous so keep it in to be safe</span>
    <span class="n">res</span><span class="p">[</span><span class="n">std_image_std_template</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">return</span> <span class="n">res</span>


<div class="viewcode-block" id="fft_correlator_2d"><a class="viewcode-back" href="../../image_processing/giant.image_processing.fft_correlator_2d.html#giant.image_processing.fft_correlator_2d">[docs]</a><span class="k">def</span> <span class="nf">fft_correlator_2d</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">ARRAY_LIKE_2D</span><span class="p">,</span> <span class="n">template</span><span class="p">:</span> <span class="n">ARRAY_LIKE_2D</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function performs normalized cross correlation between a template and an image in the frequency domain.</span>

<span class="sd">    The correlation is performed over the full image, aligning the center of the template with every pixel in the image.</span>
<span class="sd">    (Note that this means that if the center of the template should be outside of the image this function will not</span>
<span class="sd">    work.)</span>

<span class="sd">    The correlation in this method is roughly performed by</span>

<span class="sd">    #. take the 2D fourier transform of the image and the fliplr/flipud template</span>
<span class="sd">    #. multiply each term of the frequency image and template together</span>
<span class="sd">    #. take the inverse fourier transform of the product from step 2.</span>
<span class="sd">    #. normalize the correlation coefficients</span>

<span class="sd">    Each pixel of the correlation surface returned by this function represents the correlation value when the center of</span>
<span class="sd">    the template is placed at this location.  Thus, the location of any point in the template can be found by</span>

<span class="sd">    &gt;&gt;&gt; import numpy as numpy</span>
<span class="sd">    &gt;&gt;&gt; from giant.image_processing import fft_correlator_2d</span>
<span class="sd">    &gt;&gt;&gt; example_image = numpy.random.randn(200, 200)</span>
<span class="sd">    &gt;&gt;&gt; example_template = example_image[30:60, 45:60]</span>
<span class="sd">    &gt;&gt;&gt; surf = fft_correlator_2d(example_image, example_template)</span>
<span class="sd">    &gt;&gt;&gt; temp_middle = numpy.floor(numpy.array(example_template.shape)/2)</span>
<span class="sd">    &gt;&gt;&gt; template_point = numpy.array([0, 0])  # upper left corner</span>
<span class="sd">    &gt;&gt;&gt; template_point - temp_middle + numpy.unravel_index(surf.argmax(), surf.shape)</span>
<span class="sd">    array([30., 45.])</span>

<span class="sd">    :param image: The image that the template is to be matched against</span>
<span class="sd">    :param template: the template that is to be matched against the image</span>
<span class="sd">    :return: A surface of the correlation coefficients for each overlap between the template and the image.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># perform the correlation in the frequency domain.  Note that template needs to be fliplr/flipud due to the</span>
    <span class="c1"># definition of correlation</span>

    <span class="c1"># use the zero mean template to simplify some steps later</span>
    <span class="n">zero_mean_temp</span> <span class="o">=</span> <span class="n">template</span> <span class="o">-</span> <span class="n">template</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">corr_surf</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">fftconvolve</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">zero_mean_temp</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;full&#39;</span><span class="p">)</span>
    <span class="c1"># the preceding is mostly equivalent to the following but it does a better job of handling the shapes to make things</span>
    <span class="c1"># faster</span>
    <span class="c1"># fft_shape = np.array(image.shape)+np.array(template.shape)-1</span>
    <span class="c1"># image_fft = np.fft.rfft2(image, s=fft_shape)</span>
    <span class="c1"># template_fft = np.fft.rfft2(template[::-1, ::-1], s=fft_shape)</span>
    <span class="c1"># corr_surf = np.fft.irfft2(image_fft*template_fft, s=fft_shape)</span>

    <span class="c1"># this forms the un-normalized correlation surface.  Now we need to normalize:</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">_normalize_xcorr_2d</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">zero_mean_temp</span><span class="p">,</span> <span class="n">corr_surf</span><span class="p">)</span>

    <span class="c1"># get the output size for output type of &quot;same&quot;</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="n">lower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># return the correlation surface for type &quot;same&quot;</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="n">lower</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="o">-</span><span class="n">upper</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lower</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="o">-</span><span class="n">upper</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span></div>


<div class="viewcode-block" id="spatial_correlator_2d"><a class="viewcode-back" href="../../image_processing/giant.image_processing.spatial_correlator_2d.html#giant.image_processing.spatial_correlator_2d">[docs]</a><span class="k">def</span> <span class="nf">spatial_correlator_2d</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">template</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function performs normalized cross correlation directly (spatial correlation).</span>

<span class="sd">    The correlation is performed over the full image, aligning the center of the template with every pixel in the image.</span>
<span class="sd">    (Note that this means that if the center of the template should be outside of the image this function will not</span>
<span class="sd">    work.)</span>

<span class="sd">    Each pixel of the correlation surface returned by this function represents the correlation value when the center of</span>
<span class="sd">    the template is placed at this location.  Thus, the location of any point in the template can be found by</span>

<span class="sd">    &gt;&gt;&gt; import numpy</span>
<span class="sd">    &gt;&gt;&gt; from giant.image_processing import spatial_correlator_2d</span>
<span class="sd">    &gt;&gt;&gt; example_image = numpy.random.randn(200, 200)</span>
<span class="sd">    &gt;&gt;&gt; example_template = example_image[30:60, 45:60]</span>
<span class="sd">    &gt;&gt;&gt; surf = spatial_correlator_2d(example_image, example_template)</span>
<span class="sd">    &gt;&gt;&gt; temp_middle = numpy.floor(numpy.array(example_template.shape)/2)</span>
<span class="sd">    &gt;&gt;&gt; template_point = numpy.array([0, 0])  # upper left corner -- replace 0, 0 with whichever template location you</span>
<span class="sd">    &gt;&gt;&gt; # want (starting with the upper left as 0, 0).</span>
<span class="sd">    &gt;&gt;&gt; template_point - temp_middle + numpy.unravel_index(surf.argmax(), surf.shape)</span>
<span class="sd">    array([30., 45.])</span>

<span class="sd">    :param image: The image that the template is to be matched against</span>
<span class="sd">    :param template: the template that is to be matched against the image</span>
<span class="sd">    :return: A surface of the correlation coefficients for each overlap between the template and the image.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">template</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">zero_mean_temp</span> <span class="o">=</span> <span class="n">template</span> <span class="o">-</span> <span class="n">template</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

    <span class="n">corr_surf</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">convolve2d</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">zero_mean_temp</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;full&#39;</span><span class="p">)</span>

    <span class="c1"># this forms the un-normalized correlation surface.  Now we need to normalize:</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">_normalize_xcorr_2d</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">zero_mean_temp</span><span class="p">,</span> <span class="n">corr_surf</span><span class="p">)</span>

    <span class="c1"># get the output size for output type of &quot;same&quot;</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="n">lower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># return the correlation surface for type &quot;same&quot;</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="n">lower</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="o">-</span><span class="n">upper</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lower</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="o">-</span><span class="n">upper</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span></div>


<span class="k">def</span> <span class="nf">_normalize_xcorr_1d</span><span class="p">(</span><span class="n">extracted</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">zero_mean_predicted</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">corr_lines</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function normalizes correlation coefficients between 1d lines based off of the non-normalized correlation</span>
<span class="sd">    between the 1d lines. This method works by computing the local standard deviation and mean of the extracted for</span>
<span class="sd">    each overlay of the temps, then dividing the correlation surface by the difference of these values (roughly</span>
<span class="sd">    at least). This function is used inside of :func:`n1d_correlate` to normalize the</span>
<span class="sd">    correlation surfaces.</span>

<span class="sd">    :param extracted: the extracted scan lines that were correlated against (each image should be contained in the last</span>
<span class="sd">                      axis</span>
<span class="sd">    :param zero_mean_predicted: the zero mean versions of the predicted_lines that were correlated</span>
<span class="sd">    :param corr_lines: the non-normalized correlation lines to be normalized</span>
<span class="sd">    :return: the normalized correlation lines</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># The following code is based off of MATLAB&#39;s normxcorr2 which is based off of</span>
    <span class="c1"># Lewis, J. P. &quot;Fast normalized cross-correlation.&quot; Vision interface. Vol. 10. No. 1. 1995.</span>

    <span class="k">def</span> <span class="nf">local_sum</span><span class="p">(</span><span class="n">in_mat</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the integral of in_mat over the given search areas.</span>

<span class="sd">        :param in_mat: the matrix to be integrated</span>
<span class="sd">        :param shape: the size of the search areas</span>
<span class="sd">        :return: a matrix containing the integral of in_mat for a search area overlaid starting at each pixel of in_mat</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># First, pad in_mat so that the template can be overlaid on the borders as well</span>
        <span class="n">in_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">in_mat</span><span class="p">,</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])],</span> <span class="s1">&#39;constant&#39;</span><span class="p">)</span>

        <span class="c1"># Calculate the cumulative summation along the second axis (down each column)</span>
        <span class="n">sum2</span> <span class="o">=</span> <span class="n">in_mat</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Calculate the running sums for the cols</span>
        <span class="k">return</span> <span class="n">sum2</span><span class="p">[:,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">sum2</span><span class="p">[:,</span> <span class="p">:(</span><span class="o">-</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>

    <span class="c1"># Get the integral of the extracted lines under the template for each overlay</span>
    <span class="n">local_means</span> <span class="o">=</span> <span class="n">local_sum</span><span class="p">(</span><span class="n">extracted</span><span class="p">,</span> <span class="n">zero_mean_predicted</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># this is the predicted.size*mean of the extracted</span>

    <span class="c1"># Within the predicted window for every overlay of the predicted</span>
    <span class="n">local_sum_square</span> <span class="o">=</span> <span class="n">local_sum</span><span class="p">(</span><span class="n">extracted</span> <span class="o">*</span> <span class="n">extracted</span><span class="p">,</span>
                                 <span class="n">zero_mean_predicted</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># This is the sum of the squares of the image within</span>
    <span class="c1"># The template window for every overlay of the template</span>

    <span class="c1"># Calculate the variance of the extracted lines under the predicted_lines for the area overlaid under each image and</span>
    <span class="c1"># Ensure the variance is positive or zero (it will only be negative due to numerical precision issues)</span>
    <span class="n">local_variance</span> <span class="o">=</span> <span class="n">local_sum_square</span> <span class="o">-</span> <span class="n">local_means</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">zero_mean_predicted</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">local_variance</span><span class="p">[</span><span class="n">local_variance</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Calculate the variance of the template itself</span>
    <span class="n">temp_variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">zero_mean_predicted</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Calculate the product of the local standard deviations of the image and the standard deviation of the template</span>
    <span class="c1"># (This is the same as the square root of the product of the variances)</span>
    <span class="n">std_image_std_template</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">local_variance</span> <span class="o">*</span> <span class="n">temp_variance</span><span class="p">)</span>

    <span class="c1"># Calculate the normalized correlation coefficients</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">corr_lines</span> <span class="o">/</span> <span class="n">std_image_std_template</span>

    <span class="c1"># Check to make sure that machine precision and divide by zero errors haven&#39;t given us any invalid answers</span>
    <span class="n">res</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># This step shouldn&#39;t be necessary due to the previous step but its basically instantaneous so keep it in to be safe</span>
    <span class="n">res</span><span class="p">[</span><span class="n">std_image_std_template</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">_fft_correlate_1d</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function performs FFT based correlation on nd arrays of 1d scan lines.</span>

<span class="sd">    :param a: array of 1d scan lines</span>
<span class="sd">    :param b: array of 1d scan lines</span>
<span class="sd">    :return: array of spatial correlation values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Determine the size of the correlation surface for type &quot;full&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># Get the next fast fft length</span>
    <span class="n">fft_size</span> <span class="o">=</span> <span class="n">next_fast_len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="c1"># Transform the input values into the frequency domain</span>
    <span class="n">a_fft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">fft_size</span><span class="p">)</span>
    <span class="n">b_fft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">fft_size</span><span class="p">)</span>

    <span class="c1"># Perform the correlation and transform back to the spatial domain</span>
    <span class="n">cc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">a_fft</span> <span class="o">*</span> <span class="n">b_fft</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">n</span><span class="o">=</span><span class="n">fft_size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">cc</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">cc</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]])</span>


<div class="viewcode-block" id="fft_correlator_1d"><a class="viewcode-back" href="../../image_processing/giant.image_processing.fft_correlator_1d.html#giant.image_processing.fft_correlator_1d">[docs]</a><span class="k">def</span> <span class="nf">fft_correlator_1d</span><span class="p">(</span><span class="n">extracted_lines</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">predicted_lines</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function performs 1d correlation based on extracted lines and predicted lines.</span>

<span class="sd">    Each line of the input matrices should be a pair of scan lines to be correlated.  The result of this function</span>
<span class="sd">    will be a numpy array of correlation coefficients for the cross correlation of the lines.</span>

<span class="sd">    The correlation is computed using discrete fourier transforms to transform the scan lines into the frequency domain.</span>
<span class="sd">    The correlation is then performed in the frequency domain and then transformed back into the spatial domain.</span>
<span class="sd">    Finally, the spatial correlation lines are normalized to have values between -1 and 1 in the usual sense.</span>

<span class="sd">    :param extracted_lines: array of extracted lines to be correlated</span>
<span class="sd">    :param predicted_lines: array of predicted lines to be correlated</span>
<span class="sd">    :return: array of correlation coefficients for each scan line pair.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Subtract the mean from each template to reduce the complexity later</span>
    <span class="n">zero_mean_pred_lines</span> <span class="o">=</span> <span class="n">predicted_lines</span> <span class="o">-</span> <span class="n">predicted_lines</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Get the un-normalized correlation lines (for a &quot;full&quot; correlation)</span>
    <span class="n">un_normalized_corr_lines</span> <span class="o">=</span> <span class="n">_fft_correlate_1d</span><span class="p">(</span><span class="n">extracted_lines</span><span class="p">,</span> <span class="n">zero_mean_pred_lines</span><span class="p">)</span>

    <span class="c1"># Normalize the correlation coefficients to be between -1 and 1</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">_normalize_xcorr_1d</span><span class="p">(</span><span class="n">extracted_lines</span><span class="p">,</span> <span class="n">zero_mean_pred_lines</span><span class="p">,</span> <span class="n">un_normalized_corr_lines</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span>

    <span class="c1"># Select only correlation coefficients for type &quot;same&quot;</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">extracted_lines</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="c1"># Determine the regions of the correlation lines that are valid</span>
    <span class="n">lower</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">diff</span><span class="p">))</span>
    <span class="n">upper</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">diff</span><span class="p">))</span>

    <span class="c1"># Only return the valid regions</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">lower</span><span class="p">:</span><span class="o">-</span><span class="n">upper</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="otsu"><a class="viewcode-back" href="../../image_processing/giant.image_processing.otsu.html#giant.image_processing.otsu">[docs]</a><span class="k">def</span> <span class="nf">otsu</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Real</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function performs multilevel Otsu thresholding on a 2D array.</span>

<span class="sd">    Otsu thresholding is a technique by which the optimal threshold is chosen so as to split a 2D array based on the</span>
<span class="sd">    peaks in its histogram.  In multilevel thresholding, we choose multiple optimal thresholds so that multiple peaks</span>
<span class="sd">    are separated.  This process is described in</span>
<span class="sd">    &quot;Otsu N, A Threshold Selection Method from Gray-Level Histograms, IEEE Trans. Syst. Man Cybern. 1979;9:62-66.&quot;</span>

<span class="sd">    To use this function, simply input the image and the number of times you want to split the histogram.  The function</span>
<span class="sd">    will then return the optimal threshold values used to bin the image (n-1 thresholds), and a labeled image where each</span>
<span class="sd">    bin has its own number (n labels).  Note that the function will convert the image to a uint8 image if it is not</span>
<span class="sd">    already, and the thresholds will correspond to the uint8 image.</span>

<span class="sd">    This function uses the opencv threhold function to perform the thresholding when n=2 and is based off of the</span>
<span class="sd">    MATLAB function otsu</span>
<span class="sd">    (https://www.mathworks.com/matlabcentral/fileexchange/26532-image-segmentation-using-otsu-thresholding?s_tid=prof_contriblnk)</span>
<span class="sd">    for when n&gt;=3.</span>

<span class="sd">    &gt;&gt;&gt; import numpy</span>
<span class="sd">    &gt;&gt;&gt; from giant.image_processing import otsu</span>
<span class="sd">    &gt;&gt;&gt; from giant.point_spread_functions import Gaussian</span>
<span class="sd">    &gt;&gt;&gt; im = numpy.zeros((100, 100), dtype=numpy.float64)</span>
<span class="sd">    &gt;&gt;&gt; x, y = numpy.meshgrid(numpy.arange(10), numpy.arange(10))</span>
<span class="sd">    &gt;&gt;&gt; psf = Gaussian(sigma_x=1.5, sigma_y=0.7, amplitude=100, centroid_x=5, centroid_y=5)</span>
<span class="sd">    &gt;&gt;&gt; im[50:60, 50:60] = psf.evaluate(x, y)</span>
<span class="sd">    &gt;&gt;&gt; thresh, labeled_im = otsu(im, 3)</span>
<span class="sd">    &gt;&gt;&gt; print(thresh)</span>
<span class="sd">    [0.24723526470339388, 2.235294117647059]</span>

<span class="sd">    :param image: The grayscale image to be thresholded as a numpy array</span>
<span class="sd">    :param n: The number of times to bin the image (for a binary threshold n=2)</span>
<span class="sd">    :return: The n-1 threshold values and the labeled image with the background</span>
<span class="sd">             being labeled 0 and each subsequent bin being labeled with the next integer (ie 1, 2, 3, ...)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># convert the image to uint 8 (Assume it is already grayscale)</span>
    <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">:</span>
        <span class="c1"># noinspection PyArgumentList</span>
        <span class="n">delta_conv</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">iu8</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">-</span> <span class="n">delta_conv</span>
        <span class="n">multi_conv</span> <span class="o">=</span> <span class="mi">255</span> <span class="o">/</span> <span class="n">iu8</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">iu8</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">iu8</span> <span class="o">*</span> <span class="n">multi_conv</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">iu8</span> <span class="o">=</span> <span class="n">image</span>
        <span class="n">delta_conv</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">multi_conv</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">threshold</span><span class="p">,</span> <span class="n">labeled_image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">threshold</span><span class="p">(</span><span class="n">iu8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">THRESH_OTSU</span> <span class="o">+</span> <span class="n">cv2</span><span class="o">.</span><span class="n">THRESH_BINARY</span><span class="p">)</span>

        <span class="n">threshold</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">threshold</span><span class="p">)</span>
        <span class="n">threshold</span> <span class="o">/=</span> <span class="n">multi_conv</span>
        <span class="n">threshold</span> <span class="o">+=</span> <span class="n">delta_conv</span>

        <span class="n">threshold</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">threshold</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">threshold</span><span class="p">],</span> <span class="n">labeled_image</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># get the unique dn values at uint8 level</span>
        <span class="n">unique_iu8</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">iu8</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>

        <span class="n">range_unique_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">unique_iu8</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># generate a histogram of the values</span>
        <span class="n">hist</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">iu8</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">unique_iu8</span><span class="p">,</span> <span class="p">[</span><span class="mi">256</span><span class="p">]]))</span>

        <span class="c1"># estimate the pdf by scaling back so the integral is equal to 1</span>
        <span class="n">pdf</span> <span class="o">=</span> <span class="n">hist</span> <span class="o">/</span> <span class="n">hist</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="n">range_unique_image_pdf</span> <span class="o">=</span> <span class="n">range_unique_image</span> <span class="o">*</span> <span class="n">pdf</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>

            <span class="c1"># determine the zeroth and first-order cumulative moments</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">pdf</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">range_unique_image_pdf</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>

            <span class="n">w0</span> <span class="o">=</span> <span class="n">w</span>
            <span class="n">w2</span> <span class="o">=</span> <span class="n">pdf</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">w0</span><span class="p">,</span> <span class="n">w2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">w0</span><span class="p">,</span> <span class="n">w2</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>

            <span class="n">mu0</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">/</span> <span class="n">w</span>

            <span class="n">mu2</span> <span class="o">=</span> <span class="p">(</span><span class="n">range_unique_image_pdf</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span> <span class="o">/</span> <span class="n">pdf</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">())[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">mu0</span><span class="p">,</span> <span class="n">mu2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">mu0</span><span class="p">,</span> <span class="n">mu2</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>

            <span class="n">w1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">w0</span> <span class="o">-</span> <span class="n">w2</span>

            <span class="n">w1</span><span class="p">[</span><span class="n">w1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="n">mu0mue</span> <span class="o">=</span> <span class="n">mu0</span> <span class="o">-</span> <span class="n">mu</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">mu2mue</span> <span class="o">=</span> <span class="n">mu2</span> <span class="o">-</span> <span class="n">mu</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">w0mu0mue</span> <span class="o">=</span> <span class="n">w0</span> <span class="o">*</span> <span class="n">mu0mue</span>
            <span class="n">w2mu2mue</span> <span class="o">=</span> <span class="n">w2</span> <span class="o">*</span> <span class="n">mu2mue</span>

            <span class="n">sigma2b</span> <span class="o">=</span> <span class="n">w0mu0mue</span> <span class="o">*</span> <span class="n">mu0mue</span> <span class="o">+</span> <span class="n">w2mu2mue</span> <span class="o">*</span> <span class="n">mu2mue</span> <span class="o">+</span> <span class="p">(</span><span class="n">w0mu0mue</span> <span class="o">+</span> <span class="n">w2mu2mue</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">w1</span>

            <span class="n">sigma2b</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">sigma2b</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">k</span> <span class="o">=</span> <span class="n">sigma2b</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>

            <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">sigma2b</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

            <span class="n">labeled_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

            <span class="n">labeled_image</span><span class="p">[(</span><span class="n">iu8</span> <span class="o">&gt;</span> <span class="n">unique_iu8</span><span class="p">[</span><span class="n">k1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">iu8</span> <span class="o">&lt;=</span> <span class="n">unique_iu8</span><span class="p">[</span><span class="n">k2</span><span class="p">])]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">labeled_image</span><span class="p">[</span><span class="n">iu8</span> <span class="o">&gt;</span> <span class="n">unique_iu8</span><span class="p">[</span><span class="n">k2</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">2</span>

            <span class="n">thresholds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">unique_iu8</span><span class="p">[</span><span class="n">k1</span><span class="p">],</span> <span class="n">unique_iu8</span><span class="p">[</span><span class="n">k2</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

            <span class="n">thresholds</span> <span class="o">/=</span> <span class="n">multi_conv</span>
            <span class="n">thresholds</span> <span class="o">+=</span> <span class="n">delta_conv</span>

            <span class="c1"># noinspection PyTypeChecker</span>
            <span class="n">out_thresh</span> <span class="o">=</span> <span class="n">thresholds</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>  <span class="c1"># type: list</span>

            <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">out_thresh</span><span class="p">):</span>
                <span class="n">out_thresh</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">image</span><span class="p">[</span><span class="n">labeled_image</span> <span class="o">==</span> <span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()),</span> <span class="n">image</span><span class="p">[</span><span class="n">labeled_image</span> <span class="o">==</span> <span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>

            <span class="k">return</span> <span class="n">out_thresh</span><span class="p">,</span> <span class="n">labeled_image</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">mut</span> <span class="o">=</span> <span class="n">range_unique_image_pdf</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">sig2t</span> <span class="o">=</span> <span class="p">((</span><span class="n">range_unique_image</span> <span class="o">-</span> <span class="n">mut</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pdf</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="k">def</span> <span class="nf">sig_fun</span><span class="p">(</span><span class="n">ik</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
                <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                A temporary function for passing to the optimizer</span>

<span class="sd">                :param ik:</span>
<span class="sd">                :return:</span>
<span class="sd">                &quot;&quot;&quot;</span>

                <span class="n">ik</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ik</span> <span class="o">*</span> <span class="p">(</span><span class="n">unique_iu8</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.000000000001</span><span class="p">)</span>
                <span class="n">ik</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">ik</span><span class="p">)</span>

                <span class="k">if</span> <span class="p">((</span><span class="n">ik</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ik</span> <span class="o">&gt;</span> <span class="n">unique_iu8</span><span class="o">.</span><span class="n">size</span><span class="p">))</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="k">return</span> <span class="mi">1</span>

                <span class="n">ik</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">ik</span><span class="p">,</span> <span class="n">unique_iu8</span><span class="o">.</span><span class="n">size</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

                <span class="n">sigma2bi</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">wj</span> <span class="o">=</span> <span class="n">pdf</span><span class="p">[</span><span class="n">ik</span><span class="p">[</span><span class="n">ii</span><span class="p">]:</span><span class="n">ik</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

                    <span class="k">if</span> <span class="n">wj</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">return</span> <span class="mi">1</span>

                    <span class="n">muj</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ik</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ik</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">pdf</span><span class="p">[</span><span class="n">ik</span><span class="p">[</span><span class="n">ii</span><span class="p">]:</span><span class="n">ik</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">wj</span>
                    <span class="n">sigma2bi</span> <span class="o">+=</span> <span class="n">wj</span> <span class="o">*</span> <span class="p">(</span><span class="n">muj</span> <span class="o">-</span> <span class="n">mut</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

                <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">sigma2bi</span> <span class="o">/</span> <span class="n">sig2t</span>

            <span class="n">k0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">kk</span> <span class="o">=</span> <span class="n">fmin</span><span class="p">(</span><span class="n">sig_fun</span><span class="p">,</span> <span class="n">k0</span><span class="p">,</span> <span class="n">xtol</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">kk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">kk</span> <span class="o">*</span> <span class="p">(</span><span class="n">unique_iu8</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

            <span class="n">labeled_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

            <span class="n">labeled_image</span><span class="p">[</span><span class="n">iu8</span> <span class="o">&gt;</span> <span class="n">unique_iu8</span><span class="p">[</span><span class="n">kk</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">labeled_image</span><span class="p">[(</span><span class="n">iu8</span> <span class="o">&gt;</span> <span class="n">unique_iu8</span><span class="p">[</span><span class="n">kk</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">iu8</span> <span class="o">&lt;=</span> <span class="n">unique_iu8</span><span class="p">[</span><span class="n">kk</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]])]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># put back into the original image values</span>
            <span class="n">thresholds</span> <span class="o">=</span> <span class="n">unique_iu8</span><span class="p">[</span><span class="n">kk</span><span class="p">[:</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">thresholds</span> <span class="o">/=</span> <span class="n">multi_conv</span>
            <span class="n">thresholds</span> <span class="o">+=</span> <span class="n">delta_conv</span>

            <span class="c1"># noinspection PyTypeChecker</span>
            <span class="n">out_thresh</span> <span class="o">=</span> <span class="n">thresholds</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>  <span class="c1"># type: list</span>

            <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">out_thresh</span><span class="p">):</span>
                <span class="n">out_thresh</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">image</span><span class="p">[</span><span class="n">labeled_image</span> <span class="o">==</span> <span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()),</span> <span class="n">image</span><span class="p">[</span><span class="n">labeled_image</span> <span class="o">==</span> <span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>

            <span class="k">return</span> <span class="n">out_thresh</span><span class="p">,</span> <span class="n">labeled_image</span></div>


<div class="viewcode-block" id="pixel_level_peak_finder_2d"><a class="viewcode-back" href="../../image_processing/giant.image_processing.pixel_level_peak_finder_2d.html#giant.image_processing.pixel_level_peak_finder_2d">[docs]</a><span class="k">def</span> <span class="nf">pixel_level_peak_finder_2d</span><span class="p">(</span><span class="n">surface</span><span class="p">:</span> <span class="n">ARRAY_LIKE_2D</span><span class="p">,</span> <span class="n">blur</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function returns a numpy array containing the (x, y) location of the maximum surface value</span>
<span class="sd">    to pixel level accuracy.</span>

<span class="sd">    Optionally, a blur can be applied to the surface before locating the peak to attempt to remove high frequency noise.</span>

<span class="sd">    :param surface: A surface, or image, to use</span>
<span class="sd">    :param blur: A flag to indicate whether to apply Gaussian blur to image</span>
<span class="sd">    :return: The (x, y) location of the maximum surface values to pixel level accuracy.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">surface</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">blur</span><span class="p">:</span>
        <span class="c1"># Do this to try to avoid spikes due to noise aligning</span>
        <span class="n">surface</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">GaussianBlur</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">surface</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">surface</span><span class="p">)))</span></div>


<div class="viewcode-block" id="quadric_peak_finder_2d"><a class="viewcode-back" href="../../image_processing/giant.image_processing.quadric_peak_finder_2d.html#giant.image_processing.quadric_peak_finder_2d">[docs]</a><span class="k">def</span> <span class="nf">quadric_peak_finder_2d</span><span class="p">(</span><span class="n">surface</span><span class="p">:</span> <span class="n">ARRAY_LIKE_2D</span><span class="p">,</span> <span class="n">fit_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">blur</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                           <span class="n">shift_limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function returns a numpy array containing the (x, y) location of the maximum surface value</span>
<span class="sd">    which corresponds to the peak of the fitted quadric surface to subpixel accuracy.</span>

<span class="sd">    First, this function calls :func:`pixel_level_peak_finder_2d` to identify the pixel location of the peak of the</span>
<span class="sd">    correlation surface.  It then fits a 2D quadric to the pixels around the peak and solves for the center of the</span>
<span class="sd">    quadric to be the peak value.  The quadric equation that is fit is</span>

<span class="sd">    .. math::</span>
<span class="sd">        z = Ax^2+By^2+Cxy+Dx+Ey+F</span>

<span class="sd">    where :math:`z` is the height of the correlation surface at location :math:`(x,y)`, and :math:`A--F` are the</span>
<span class="sd">    coefficients to be fit.  The fit is performed in an algebraic least squares sense.</span>
<span class="sd">    The location of the peak of the surface is then given by:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \left[\begin{array}{c}x_p \\ y_p\end{array}\right] = \frac{1}{4AB-C^2}\left[\begin{array}{c} CE-2BD\\</span>
<span class="sd">        CD-2AE\end{array}\right]</span>

<span class="sd">    where :math:`(x_p,y_p)` is the location of the peak.</span>

<span class="sd">    If the peak is invalid because it is too close to the edge, the fit failed, or the parabolic fit moved</span>
<span class="sd">    the peak too far from the pixel level peak then the result is returned as NaNs.</span>

<span class="sd">    :param surface: A surface, or image, to use</span>
<span class="sd">    :param fit_size: Number of pixels around the peak that are used in fitting the paraboloid</span>
<span class="sd">    :param blur: A flag to indicate whether to apply Gaussian blur to the correlation surface to filter out high</span>
<span class="sd">                 frequency noise</span>
<span class="sd">    :param shift_limit: maximum difference from the pixel level peak to the fitted peak for the fitted peak to be</span>
<span class="sd">                        accepted</span>
<span class="sd">    :return: The (x, y) location corresponding to the peak of fitted quadric surface to subpixel accuracy</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># make sure we have an array</span>
    <span class="n">surface</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>

    <span class="c1"># find the pixel level peak</span>
    <span class="n">max_col</span><span class="p">,</span> <span class="n">max_row</span> <span class="o">=</span> <span class="n">pixel_level_peak_finder_2d</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">blur</span><span class="o">=</span><span class="n">blur</span><span class="p">)</span>

    <span class="c1"># if we&#39;re too close to the edge return NaNs</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">max_row</span> <span class="o">-</span> <span class="n">fit_size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">((</span><span class="n">max_row</span> <span class="o">+</span> <span class="n">fit_size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">surface</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> \
            <span class="p">((</span><span class="n">max_col</span> <span class="o">-</span> <span class="n">fit_size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">((</span><span class="n">max_col</span> <span class="o">+</span> <span class="n">fit_size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">surface</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>

    <span class="c1"># set up the columns/rows we will fit the peak to</span>
    <span class="n">deltas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">fit_size</span><span class="p">,</span> <span class="n">fit_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">cols</span><span class="p">,</span> <span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">max_col</span> <span class="o">+</span> <span class="n">deltas</span><span class="p">,</span> <span class="n">max_row</span> <span class="o">+</span> <span class="n">deltas</span><span class="p">)</span>

    <span class="n">cols</span> <span class="o">=</span> <span class="n">cols</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="n">rows</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="c1"># form the jacobian matrix for the leas squares</span>
    <span class="n">jac_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cols</span> <span class="o">*</span> <span class="n">cols</span><span class="p">,</span> <span class="n">rows</span> <span class="o">*</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">*</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">rows</span><span class="o">.</span><span class="n">shape</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># perform the least squares fit</span>
    <span class="n">coefs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">jac_matrix</span><span class="p">,</span> <span class="n">surface</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># extract the peak column and row</span>
    <span class="n">peak_col</span> <span class="o">=</span> <span class="p">(</span><span class="n">coefs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">coefs</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">coefs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">coefs</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">coefs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">coefs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">coefs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">peak_row</span> <span class="o">=</span> <span class="p">(</span><span class="n">coefs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">coefs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">coefs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">coefs</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">coefs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">coefs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">coefs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Check if peak of fitted parabolic surface is outside the correlation surface:</span>
    <span class="k">if</span> <span class="n">peak_col</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">surface</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">peak_row</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">surface</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>

    <span class="c1"># Check if peak pixel and peak of fitted parabolic surface are reasonably close:</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">max_col</span> <span class="o">-</span> <span class="n">peak_col</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">shift_limit</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">max_row</span> <span class="o">-</span> <span class="n">peak_row</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">shift_limit</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>

    <span class="c1"># Fit is valid, return the fit:</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">peak_col</span><span class="p">,</span> <span class="n">peak_row</span><span class="p">])</span></div>


<div class="viewcode-block" id="pixel_level_peak_finder_1d"><a class="viewcode-back" href="../../image_processing/giant.image_processing.pixel_level_peak_finder_1d.html#giant.image_processing.pixel_level_peak_finder_1d">[docs]</a><span class="k">def</span> <span class="nf">pixel_level_peak_finder_1d</span><span class="p">(</span><span class="n">correlation_lines</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function returns a numpy array containing the location of the maximum surface value</span>
<span class="sd">    to pixel level accuracy for each row of the input matrix.</span>

<span class="sd">    :return: The location of the maximum surface values to pixel level accuracy.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># noinspection PyTypeChecker</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">correlation_lines</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>  <span class="c1"># type: np.ndarray</span>
    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="parabolic_peak_finder_1d"><a class="viewcode-back" href="../../image_processing/giant.image_processing.parabolic_peak_finder_1d.html#giant.image_processing.parabolic_peak_finder_1d">[docs]</a><span class="k">def</span> <span class="nf">parabolic_peak_finder_1d</span><span class="p">(</span><span class="n">correlation_lines</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">fit_size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the subpixel maximum location along each row.</span>

<span class="sd">    First, this function calls :func:`pixel_level_peak_finder_1d` to identify the location of the peak of each row.</span>
<span class="sd">    It then fits a parabola to the values around the peak and solves for the center of the</span>
<span class="sd">    parabola to be the peak value.  The parabola equation that is fit is</span>

<span class="sd">    .. math::</span>
<span class="sd">        y = Ax^2+Bx+C</span>

<span class="sd">    where :math:`y` is the value of the correlation line at location :math:`x`, and :math:`A-C` are the</span>
<span class="sd">    coefficients to be fit.  The fit is performed in an algebraic least squares sense.</span>
<span class="sd">    The location of the peak of the surface is then given by:</span>

<span class="sd">    .. math::</span>
<span class="sd">        x_p = \frac{-B}{2A}</span>

<span class="sd">    where :math:`x_p` is the location of the peak.</span>

<span class="sd">    :param correlation_lines: array of correlation lines</span>
<span class="sd">    :param fit_size: number of values on each side to include in the parabola fit</span>
<span class="sd">    :return: array of subpixel centers for each row</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the pixel level correlation surface</span>
    <span class="n">max_cols</span> <span class="o">=</span> <span class="n">pixel_level_peak_finder_1d</span><span class="p">(</span><span class="n">correlation_lines</span><span class="p">)</span>

    <span class="c1"># Determine which values to include in the parabola fit</span>
    <span class="n">deltas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">fit_size</span><span class="p">,</span> <span class="n">fit_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Get the original shape of the correlation lines</span>
    <span class="n">base_shape</span> <span class="o">=</span> <span class="n">correlation_lines</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Reshape the correlation lines to be only 2d</span>
    <span class="n">correlation_lines</span> <span class="o">=</span> <span class="n">correlation_lines</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">base_shape</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Get the column indices for the fit</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_cols</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">base_shape</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">deltas</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Build the jacobian matrix</span>
    <span class="n">jac_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cols</span> <span class="o">*</span> <span class="n">cols</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cols</span><span class="o">.</span><span class="n">shape</span><span class="p">)]),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Build the rhs</span>
    <span class="n">rhs</span> <span class="o">=</span> <span class="n">correlation_lines</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[:</span><span class="n">correlation_lines</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:</span><span class="mi">0</span><span class="p">][:</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">cols</span><span class="p">]]</span>

    <span class="c1"># Fit the paraboloid using LLS</span>
    <span class="n">solus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">jac_matrix</span> <span class="o">@</span> <span class="n">jac_matrix</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">jac_matrix</span> <span class="o">@</span> <span class="n">rhs</span><span class="p">)</span>

    <span class="c1"># Return the subpixel center</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">solus</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">solus</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">base_shape</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span></div>


<div class="viewcode-block" id="ImageProcessing"><a class="viewcode-back" href="../../image_processing/giant.image_processing.ImageProcessing.html#giant.image_processing.ImageProcessing">[docs]</a><span class="k">class</span> <span class="nc">ImageProcessing</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class is a collection of various image processing techniques used throughout GIANT.</span>

<span class="sd">    All image processing techniques for the GIANT algorithms are contained in this class.  This includes</span>
<span class="sd">    centroiding algorithms for stars and unresolved bodies, algorithms for extracting bright spots from an image</span>
<span class="sd">    (particularly useful in the detection of stars and unresolved bodies), denoising algorithms,</span>
<span class="sd">    and edge detection algorithms.  The class essentially works as a container for the various options required for</span>
<span class="sd">    each technique.  It also makes it easier to pass data between different functions that may be required for</span>
<span class="sd">    individual algorithms.</span>

<span class="sd">    In general, users will not directly interact with this class, as it is used internally by many other GIANT</span>
<span class="sd">    routines.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">centroiding</span><span class="p">:</span> <span class="n">PointSpreadFunction</span> <span class="o">=</span> <span class="n">Gaussian</span><span class="p">,</span>
                 <span class="n">image_denoising</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">GaussianBlur</span><span class="p">,</span>
                 <span class="n">denoising_args</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="mi">0</span><span class="p">),</span> <span class="n">denoising_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">denoise_flag</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">pae_threshold</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span> <span class="n">pae_order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">centroid_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                 <span class="n">correlator</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">cv2_correlator_2d</span><span class="p">,</span> <span class="n">correlator_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">poi_min_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">poi_max_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span> <span class="n">poi_threshold</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
                 <span class="n">reject_saturation</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">subpixel_method</span><span class="p">:</span> <span class="n">SubpixelEdgeMethods</span> <span class="o">=</span> <span class="n">SubpixelEdgeMethods</span><span class="o">.</span><span class="n">PAE</span><span class="p">,</span>
                 <span class="n">save_psf</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">return_stats</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">zernike_edge_width</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
                 <span class="n">otsu_levels</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">minimum_segment_area</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">minimum_segment_dn</span><span class="p">:</span> <span class="n">Real</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
                 <span class="n">image_flattening_noise_approximation</span><span class="p">:</span> <span class="n">ImageFlatteningNoiseApprox</span> <span class="o">=</span> <span class="n">ImageFlatteningNoiseApprox</span><span class="o">.</span><span class="n">GLOBAL</span><span class="p">,</span>
                 <span class="n">flattening_kernel_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">7</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param centroiding: A callable object which takes 3 positional arguments and estimates the centers of a ROI</span>
<span class="sd">        :param image_denoising: A callable object with takes an image as the first positional argument and returns the</span>
<span class="sd">                                denoised image</span>
<span class="sd">        :param denoising_args: The rest of the positional arguments for the image_denoising callable</span>
<span class="sd">        :param denoising_kwargs: the keyword arguments for the image_denoising callable as a dictionary</span>
<span class="sd">        :param denoise_flag: A flag to indicate whether to denoise the image before applying the other techniques</span>
<span class="sd">        :param pae_threshold: The threshold for identifying pixel level edges in the PAE method</span>
<span class="sd">        :param pae_order:  The order of fit for the PAE refinement (must be 1 or 2)</span>
<span class="sd">        :param centroid_size:  half of the area passed to the centroiding function for refining the poi positions</span>
<span class="sd">        :param correlator: The cross correlation function to use</span>
<span class="sd">        :param correlator_kwargs: Key word arguments to pass to the correlator function</span>
<span class="sd">        :param poi_min_size: The minimum size for blobs to be considered points of interest</span>
<span class="sd">        :param poi_max_size: The maximum size for blobs to be considered points of interest</span>
<span class="sd">        :param poi_threshold: The threshold for coarsely identifying potential points of interest</span>
<span class="sd">        :param reject_saturation: A flag indicating whether to reject blobs that contain saturated pixels when</span>
<span class="sd">                                  performing poi identification.  Note that the saturation dn value must be stored in</span>
<span class="sd">                                  a `saturation` attribute for each image object being considered</span>
<span class="sd">        :param subpixel_method: An enumeration specifying which method to use for identifying subpixel edges</span>
<span class="sd">        :param save_psf: A flag specifying whether to save the fit psf in the centroiding methods</span>
<span class="sd">        :param return_stats: A flag specifying whether to return stats about each point of interest in the locate_poi</span>
<span class="sd">                             methods</span>
<span class="sd">        :param zernike_edge_width: The expected width of the edges for the zernike ramp edge method.</span>
<span class="sd">        :param otsu_levels: The number of levels to attempt to split the histogram by for Otsu thresholding.</span>
<span class="sd">        :param minimum_segment_dn: The minimum average DN for a segment to be considered foreground instead of</span>
<span class="sd">                                   background</span>
<span class="sd">        :param minimum_segment_area: The minimum area for a segment to be considered foreground instead of</span>
<span class="sd">                                     noise in pixels squared.</span>
<span class="sd">        :param image_flattening_noise_approximation: A</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">centroiding</span> <span class="o">=</span> <span class="n">centroiding</span>  <span class="c1"># type: PointSpreadFunction</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The PSF object that estimates the center of a region of interest.</span>
<span class="sd">        </span>
<span class="sd">        This should be of the form::</span>
<span class="sd">        </span>
<span class="sd">            res = centroiding(x, y, illums)</span>
<span class="sd">            x0, y0 = res.centroid</span>
<span class="sd">            </span>
<span class="sd">        where x0, y0 is the subpixel center of the blob, [...] are optional outputs containing information about the </span>
<span class="sd">        fit, x, y are arrays of the column and row locations corresponding to illums, and illums are the illumination </span>
<span class="sd">        values at x, y.  </span>
<span class="sd">        </span>
<span class="sd">        There are a few built in options for centroiding in the :mod:`.point_spread_functions` package or you can build</span>
<span class="sd">        your own.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">save_psf</span> <span class="o">=</span> <span class="n">save_psf</span>  <span class="c1"># type: bool</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A boolean flag specifying whether to save the point spread function fit.</span>
<span class="sd">        </span>
<span class="sd">        If this parameter is set to ``true`` then resulting PSF object from the :attr:`centroiding` attribute is saved</span>
<span class="sd">        in addition to just the centroid.  To ensure that the fit statistics are also saved for each PSF</span>
<span class="sd">        ensure the :attr:`~.PointSpreadFunction.save_residuals` class attribute on the PSF object is set to ``True`` as</span>
<span class="sd">        well.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">image_denoising</span> <span class="o">=</span> <span class="n">image_denoising</span>  <span class="c1"># type: Callable</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A callable that is used to decrease the effects of noise in an image.</span>
<span class="sd">        </span>
<span class="sd">        This should take the form of::</span>
<span class="sd">        </span>
<span class="sd">            denoised_image = image_denoising(original_image, *denoising_args, *denoising_kwargs)</span>
<span class="sd">            </span>
<span class="sd">        where ``original_image`` is the original 2D grayscale image as a numpy array, ``denoising_args`` are additional</span>
<span class="sd">        positional arguments to the image_denoising callable in a list, denoising_kwargs are a dictionary of key word</span>
<span class="sd">        arguments to pass to the image_denoising method, and denoised_image is a grayscale 2D image containing</span>
<span class="sd">        the noise suppressed version of the input image.</span>
<span class="sd">        </span>
<span class="sd">        By default this applies a 2D Gaussian blurring kernel of size 3, 3 to the image to suppress the noise effects.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subpixel_method</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">subpixel_method</span> <span class="o">=</span> <span class="n">subpixel_method</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">subpixel_method</span> <span class="o">=</span> <span class="n">SubpixelEdgeMethods</span><span class="p">(</span><span class="n">subpixel_method</span><span class="p">)</span>  <span class="c1"># type: SubpixelEdgeMethods</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        An enumeration (string) specifying what subpixel edge refinement method to use.</span>
<span class="sd">        </span>
<span class="sd">        This can specified as an attribute of the :class:`SubpixelEdgeMethods` enumeration directly or as a string</span>
<span class="sd">        that corresponds to that enumeration.  </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">zernike_edge_width</span> <span class="o">=</span> <span class="n">zernike_edge_width</span>  <span class="c1"># type: float</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A tuning parameter for the Zernike Ramp method specifying half the total edge width in pixels.</span>
<span class="sd">        </span>
<span class="sd">        Typically this is set to 1.66*sigma where sigma is the point spread function full width half maximum for the </span>
<span class="sd">        camera.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">denoising_args</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># type: list</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A list of additional arguments to pass to the :attr:`.image_denoising` callable after the image.</span>
<span class="sd">        </span>
<span class="sd">        This list is expanded using the typical python expansion.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">denoising_args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">denoising_args</span> <span class="o">=</span> <span class="n">denoising_args</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">denoising_kwargs</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># type: dict</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A dictionary of keyword arguments to pass to the :attr:`.image_denoising` callable after the image.</span>

<span class="sd">        This dictionary is expanded using the typical python expansion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">denoising_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">denoising_kwargs</span> <span class="o">=</span> <span class="n">denoising_kwargs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">denoise_flag</span> <span class="o">=</span> <span class="n">denoise_flag</span>  <span class="c1"># type: bool</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A boolean specifying whether to apply the :attr:`.image_denoising` callable before applying other image </span>
<span class="sd">        processing routines to an image.</span>
<span class="sd">        </span>
<span class="sd">        Set this attribute to True to apply the denoising routine and False to not apply the denoising routine.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">correlator</span> <span class="o">=</span> <span class="n">correlator</span>  <span class="c1"># type: Callable</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A callable that is used to perform cross correlation between an image and a template</span>
<span class="sd">        </span>
<span class="sd">        This should take the image as the first argument, the template as the second argument, and</span>
<span class="sd">        correlator_kwargs as the key word arguments.  That is, it should be of the form::</span>

<span class="sd">            cor_surf = correlator(image, template, **correlator_kwargs)</span>

<span class="sd">        where cor_surf is the correlation surface.  By default this is set to :func:`.cv2_correlator_2d`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">correlator_kwargs</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># type: dict</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A dictionary of keyword arguments to pass to the :attr:`.correlator` callable after the image and the template.</span>

<span class="sd">        This dictionary is expanded using the typical python expansion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">correlator_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">correlator_kwargs</span> <span class="o">=</span> <span class="n">correlator_kwargs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pae_threshold</span> <span class="o">=</span> <span class="n">pae_threshold</span>  <span class="c1"># type: float</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This tuning parameter specifies the minimum absolute image gradient for a location in an image to be considered </span>
<span class="sd">        an edge for the Partial Area Effect Method.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pae_order</span> <span class="o">=</span> <span class="n">pae_order</span>  <span class="c1"># type: int</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This specifies whether to fit a linear (1) or quadratic (2) to the limb in the PAE method.  </span>
<span class="sd">        </span>
<span class="sd">        Typically quadratic produces the best results.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">centroid_size</span> <span class="o">=</span> <span class="n">centroid_size</span>  <span class="c1"># type: int</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This specifies how many pixels to include when identifying a centroid in a region of interest.</span>
<span class="sd">        </span>
<span class="sd">        This sets the +/- number from the peak brightness pixel in both axes (so that a value of 1 means</span>
<span class="sd">        a 3x3 grid will be considered, a value of 2 will result in a 5x5 grid, etc).  </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">poi_threshold</span> <span class="o">=</span> <span class="n">poi_threshold</span>  <span class="c1"># type: float</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This specifies the sigma multiplier to use when identifying a pixel as a point of interest.</span>
<span class="sd">        </span>
<span class="sd">        The sigma multiplier is applied to a rough noise estimate of the image (see </span>
<span class="sd">        :meth:`.flatten_image_and_get_noise_level`) and then any pixels above this DN value are labeled as interesting </span>
<span class="sd">        pixels that require further processing (see :meth:`.locate_subpixel_poi_in_roi`).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">poi_min_size</span> <span class="o">=</span> <span class="n">poi_min_size</span>  <span class="c1"># type: int</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This specifies the minimum number of pixels that must be connected for a blob to be considered a point of </span>
<span class="sd">        interest.</span>

<span class="sd">        Individual pixels are clumped using a connected components algorithm, and then the size of each blob is compared</span>
<span class="sd">        against this value.  See :meth:`.locate_subpixel_poi_in_roi` for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">poi_max_size</span> <span class="o">=</span> <span class="n">poi_max_size</span>  <span class="c1"># type: int</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This specifies the maximum number of pixels that must be connected for a blob to be considered a point of </span>
<span class="sd">        interest.</span>

<span class="sd">        Individual pixels are clumped using a connected components algorithm, and then the size of each blob is compared</span>
<span class="sd">        against this value.  see :meth:`.locate_subpixel_poi_in_roi` for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reject_saturation</span> <span class="o">=</span> <span class="n">reject_saturation</span>  <span class="c1"># type: bool</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This boolean flag specifies whether to ignore clumps of pixels that contain saturated DN values when identifying </span>
<span class="sd">        points of interest in an image.</span>
<span class="sd">        </span>
<span class="sd">        Set to True to reject any clumps containing saturated pixels.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">return_stats</span> <span class="o">=</span> <span class="n">return_stats</span>  <span class="c1"># type: bool</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This boolean flag specifies whether to return statistics about each blob when identifying points of interest in </span>
<span class="sd">        the image.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">otsu_levels</span> <span class="o">=</span> <span class="n">otsu_levels</span>  <span class="c1"># type int</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This sets the number of levels to attempt to segment the histogram into for Otsu based multi level thresholding.</span>
<span class="sd">        </span>
<span class="sd">        See the :func:`.otsu` function for more details.</span>
<span class="sd">        </span>
<span class="sd">        This is used in method :meth:`segment_image`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">minimum_segment_area</span> <span class="o">=</span> <span class="n">minimum_segment_area</span>  <span class="c1"># type int</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This sets the minimum area for a segment to be considered not noise.</span>
<span class="sd">        </span>
<span class="sd">        Segments with areas less than this are discarded as noise spikes</span>
<span class="sd">        </span>
<span class="sd">        This is used in method :meth:`segment_image`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">minimum_segment_dn</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">minimum_segment_dn</span><span class="p">)</span>  <span class="c1"># type float</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The minimum that the average DN for a segment must be for it to not be discarded as the background.</span>

<span class="sd">        Segments with average DNs less than this are discarded as the background</span>
<span class="sd">        </span>
<span class="sd">        This is used in method :meth:`segment_image`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image_flattening_noise_approximation</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">image_flattening_noise_approximation</span> <span class="o">=</span> <span class="n">image_flattening_noise_approximation</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">image_flattening_noise_approximation</span><span class="p">:</span> <span class="n">ImageFlatteningNoiseApprox</span> <span class="o">=</span> <span class="n">ImageFlatteningNoiseApprox</span><span class="p">(</span>
            <span class="n">image_flattening_noise_approximation</span>
        <span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This specifies whether to globally flatten the image and compute a single noise level or to locally do so.</span>
<span class="sd">        </span>
<span class="sd">        Generally global is sufficient for star identification purposes.  If you are trying to extract very dim stars </span>
<span class="sd">        (or particles) then you may need to use the ``&#39;LOCAL&#39;`` option, which is much better for low SNR targets but </span>
<span class="sd">        much slower.</span>
<span class="sd">        </span>
<span class="sd">        This is used in :meth:`find_poi_in_roi` and :meth:`flatten_image_and_get_noise_level`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">flattening_kernel_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">flattening_kernel_size</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This specifies the half size of the kernel to use when locally flattening an image.  </span>
<span class="sd">        </span>
<span class="sd">        If you are using global flattening of an image this is ignored.</span>
<span class="sd">        </span>
<span class="sd">        The size of the kernel/region used in flattening the image will be ``2*flattening_kernel_size+1``.</span>
<span class="sd">        </span>
<span class="sd">        This is used in :meth:`flatten_image_and_get_noise_level`.</span>
<span class="sd">        &quot;&quot;&quot;</span>


    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>

        <span class="n">ip_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">):</span>
                <span class="n">ip_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span>
                <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">=</span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ip_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">ip_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Callable</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">value</span><span class="o">.</span><span class="vm">__name__</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">):</span>
                <span class="n">ip_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span>
                <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">=</span><span class="si">{!s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ip_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">segment_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method attempts to segment images into foreground/background objects.</span>

<span class="sd">        The objects are segmented by</span>
<span class="sd">        #. Performing a multi-level Otsu threshold on the image</span>
<span class="sd">        #. Choosing all but the bottom level from Otsu as likely foreground.</span>
<span class="sd">        #. Performing connected components on all the likely foreground objects</span>
<span class="sd">        #. Rejecting connected objects where the DN is less than the :attr:`minimum_segment_dn`</span>
<span class="sd">        #. Rejecting connected objects where the area is less than the :attr:`minimum_segment_area`</span>

<span class="sd">        The resulting objects are returned as a label matrix, where values &gt;=1 indicate a pixel containing a foreground</span>
<span class="sd">        object (values of 0 are the background object). In addition, the statistics about the foreground objects are</span>
<span class="sd">        returned.</span>

<span class="sd">        :param image: The image to attempt to segment</span>
<span class="sd">        :return: The label array, stats array about the labels in order, and the centroids of the segments</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># threshold the image</span>
        <span class="n">levels</span><span class="p">,</span> <span class="n">thresholded</span> <span class="o">=</span> <span class="n">otsu</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">otsu_levels</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">levels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_segment_dn</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;warning, the minimum Otsu level is greater than the minimum segment DN. This could indicate that &#39;</span>
                  <span class="sa">f</span><span class="s1">&#39;there is an issue with your settings.</span><span class="se">\n\t</span><span class="s1">minimum_segment_dn = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">minimum_segment_dn</span><span class="si">}</span><span class="se">\n\t</span><span class="s1">&#39;</span>
                  <span class="sa">f</span><span class="s1">&#39;otsu_level = </span><span class="si">{</span><span class="n">levels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">foreground_image</span> <span class="o">=</span> <span class="p">(</span><span class="n">thresholded</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">labeled</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">centroids</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">connectedComponentsWithStats</span><span class="p">(</span><span class="n">foreground_image</span><span class="p">)</span>

        <span class="n">out_labeled</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">labeled</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="n">out_stats</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">out_centroids</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">stored_ind</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">sorted_labs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">stats</span><span class="p">[:,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_AREA</span><span class="p">])</span>  <span class="c1"># sort the labels by size</span>

        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">sorted_labs</span><span class="p">:</span>

            <span class="n">stat</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="n">centroid</span> <span class="o">=</span> <span class="n">centroids</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">stat</span><span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_AREA</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_segment_area</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">boolean_label</span> <span class="o">=</span> <span class="n">labeled</span> <span class="o">==</span> <span class="n">ind</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="n">boolean_label</span><span class="p">])</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_segment_dn</span><span class="p">:</span>
                <span class="k">break</span>  <span class="c1"># since we are going in reverse size order if we get here we&#39;re done</span>

            <span class="n">out_labeled</span><span class="p">[</span><span class="n">boolean_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">stored_ind</span>
            <span class="n">out_stats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stat</span><span class="p">)</span>
            <span class="n">out_centroids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">centroid</span><span class="p">)</span>
            <span class="n">stored_ind</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">out_labeled</span><span class="p">,</span> <span class="n">foreground_image</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out_stats</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out_centroids</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_global_flat_image_and_noise</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is used to sample the noise level of an image, as well as return a flattened version of the image.</span>

<span class="sd">        The image is flattened by subtracting off a median filtered copy of the image from the image itself</span>

<span class="sd">        The standard deviation of the noise level in the image is estimated by either calculating the standard deviation</span>
<span class="sd">        of flattened user defined dark pixels for the image (contained in the :attr:`.OpNavImage.dark_pixels` attribute)</span>
<span class="sd">        or by calculating the standard deviation of 2,000 randomly sampled differences between pixel pairs of the</span>
<span class="sd">        flattened image spaced 5 rows and 5 columns apart.</span>

<span class="sd">        This method is used by :meth:`locate_subpixel_poi_in_roi` in order to make the point of interest identification</span>
<span class="sd">        easier.</span>

<span class="sd">        :param image: The image to be flattened and have the noise level estimated for</span>
<span class="sd">        :return: The flattened image and the noise level as a tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># flatten the image by subtracting a median blurred copy of the image.  Using a blurring kernel of 5x5.</span>
        <span class="n">flat_image</span> <span class="o">=</span> <span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">-</span> <span class="n">cv2</span><span class="o">.</span><span class="n">medianBlur</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="mi">5</span><span class="p">))</span>

        <span class="n">dark_pixels</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="s1">&#39;dark_pixels&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dark_pixels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># if there are identified dark pixels</span>
            <span class="c1"># flatten the dark pixels using a median filter</span>
            <span class="n">flat_dark</span> <span class="o">=</span> <span class="n">dark_pixels</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">-</span> \
                        <span class="n">sig</span><span class="o">.</span><span class="n">medfilt</span><span class="p">(</span><span class="n">dark_pixels</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>

            <span class="c1"># compute the standard deviation of the flattened dark pixels</span>
            <span class="n">standard_deviation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">flat_dark</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># otherwise, sample the image to determine the randomness</span>
            <span class="c1"># determine the randomness of the image by sampling at 10000 randomly selected points compared with point +5</span>
            <span class="c1"># rows and +5 cols from those points</span>

            <span class="n">im_shape</span> <span class="o">=</span> <span class="n">flat_image</span><span class="o">.</span><span class="n">shape</span>

            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">im_shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;the input image is too small...&#39;</span><span class="p">)</span>

            <span class="c1"># get the total possible number of starting locations</span>
            <span class="n">num_pix</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">im_shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">dist</span><span class="p">))</span>  <span class="c1"># type: float</span>

            <span class="c1"># sample at most 1 quarter of the available starting locations</span>
            <span class="n">num_choice</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">num_pix</span> <span class="o">//</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2000</span><span class="p">))</span>

            <span class="c1"># choose a random sample of starting locations</span>
            <span class="n">start_rows</span><span class="p">,</span> <span class="n">start_cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">num_pix</span><span class="p">)),</span> <span class="n">num_choice</span><span class="p">,</span>
                                                                       <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                                                      <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">im_shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">dist</span><span class="p">)</span>

            <span class="c1"># get the other half of the sample</span>
            <span class="n">next_rows</span> <span class="o">=</span> <span class="n">start_rows</span> <span class="o">+</span> <span class="n">dist</span>
            <span class="n">next_cols</span> <span class="o">=</span> <span class="n">start_cols</span> <span class="o">+</span> <span class="n">dist</span>

            <span class="c1"># compute the standard deviation of the difference between the star points and hte next points.  This</span>
            <span class="c1"># measures the noise in the image and sets the threshold for identifiable stars.</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">flat_image</span><span class="p">[</span><span class="n">next_rows</span><span class="p">,</span> <span class="n">next_cols</span><span class="p">]</span> <span class="o">-</span> <span class="n">flat_image</span><span class="p">[</span><span class="n">start_rows</span><span class="p">,</span> <span class="n">start_cols</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

            <span class="c1"># reject outliers from the data using MAD</span>
            <span class="n">outliers</span> <span class="o">=</span> <span class="n">get_outliers</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

            <span class="c1"># compute the standard deviation</span>
            <span class="n">standard_deviation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">outliers</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="k">return</span> <span class="n">flat_image</span><span class="p">,</span> <span class="n">standard_deviation</span>

    <span class="c1"># TODO: This would probably be better as a cython function where we can do parallel processing</span>
    <span class="k">def</span> <span class="nf">_local_flat_image_and_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">slice</span><span class="p">,</span> <span class="nb">slice</span><span class="p">]]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method flattens the image and approximates the noise over regions of the image.</span>

<span class="sd">        This is not intended by the user, instead use :meth:`flatten_image_and_get_noise_level`.</span>

<span class="sd">        :param image: The image which is to be flattened and have noise levels estimated for</span>
<span class="sd">        :return: The flattened image, a list of noise values for regions of the image, and a list of tuples of slices</span>
<span class="sd">                 describing the regions of the image</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get the shape of the image</span>
        <span class="n">img_shape</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># make sure that the image is double, also copy it to ensure that we don&#39;t mess up the original</span>
        <span class="n">flat_image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># start the region center at the kernel size</span>
        <span class="n">current_row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattening_kernel_size</span>
        <span class="n">current_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattening_kernel_size</span>

        <span class="c1"># initialize the lists for return</span>
        <span class="n">noises</span><span class="p">,</span> <span class="n">slices</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="c1"># loop rows through until we&#39;ve processed the whole image</span>
        <span class="k">while</span> <span class="n">current_row</span> <span class="o">&lt;</span> <span class="n">img_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="c1"># get the row bounds and slice</span>
            <span class="n">lower_row</span> <span class="o">=</span> <span class="n">current_row</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattening_kernel_size</span>
            <span class="n">upper_row</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">current_row</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattening_kernel_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">img_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">row_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">lower_row</span><span class="p">,</span> <span class="n">upper_row</span><span class="p">)</span>

            <span class="c1"># loop through columns until we&#39;ve processed the whole image</span>
            <span class="k">while</span> <span class="n">current_col</span> <span class="o">&lt;</span> <span class="n">img_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># get the column bounds and slice</span>
                <span class="n">lower_column</span> <span class="o">=</span> <span class="n">current_col</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattening_kernel_size</span>
                <span class="n">upper_column</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">current_col</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattening_kernel_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">img_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">column_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">lower_column</span><span class="p">,</span> <span class="n">upper_column</span><span class="p">)</span>

                <span class="c1"># get the row/column labels that we are working with</span>
                <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">row_slice</span><span class="p">,</span> <span class="n">column_slice</span><span class="p">]</span>

                <span class="c1"># get the region from the original image we are editing</span>
                <span class="n">region</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">row_slice</span><span class="p">,</span> <span class="n">column_slice</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

                <span class="c1"># compute the background of the region using least squares [1, x, y] @ [A, B, C] = bg</span>
                <span class="n">h_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">rows</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">cols</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">rows</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">background</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">h_matrix</span><span class="p">,</span> <span class="n">region</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

                <span class="c1"># flatten the region by subtracting the linear background approximation</span>
                <span class="n">flat_image</span><span class="p">[</span><span class="n">row_slice</span><span class="p">,</span> <span class="n">column_slice</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span><span class="n">h_matrix</span><span class="nd">@background</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">region</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

                <span class="c1"># store the slices</span>
                <span class="n">slices</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">row_slice</span><span class="p">,</span> <span class="n">column_slice</span><span class="p">))</span>

                <span class="c1"># update the current column we&#39;re centered on</span>
                <span class="n">current_col</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattening_kernel_size</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># update the current row/column we&#39;re centered on</span>
            <span class="n">current_row</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattening_kernel_size</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">current_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattening_kernel_size</span>

        <span class="c1"># make sure we&#39;re extra flat by flattening the flat image with a median blur.</span>
        <span class="n">flat_image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span><span class="n">flat_image</span> <span class="o">-</span> <span class="n">cv2</span><span class="o">.</span><span class="n">medianBlur</span><span class="p">(</span><span class="n">flat_image</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="mi">5</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">local_slice</span> <span class="ow">in</span> <span class="n">slices</span><span class="p">:</span>
            <span class="n">region</span> <span class="o">=</span> <span class="n">flat_image</span><span class="p">[</span><span class="n">local_slice</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">local_slice</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">selections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">region</span><span class="o">.</span><span class="n">size</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="n">region</span><span class="o">.</span><span class="n">size</span><span class="o">//</span><span class="mi">2</span><span class="p">),</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">selected_region</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">region</span><span class="p">[</span><span class="n">selections</span><span class="p">]</span>

            <span class="n">outliers</span> <span class="o">=</span> <span class="n">get_outliers</span><span class="p">(</span><span class="n">selected_region</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">outliers</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">selections</span><span class="o">.</span><span class="n">size</span><span class="o">//</span><span class="mi">2</span><span class="p">:</span>

                <span class="n">local_std</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">selected_region</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">local_std</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">selected_region</span><span class="p">[</span><span class="o">~</span><span class="n">outliers</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>

            <span class="n">noises</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">local_std</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">flat_image</span><span class="p">,</span> <span class="n">noises</span><span class="p">,</span> <span class="n">slices</span>

<div class="viewcode-block" id="ImageProcessing.flatten_image_and_get_noise_level"><a class="viewcode-back" href="../../image_processing/giant.image_processing.ImageProcessing.flatten_image_and_get_noise_level.html#giant.image_processing.ImageProcessing.flatten_image_and_get_noise_level">[docs]</a>    <span class="k">def</span> <span class="nf">flatten_image_and_get_noise_level</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
                                                                            <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                                                                                  <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">slice</span><span class="p">,</span> <span class="nb">slice</span><span class="p">]]]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is used to sample the noise level of an image, as well as return a flattened version of the image.</span>

<span class="sd">        There are 2 techniques for flattening the image.</span>

<span class="sd">        In the first, ``GLOBAL`` technique: the image is flattened by subtracting off a median filtered copy of the</span>
<span class="sd">        image from the image itself</span>

<span class="sd">        The standard deviation of the noise level in the image is then estimated by either calculating the standard</span>
<span class="sd">        deviation of flattened user defined dark pixels for the image (contained in the :attr:`.OpNavImage.dark_pixels`</span>
<span class="sd">        attribute) or by calculating the standard deviation of 2,000 randomly sampled differences between pixel pairs of</span>
<span class="sd">        the flattened image spaced 5 rows and 5 columns apart.</span>

<span class="sd">        In the second, ``LOCAL`` technique: the image is split into regions based on :attr:`flattening_kernel_size`.</span>
<span class="sd">        For each region, a linear background gradient is estimated and subtracted from the region.  The global flattened</span>
<span class="sd">        image is then flattened further by subtracting off a median filtered copy of the flattened image.</span>

<span class="sd">        The standard deviation of the noise level is then computed for each region by sampling about half of the points</span>
<span class="sd">        in the flattened region and computing the standard deviation of the flattened intensity values.  In this case</span>
<span class="sd">        3 values are returned, the flattened image, the list of noise values for each region, and a list of slices</span>
<span class="sd">        defining the regions that were processed.</span>

<span class="sd">        This method is used by :meth:`locate_subpixel_poi_in_roi` in order to make the point of interest identification</span>
<span class="sd">        easier.</span>

<span class="sd">        :param image: The image to be flattened and have the noise level estimated for</span>
<span class="sd">        :return: The flattened image and the noise level as a tuple, or the flattened image, the noise levels as a list,</span>
<span class="sd">                 and a list of slices of tuples specifying the regions of the image the noise levels apply to.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_flattening_noise_approximation</span> <span class="o">==</span> <span class="n">ImageFlatteningNoiseApprox</span><span class="o">.</span><span class="n">GLOBAL</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_global_flat_image_and_noise</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_flat_image_and_noise</span><span class="p">(</span><span class="n">image</span><span class="p">)</span></div>

<div class="viewcode-block" id="ImageProcessing.corners_to_roi"><a class="viewcode-back" href="../../image_processing/giant.image_processing.ImageProcessing.corners_to_roi.html#giant.image_processing.ImageProcessing.corners_to_roi">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">corners_to_roi</span><span class="p">(</span><span class="n">row_corners</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">column_corners</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method provides a convenient way to convert a set of corners to a region of interest that can be passed to</span>
<span class="sd">        :meth:`find_poi_in_roi` and :meth:`locate_subpixel_poi_in_roi`.</span>

<span class="sd">        This method finds the minimum and maximum row and column from row_corners and column_corners, respectively, and</span>
<span class="sd">        then makes a call to meshgrid using these bounds, reversing the output so it is row, col instead of col, row.</span>

<span class="sd">        The results from this function can be used to directly index into an image</span>

<span class="sd">        &gt;&gt;&gt; import numpy</span>
<span class="sd">        &gt;&gt;&gt; import giant.image_processing as gimp</span>
<span class="sd">        &gt;&gt;&gt; im = numpy.random.randn(500, 600)</span>
<span class="sd">        &gt;&gt;&gt; local_row_corners = [5.5, 3, 6.5, 8.9]</span>
<span class="sd">        &gt;&gt;&gt; local_column_corners = [4.3, 2.7, 3.3, 7.8]</span>
<span class="sd">        &gt;&gt;&gt; roi = im[gimp.ImageProcessing.corners_to_roi(local_row_corners, local_column_corners)]</span>
<span class="sd">        &gt;&gt;&gt; (roi == im[3:10, 2:9]).all()</span>
<span class="sd">        True</span>

<span class="sd">        :param row_corners: a list of corner row locations</span>
<span class="sd">        :param column_corners: a list of corner column locations</span>
<span class="sd">        :return: row, column subscripts into an image as a tuple of ndarrays of type int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get the bounds</span>
        <span class="n">min_row</span><span class="p">,</span> <span class="n">min_col</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">row_corners</span><span class="p">))),</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">column_corners</span><span class="p">)))</span>

        <span class="n">max_row</span><span class="p">,</span> <span class="n">max_col</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">row_corners</span><span class="p">))),</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">column_corners</span><span class="p">)))</span>

        <span class="c1"># return the subscripts</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">min_row</span><span class="p">,</span> <span class="n">max_row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">min_col</span><span class="p">,</span> <span class="n">max_col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span></div>

    <span class="c1"># noinspection SpellCheckingInspection</span>
<div class="viewcode-block" id="ImageProcessing.find_poi_in_roi"><a class="viewcode-back" href="../../image_processing/giant.image_processing.ImageProcessing.find_poi_in_roi.html#giant.image_processing.ImageProcessing.find_poi_in_roi">[docs]</a>    <span class="k">def</span> <span class="nf">find_poi_in_roi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                        <span class="n">region</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method identifies pixel level centers for all points of interest inside of some region of interest.</span>

<span class="sd">        A point of interest is defined as any grouping of *n* pixels that are above :attr:`.poi_threshold` *</span>
<span class="sd">        **standard_deviation** where :attr:`poi_min_size` &lt;= *n* &lt;= :attr:`.poi_max_size`.  The **standard_deviation**</span>
<span class="sd">        is computed using the :meth:`.flatten_image_and_get_noise_level` method.</span>
<span class="sd">        Pixels are defined to be grouped if they are neighboring:</span>

<span class="sd">        .. code-block:: none</span>

<span class="sd">            nnnnn</span>
<span class="sd">            nyyyn</span>
<span class="sd">            nyoyn</span>
<span class="sd">            nyyyn</span>
<span class="sd">            nnnnn</span>

<span class="sd">        therefore any pixels labeled ``y`` are grouped with ``o`` whereas any pixels labeled ``n`` are not.</span>

<span class="sd">        This method will ignore any blobs that contain saturated pixels if :attr:`.reject_saturation` is set to True</span>
<span class="sd">        and the ``image`` object has an attribute :attr:`~.OpNavImage.saturation` containing the saturation level for</span>
<span class="sd">        the image.</span>

<span class="sd">        If the :attr:`.return_stats` attribute is set to True, then this method will also return the connected</span>
<span class="sd">        components stats (see</span>
<span class="sd">        `OpenCV connectedComponentsWithStats &lt;https://docs.opencv.org/master/d3/dc0/group__imgproc__shape.html</span>
<span class="sd">        #ga107a78bf7cd25dec05fb4dfc5c9e765f&gt;`_</span>
<span class="sd">        for details) and the peak signal to noise ratio for each detection.</span>

<span class="sd">        :param image: The image being considered</span>
<span class="sd">        :param region: The region of the image to consider</span>
<span class="sd">        :return: the pixel level locations of the points of interest in the region of interest (row, col).  Optionally</span>
<span class="sd">                 returns the connected component stats and the peak signal to noise ratio for each detection if</span>
<span class="sd">                 :attr:`.return_stats` is set to True.</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="c1"># select the sub image we are considering</span>
        <span class="k">if</span> <span class="n">region</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">roi_start</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">region</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">region</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>

            <span class="n">big_roi</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">region</span><span class="p">)]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">roi_start</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

            <span class="n">big_roi</span> <span class="o">=</span> <span class="n">image</span>

        <span class="c1"># get the flat image and approximate noise level(s) in the image</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_flattening_noise_approximation</span> <span class="o">==</span> <span class="n">ImageFlatteningNoiseApprox</span><span class="o">.</span><span class="n">GLOBAL</span><span class="p">:</span>
            <span class="n">roi</span><span class="p">,</span> <span class="n">standard_deviation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flatten_image_and_get_noise_level</span><span class="p">(</span><span class="n">big_roi</span><span class="p">)</span>

            <span class="c1"># detect pixels of interest by thresholding the flattened image at some multiple of the noise level</span>
            <span class="n">snr</span> <span class="o">=</span> <span class="n">roi</span> <span class="o">/</span> <span class="n">standard_deviation</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if we&#39;re doing local flattening and noise estimation</span>
            <span class="n">roi</span><span class="p">,</span> <span class="n">noise_estimates</span><span class="p">,</span> <span class="n">slices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flatten_image_and_get_noise_level</span><span class="p">(</span><span class="n">big_roi</span><span class="p">)</span>

            <span class="c1"># detect pixels of interest by thresholding the flattened image at some multiple of the noise level</span>
            <span class="n">snr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">big_roi</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

            <span class="c1"># for each region, compute the &quot;snr&quot; for each detection</span>
            <span class="k">for</span> <span class="n">noise</span><span class="p">,</span> <span class="n">slices</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">noise_estimates</span><span class="p">,</span> <span class="n">slices</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">noise</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">flat_sliced</span> <span class="o">=</span> <span class="n">roi</span><span class="p">[</span><span class="n">slices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">slices</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">snr</span><span class="p">[</span><span class="n">slices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">slices</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">flat_sliced</span> <span class="o">/</span> <span class="n">noise</span>

        <span class="n">interesting_pix</span> <span class="o">=</span> <span class="n">snr</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">poi_threshold</span>

        <span class="c1"># use connected components to blob the pixels together into single objects</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">__</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">___</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">connectedComponentsWithStats</span><span class="p">(</span><span class="n">interesting_pix</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">))</span>

        <span class="n">poi_subs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">out_stats</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">out_snrs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># loop through each grouping of pixels</span>
        <span class="k">for</span> <span class="n">blob</span> <span class="ow">in</span> <span class="n">stats</span><span class="p">:</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">poi_max_size</span> <span class="o">&gt;=</span> <span class="n">blob</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poi_min_size</span><span class="p">:</span>

                <span class="c1"># if we want to reject blobs that are affected by saturation</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reject_saturation</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="s1">&#39;saturation&#39;</span><span class="p">):</span>

                    <span class="c1"># ignore blobs where a portion of the blob is saturated</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">big_roi</span><span class="p">[</span><span class="n">blob</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">blob</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">blob</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">blob</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">blob</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">blob</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">&gt;=</span> <span class="n">image</span><span class="o">.</span><span class="n">saturation</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="k">continue</span>

                <span class="c1"># get the subscript to the maximum illumination value within the current component and append it to the</span>
                <span class="c1"># return list</span>
                <span class="n">poi_roi</span> <span class="o">=</span> <span class="n">roi</span><span class="p">[</span><span class="n">blob</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">blob</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">blob</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                              <span class="n">blob</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">blob</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">blob</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>

                <span class="c1"># get the x/y location by unraveling the index (and reversing the order</span>
                <span class="n">local_subs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanargmax</span><span class="p">(</span><span class="n">poi_roi</span><span class="p">),</span> <span class="n">poi_roi</span><span class="o">.</span><span class="n">shape</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># type: np.ndarray</span>
                <span class="c1"># store the results translated back to the full image and the statistics</span>
                <span class="n">poi_subs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">local_subs</span> <span class="o">+</span> <span class="n">blob</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="n">roi_start</span><span class="p">)</span>
                <span class="n">out_stats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">blob</span><span class="p">)</span>
                <span class="n">out_snrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">snr</span><span class="p">[</span><span class="n">blob</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">blob</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">blob</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                                    <span class="n">blob</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">blob</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">blob</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_stats</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">poi_subs</span><span class="p">,</span> <span class="n">out_stats</span><span class="p">,</span> <span class="n">out_snrs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">poi_subs</span></div>

<div class="viewcode-block" id="ImageProcessing.refine_locations"><a class="viewcode-back" href="../../image_processing/giant.image_processing.ImageProcessing.refine_locations.html#giant.image_processing.ImageProcessing.refine_locations">[docs]</a>    <span class="k">def</span> <span class="nf">refine_locations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">image_subs</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                         <span class="n">stats</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">snrs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                     <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
                     <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is used to estimate the subpixel centers of blobs in an image given the pixel level location of the</span>
<span class="sd">        blobs.</span>

<span class="sd">        The method operates by performing a user specified centroiding algorithm on the image area surrounding the</span>
<span class="sd">        specified pixel level centers of the points of interest.  The centroiding algorithm should typically be a</span>
<span class="sd">        subclass of :class:`.PointSpreadFunction`, however it can be any object with a ``fit`` method that inputs  3</span>
<span class="sd">        array like parameters with the first two being pixel locations and the last being DN values and returns a</span>
<span class="sd">        object with a ``centroid`` attribute which provides the (x, y) location of the centroid.  The centroiding</span>
<span class="sd">        algorithm is specified using the :attr:`.centroiding` attribute. The size of the area considered in the</span>
<span class="sd">        centroiding algorithm can be specified in the :attr:`.centroid_size` attribute.</span>

<span class="sd">        This method returns both the subpixel centers of the points of interest as well as the illumination values of</span>
<span class="sd">        the pixels containing the subpixel centers of the points of interest.  Optionally, stats about the blobs that</span>
<span class="sd">        the centroid was fit to and then full centroid fit can be returned if ``stats`` and ``snrs`` are not</span>
<span class="sd">        None and :attr:`.save_psf` is set to True, respectively.</span>

<span class="sd">        Note that if a centroid fit is unsuccessful then no information is returned for that point.  Therefore the</span>
<span class="sd">        output arrays lengths will be less than or equal to the length of the input array.</span>

<span class="sd">        This method is designed to be used in conjunction with the :meth:`find_poi_in_roi` method; however, it can be</span>
<span class="sd">        used with any rough identification method so long as the input format is correct.</span>

<span class="sd">        :param image: The image to be processed</span>
<span class="sd">        :param image_subs: The pixel level locations of interest to be refined</span>
<span class="sd">        :param stats: An optional input of stats about the blobs.  This is not used in this function but is passed</span>
<span class="sd">                      through, removing any blobs where a centroid was not found.</span>
<span class="sd">        :param snrs: An optional input of signal to noise ratios from the blobs.  This is not used in this function but</span>
<span class="sd">                     is passed through, removing any blobs where a centroid was not found.</span>
<span class="sd">        :return: The subpixel centers of the points of interest as well as the illumination values (col, row)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># initialize lists for output</span>
        <span class="n">star_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">star_illums</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">star_psfs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">out_stats</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">out_snrs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># loop through the pixel level points of interest</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">center</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">image_subs</span><span class="p">):</span>

            <span class="n">column_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid_size</span><span class="p">,</span>
                                     <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">row_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid_size</span><span class="p">,</span>
                                  <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">col_check</span> <span class="o">=</span> <span class="p">(</span><span class="n">column_array</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">column_array</span> <span class="o">&lt;=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">row_check</span> <span class="o">=</span> <span class="p">(</span><span class="n">row_array</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">row_array</span> <span class="o">&lt;=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># valid_check = col_check &amp; row_check</span>
            <span class="n">cols</span><span class="p">,</span> <span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">column_array</span><span class="p">[</span><span class="n">col_check</span><span class="p">],</span>
                                     <span class="n">row_array</span><span class="p">[</span><span class="n">row_check</span><span class="p">])</span>

            <span class="c1"># if col_check and row_check:</span>
            <span class="k">if</span> <span class="n">cols</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">centroid_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">:</span>

                <span class="n">sampled_image</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

                <span class="c1"># perform the fit</span>
                <span class="c1"># if self.save_psf:</span>
                <span class="c1">#     [x0, y0], psf, rss = self.centroiding(cols,</span>
                <span class="c1">#                                           rows,</span>
                <span class="c1">#                                           sampled_image,</span>
                <span class="c1">#                                           save_psf=self.save_psf)</span>
                <span class="c1"># else:</span>
                <span class="c1">#     x0, y0 = self.centroiding(cols,</span>
                <span class="c1">#                               rows,</span>
                <span class="c1">#                               sampled_image,</span>
                <span class="c1">#                               save_psf=self.save_psf)</span>

                <span class="n">psf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroiding</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">sampled_image</span><span class="p">)</span>

                <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">=</span> <span class="n">psf</span><span class="o">.</span><span class="n">centroid</span>

                <span class="c1"># if we&#39;re outside the image or the fit failed skip this one</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">x0</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">y0</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">((</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">))</span><span class="o">.</span><span class="n">any</span><span class="p">()):</span>
                    <span class="k">continue</span>

                <span class="c1"># check to be sure we haven&#39;t deviated too far from the original peak of interest (avoid poorly</span>
                <span class="c1"># conditioned systems)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">center</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="n">star_points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">])</span>
                    <span class="n">star_illums</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">center</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])])</span>
                    <span class="n">star_psfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">psf</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">stats</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">out_stats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
                        <span class="n">out_snrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">snrs</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>

        <span class="c1"># determine which form the output should take</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_psf</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">stats</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">star_points</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">star_illums</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">star_psfs</span><span class="p">),</span> <span class="n">out_stats</span><span class="p">,</span> <span class="n">out_snrs</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">star_points</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">star_illums</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">star_psfs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">stats</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">star_points</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">star_illums</span><span class="p">),</span> <span class="n">out_stats</span><span class="p">,</span> <span class="n">out_snrs</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">star_points</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">star_illums</span><span class="p">)</span></div>

<div class="viewcode-block" id="ImageProcessing.locate_subpixel_poi_in_roi"><a class="viewcode-back" href="../../image_processing/giant.image_processing.ImageProcessing.locate_subpixel_poi_in_roi.html#giant.image_processing.ImageProcessing.locate_subpixel_poi_in_roi">[docs]</a>    <span class="k">def</span> <span class="nf">locate_subpixel_poi_in_roi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                   <span class="n">region</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                     <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
                     <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]:</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method identifies the subpixel locations of points of interest in an image.</span>

<span class="sd">        This method is simply a convenient way of combining :meth:`find_poi_in_roi` and :meth:`refine_locations` and</span>
<span class="sd">        calls these two methods directly, feeding the results of the first into the second.</span>

<span class="sd">        Note that if the :attr:`.denoise_flag` is set to true then this method will first pass the image through the</span>
<span class="sd">        :meth:`.denoise_image` method.</span>

<span class="sd">        :param image: The image to be processed</span>
<span class="sd">        :param region: The region of interest to consider as 2 numpy arrays of indices into the images or None</span>
<span class="sd">        :return: The subpixel centers of the points of interest as well as the illumination values, plus</span>
<span class="sd">                 optionally details about the point spread function fit if</span>
<span class="sd">                 :attr:`.save_psf` is set to True and the blob statistics and SNR values for each blob if</span>
<span class="sd">                 :attr:`.return_stats` is set to true</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># denoise the image if requested</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">denoise_flag</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">denoise_image</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
            <span class="n">flip_denoise_flag</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">denoise_flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flip_denoise_flag</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># first get the rough locations of points of interest</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_stats</span><span class="p">:</span>
            <span class="n">image_inds</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">snrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_poi_in_roi</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="n">region</span><span class="p">)</span>

            <span class="c1"># refine the rough locations and return the results</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">refine_locations</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">image_inds</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">snrs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">flip_denoise_flag</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">denoise_flag</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="n">res</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">image_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_poi_in_roi</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="n">region</span><span class="p">)</span>

            <span class="c1"># refine the rough locations and return the results</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">refine_locations</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">image_inds</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">flip_denoise_flag</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">denoise_flag</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="ImageProcessing.denoise_image"><a class="viewcode-back" href="../../image_processing/giant.image_processing.ImageProcessing.denoise_image.html#giant.image_processing.ImageProcessing.denoise_image">[docs]</a>    <span class="k">def</span> <span class="nf">denoise_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is used to optionally denoise the image before a number of the other techniques contained in this</span>
<span class="sd">        class.</span>

<span class="sd">        The method applies the denoising technique specified in the :attr:`.image_denoising` attribute.  The returned</span>
<span class="sd">        2D numpy array is the image after applying the denoising technique.</span>

<span class="sd">        :param image: The image to be denoised</span>
<span class="sd">        :return: The denoised image</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_denoising</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">denoising_args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">denoising_kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="ImageProcessing.correlate"><a class="viewcode-back" href="../../image_processing/giant.image_processing.ImageProcessing.correlate.html#giant.image_processing.ImageProcessing.correlate">[docs]</a>    <span class="k">def</span> <span class="nf">correlate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">template</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method generates a cross correlation surface between template and image.</span>

<span class="sd">        The method applies the correlation function specified in the :attr:`.correlator` attribute.  The returned</span>
<span class="sd">        2D array in general will be the same size as the image (though this is controlled by the</span>
<span class="sd">        :attr:`.correlator` attribute) where each element will represent the correlation score between the template and</span>
<span class="sd">        the image when the center of the template is aligned with the corresponding element in the image.  Therefore,</span>
<span class="sd">        to get the location of a template in an image one would do</span>

<span class="sd">            &gt;&gt;&gt; from giant.image_processing import ImageProcessing</span>
<span class="sd">            &gt;&gt;&gt; import numpy</span>
<span class="sd">            &gt;&gt;&gt; ip = ImageProcessing()</span>
<span class="sd">            &gt;&gt;&gt; local_image = numpy.random.randn(200, 200)</span>
<span class="sd">            &gt;&gt;&gt; local_template = local_image[30:60, 45:60]</span>
<span class="sd">            &gt;&gt;&gt; surf = ip.correlate(local_image, local_template)</span>
<span class="sd">            &gt;&gt;&gt; temp_middle = numpy.floor(numpy.array(local_template.shape)/2)</span>
<span class="sd">            &gt;&gt;&gt; template_point = numpy.array([0, 0])  # upper left corner</span>
<span class="sd">            &gt;&gt;&gt; template_point - temp_middle + numpy.unravel_index(surf.argmax(), surf.shape)</span>
<span class="sd">            array([30., 45.])</span>

<span class="sd">        :param image: The image to be matched against</span>
<span class="sd">        :param template: The template to find in the image</span>
<span class="sd">        :return: The normalized correlation surface</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">correlator</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">correlator_kwargs</span><span class="p">)</span></div>

    <span class="c1"># TODO: unit tests for all of the following</span>
<div class="viewcode-block" id="ImageProcessing.identify_subpixel_limbs"><a class="viewcode-back" href="../../image_processing/giant.image_processing.ImageProcessing.identify_subpixel_limbs.html#giant.image_processing.ImageProcessing.identify_subpixel_limbs">[docs]</a>    <span class="k">def</span> <span class="nf">identify_subpixel_limbs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">illum_dir</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">num_objs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method identifies illuminated limbs in an image to sub-pixel accuracy.</span>

<span class="sd">        The input to this method is the image to have the limbs extracted from, the illumination direction in the image,</span>
<span class="sd">        and the number of objects that limbs are to be extracted from in the image.  The output is a list of arrays</span>
<span class="sd">        or subpixel limb points with each element of the list being a 2d array of the limb points for the</span>
<span class="sd">        i\ :sup:`th` object. The limb arrays are 2xn where n is the number of limb points and the first row</span>
<span class="sd">        corresponds to the x locations of the limb points in the image and the second row corresponds to the y</span>
<span class="sd">        locations of the limb points in the image.</span>

<span class="sd">        This method works by first thresholding the image to extract the foreground objects from the background using</span>
<span class="sd">        the :func:`otsu` function, and then identifying complete objects using connected components.  For each connected</span>
<span class="sd">        object up to `num_objs` objects, the limb points are extracted by scanning along the `illum_dir` vector to the</span>
<span class="sd">        first edge pixel encountered.  Then the edge level pixels are refined to subpixel accuracy  using one of the</span>
<span class="sd">        subpixel edge detection routines.</span>

<span class="sd">        :param image: The image to have the limbs extracted from</span>
<span class="sd">        :param illum_dir:  The direction of the incoming sunlight in the image</span>
<span class="sd">        :param num_objs: The number of objects to extract limbs from</span>
<span class="sd">        :return: A list of 2D arrays containing the xy subpixel limb points for each object in the image</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># denoise the image if requested</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">denoise_flag</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">denoise_image</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">denoise_flag</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">flip_denoise_flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flip_denoise_flag</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># convert the image to uint8 if it isn&#39;t already</span>
        <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">:</span>
            <span class="c1"># noinspection PyArgumentList</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">-</span> <span class="n">image</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">image</span> <span class="o">*=</span> <span class="mi">255</span> <span class="o">/</span> <span class="n">image</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

        <span class="c1"># first, try to split the image into 4 bins with Otsu thresholding</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">otsu</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

        <span class="c1"># get the number of pixels in each threshold level</span>
        <span class="n">num_pix</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
        
        <span class="c1"># check for outliers</span>
        <span class="n">outliers</span> <span class="o">=</span> <span class="n">get_outliers</span><span class="p">(</span><span class="n">num_pix</span><span class="p">,</span> <span class="n">sigma_cutoff</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

        <span class="c1"># handle the outliers</span>
        <span class="k">if</span> <span class="n">outliers</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="c1"># check if levels 2 and 3 are also noise</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">num_pix</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">&gt;</span> <span class="n">num_pix</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">outliers</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">num_pix</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">&gt;</span> <span class="n">num_pix</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">outliers</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">outliers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># create a binary image where only the non-outlier pixels are turned on</span>
        <span class="n">connected_mat</span> <span class="o">=</span> <span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)[</span><span class="o">~</span><span class="n">outliers</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># do connected components</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">labs2</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">centroids</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">connectedComponentsWithStats</span><span class="p">(</span><span class="n">connected_mat</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">))</span>

        <span class="c1"># sort based on area size</span>
        <span class="n">sorted_labs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">stats</span><span class="p">[:,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_AREA</span><span class="p">])</span>

        <span class="n">limbs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">blob</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sorted_labs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="c1"># if we have considered the maximum number of objects already</span>
            <span class="k">if</span> <span class="n">ind</span> <span class="o">==</span> <span class="n">num_objs</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c1"># throw out blobs which are smaller than 10 pixels</span>
            <span class="k">if</span> <span class="n">stats</span><span class="p">[</span><span class="n">blob</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_AREA</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># extract the area around the blob from the image</span>
            <span class="n">extra_bounds</span> <span class="o">=</span> <span class="mi">10</span>
            <span class="n">top_left</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="n">blob</span><span class="p">,</span> <span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_TOP</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_LEFT</span><span class="p">]]</span> <span class="o">-</span> <span class="n">extra_bounds</span>
            <span class="n">bottom_right</span> <span class="o">=</span> <span class="n">top_left</span> <span class="o">+</span> <span class="n">stats</span><span class="p">[</span><span class="n">blob</span><span class="p">,</span> <span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_HEIGHT</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_WIDTH</span><span class="p">]]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">extra_bounds</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="n">top_left</span><span class="p">[</span><span class="n">top_left</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">bottom_right</span><span class="p">[</span><span class="n">bottom_right</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">sub_image</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">top_left</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">bottom_right</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">top_left</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">bottom_right</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

            <span class="c1"># determine the centroid of the current blob</span>
            <span class="n">centroid</span> <span class="o">=</span> <span class="n">centroids</span><span class="p">[</span><span class="n">blob</span><span class="p">]</span> <span class="o">-</span> <span class="n">top_left</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># check to be sure we have an actual object</span>
            <span class="k">if</span> <span class="n">sub_image</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># identify the subpixel limbs and store them</span>
            <span class="n">limbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_locate_limbs</span><span class="p">(</span><span class="n">sub_image</span><span class="p">,</span> <span class="n">centroid</span><span class="p">,</span> <span class="n">illum_dir</span><span class="p">)</span> <span class="o">+</span> <span class="n">top_left</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">flip_denoise_flag</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">denoise_flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">limbs</span></div>

<div class="viewcode-block" id="ImageProcessing.identify_pixel_edges"><a class="viewcode-back" href="../../image_processing/giant.image_processing.ImageProcessing.identify_pixel_edges.html#giant.image_processing.ImageProcessing.identify_pixel_edges">[docs]</a>    <span class="k">def</span> <span class="nf">identify_pixel_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">split_horizontal_vertical</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                             <span class="n">return_gradient</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                                                     <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                                                                     <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                                                           <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                                                                     <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                                                           <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method determines pixel level edges in an image by thresholding the image gradients.</span>

<span class="sd">        The image gradients are computed by convolving horizontal and vertical Sobel masks with the image to give the</span>
<span class="sd">        horizontal and vertical gradients.  The gradient images are then thresholded using :func:`otsu` to determine</span>
<span class="sd">        the strongest gradients in the image.  The strong gradients are then searched for local maxima, which become the</span>
<span class="sd">        pixel level edges of the image.</span>

<span class="sd">        This function inputs the image and outputs a binary image with true values corresponding to the edge locations</span>
<span class="sd">        in the image.  Optionally, if the ``split_horizontal_vertical`` argument is set to True, the 2 binary images are</span>
<span class="sd">        returned, the first with true values in locations containing horizontal edges, and the second with true values</span>
<span class="sd">        in locations containing vertical edges.  Finally, if the `return_gradient` argument is set to true, then the</span>
<span class="sd">        horizontal, vertical, and magnitude gradient arrays are returned as well.</span>

<span class="sd">        :param image: The image to extract the edges from</span>
<span class="sd">        :param split_horizontal_vertical: A flag specifying whether to return the vertical and horizontal edges</span>
<span class="sd">                                          separately or combined</span>
<span class="sd">        :param return_gradient: A flag specifying whether to return the gradient arrays or not</span>
<span class="sd">        :return: the pixel level edges (either as a single boolean array or a split boolean array) and optionally the</span>
<span class="sd">                 horizontal, vertical, and magnitude gradient arrays.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># blur the image</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">denoise_flag</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">denoise_image</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">denoise_flag</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">flip_denoise_flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flip_denoise_flag</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># compute the image gradients</span>
        <span class="n">horizontal_gradient</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">fftconvolve</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">HORIZONTAL_KERNEL</span><span class="p">,</span> <span class="s1">&#39;same&#39;</span><span class="p">)</span>  <span class="c1"># gradient from left to right</span>
        <span class="n">vertical_gradient</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">fftconvolve</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">VERTICAL_KERNEL</span><span class="p">,</span> <span class="s1">&#39;same&#39;</span><span class="p">)</span>  <span class="c1"># gradient from top to bottom</span>
        <span class="n">normalized_gradient</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">horizontal_gradient</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">vertical_gradient</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># get the absolute of the gradients</span>
        <span class="n">abs_horizontal_gradient</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">horizontal_gradient</span><span class="p">)</span>
        <span class="n">abs_vertical_gradient</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">vertical_gradient</span><span class="p">)</span>

        <span class="c1"># fix the edges since they can be wonky</span>
        <span class="n">normalized_gradient</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">normalized_gradient</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">normalized_gradient</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">normalized_gradient</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># threshold the edges using Otsu&#39;s method</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">normalized_gradient_binned</span> <span class="o">=</span> <span class="n">otsu</span><span class="p">(</span><span class="n">normalized_gradient</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

        <span class="c1"># get the number of pixels in each threshold level</span>
        <span class="n">num_pix</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">normalized_gradient_binned</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
        
        <span class="c1"># check for outliers</span>
        <span class="n">outliers</span> <span class="o">=</span> <span class="n">get_outliers</span><span class="p">(</span><span class="n">num_pix</span><span class="p">,</span> <span class="n">sigma_cutoff</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">outliers</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">binned_gradient</span> <span class="o">=</span> <span class="n">normalized_gradient_binned</span> <span class="o">&gt;</span> <span class="mf">1.5</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">binned_gradient</span> <span class="o">=</span> <span class="n">otsu</span><span class="p">(</span><span class="n">normalized_gradient</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># do connected components to throw out individual points</span>
        <span class="n">number_of_labels</span><span class="p">,</span> <span class="n">labs</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">connectedComponentsWithStats</span><span class="p">(</span><span class="n">binned_gradient</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">blob</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_labels</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">stats</span><span class="p">[</span><span class="n">blob</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_AREA</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">labs</span><span class="p">[</span><span class="n">labs</span> <span class="o">==</span> <span class="n">blob</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">binned_gradient</span> <span class="o">=</span> <span class="n">labs</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="c1"># determine the horizontal edges</span>
        <span class="n">horiz_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># horizontal edges correspond to high vertical gradients</span>
        <span class="n">horiz_mask</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">binned_gradient</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span>  <span class="c1"># check to see that the overall gradient is large</span>
                                  <span class="c1"># check that this is a horizontal edge by checking that the vertical_gradient is</span>
                                  <span class="c1"># larger</span>
                                  <span class="p">(</span><span class="n">abs_vertical_gradient</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">abs_horizontal_gradient</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">&amp;</span>
                                  <span class="c1"># check that this is a local maxima horizontally</span>
                                  <span class="p">(</span><span class="n">abs_vertical_gradient</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">abs_vertical_gradient</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">&amp;</span>
                                  <span class="p">(</span><span class="n">abs_vertical_gradient</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">abs_vertical_gradient</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span>

        <span class="c1"># determine the vertical edges</span>
        <span class="n">vert_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># vertical edges correspond to high horizontal gradients</span>
        <span class="n">vert_mask</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">binned_gradient</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span> <span class="o">&amp;</span>  <span class="c1"># check to see that the overall gradient is large</span>
                                 <span class="c1"># check that this is a vertical edge by checking that the horizontal_gradient is larger</span>
                                 <span class="p">(</span><span class="n">abs_horizontal_gradient</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">abs_vertical_gradient</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">])</span> <span class="o">&amp;</span>
                                 <span class="c1"># check that this is a local maxima vertically</span>
                                 <span class="p">(</span><span class="n">abs_horizontal_gradient</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">abs_horizontal_gradient</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span><span class="o">-</span><span class="mi">6</span><span class="p">])</span> <span class="o">&amp;</span>
                                 <span class="p">(</span><span class="n">abs_horizontal_gradient</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">abs_horizontal_gradient</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">:</span><span class="o">-</span><span class="mi">4</span><span class="p">]))</span>

        <span class="c1"># perpendicular edges correspond to high rss gradients</span>
        <span class="n">perpendicular_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="n">perpendicular_mask</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">binned_gradient</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span> <span class="o">&amp;</span>  <span class="c1"># check to see if the overall gradient is large</span>
                <span class="p">(</span><span class="n">normalized_gradient</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">normalized_gradient</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span><span class="o">-</span><span class="mi">6</span><span class="p">])</span> <span class="o">&amp;</span>  <span class="c1"># horizontal local maxima</span>
                <span class="p">(</span><span class="n">normalized_gradient</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">normalized_gradient</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">:</span><span class="o">-</span><span class="mi">4</span><span class="p">])</span> <span class="o">&amp;</span>
                <span class="p">(</span><span class="n">normalized_gradient</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">normalized_gradient</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">])</span> <span class="o">&amp;</span>  <span class="c1"># vertical local maxima</span>
                <span class="p">(</span><span class="n">normalized_gradient</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">normalized_gradient</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">]))</span>

        <span class="n">vert_mask</span> <span class="o">|=</span> <span class="n">perpendicular_mask</span>

        <span class="c1"># determine what to return</span>

        <span class="k">if</span> <span class="n">flip_denoise_flag</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">denoise_flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">split_horizontal_vertical</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">return_gradient</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">horiz_mask</span><span class="p">,</span> <span class="n">vert_mask</span><span class="p">,</span> <span class="n">horizontal_gradient</span><span class="p">,</span> <span class="n">vertical_gradient</span><span class="p">,</span> <span class="n">normalized_gradient</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">horiz_mask</span><span class="p">,</span> <span class="n">vert_mask</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">return_gradient</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">horiz_mask</span> <span class="o">|</span> <span class="n">vert_mask</span><span class="p">,</span> <span class="n">horizontal_gradient</span><span class="p">,</span> <span class="n">vertical_gradient</span><span class="p">,</span> <span class="n">normalized_gradient</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">horiz_mask</span> <span class="o">|</span> <span class="n">vert_mask</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_split_pos_neg_edges</span><span class="p">(</span><span class="n">horizontal_gradient</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">vertical_gradient</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                             <span class="n">edges</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method splits diagonal edges into positive/negative bins</span>

<span class="sd">        :param horizontal_gradient: The horizontal gradient array</span>
<span class="sd">        :param vertical_gradient: The vertical gradient array</span>
<span class="sd">        :param edges: The edge array containing the pixel location of the edges as [x, y]</span>
<span class="sd">        :return: The edges split into positive and negative groupings</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check with edges are positive edges</span>
        <span class="n">positive_check</span> <span class="o">=</span> <span class="n">horizontal_gradient</span><span class="p">[</span><span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">vertical_gradient</span><span class="p">[</span><span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="c1"># split and return the binned edges</span>
        <span class="k">return</span> <span class="n">edges</span><span class="p">[:,</span> <span class="n">positive_check</span><span class="p">],</span> <span class="n">edges</span><span class="p">[:,</span> <span class="o">~</span><span class="n">positive_check</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_compute_pae_delta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sum_a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sum_b</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sum_c</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                           <span class="n">int_a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">int_b</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method computes the subpixel location of an edge using the pae method within a pixel.</span>

<span class="sd">        This method is vectorized so multiple edges can be refined at the same time.</span>

<span class="sd">        Essentially this method either fits a line or a parabola to the edge based off of the intensity data surrounding</span>
<span class="sd">        the edge.  if :attr:`pae_order` is set to 1, then a linear fit is made.  If it is set to 2 then a parabola fit</span>
<span class="sd">        is made.</span>

<span class="sd">        :param sum_a: The sum of the first row or first column (depending on whether this is a horizontal or vertical</span>
<span class="sd">                     edge)</span>
<span class="sd">        :param sum_b: The sum of the middle row or column (depending on whether this is a horizontal or vertical edge)</span>
<span class="sd">        :param sum_c: The sum of the final row or column (depending on whether this is a horizontal or vertical edge)</span>
<span class="sd">        :param int_a: The average intensity to the positive side of the edge</span>
<span class="sd">        :param int_b: The average intensity to the negative side of the edge</span>
<span class="sd">        :return: The offset in the local pixel for the subpixel edge locations.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">a_coef</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pae_order</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">sum_a</span> <span class="o">+</span> <span class="n">sum_c</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sum_b</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">int_b</span> <span class="o">-</span> <span class="n">int_a</span><span class="p">))</span>
        <span class="n">c_coef</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sum_b</span> <span class="o">-</span> <span class="mi">7</span> <span class="o">*</span> <span class="p">(</span><span class="n">int_b</span> <span class="o">+</span> <span class="n">int_a</span><span class="p">))</span> <span class="o">/</span>
                  <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">int_b</span> <span class="o">-</span> <span class="n">int_a</span><span class="p">))</span> <span class="o">-</span>
                  <span class="n">a_coef</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">24</span> <span class="o">*</span> <span class="n">PAE_A01</span> <span class="o">+</span> <span class="mi">48</span> <span class="o">*</span> <span class="n">PAE_A11</span><span class="p">)</span> <span class="o">/</span> <span class="mi">12</span><span class="p">)</span>

        <span class="n">c_coef</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">c_coef</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">c_coef</span>

<div class="viewcode-block" id="ImageProcessing.pae_edges"><a class="viewcode-back" href="../../image_processing/giant.image_processing.ImageProcessing.pae_edges.html#giant.image_processing.ImageProcessing.pae_edges">[docs]</a>    <span class="k">def</span> <span class="nf">pae_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method locates edges in an image with subpixel accuracy.</span>

<span class="sd">        Edges are defined as places in the image where the illumination values abruptly transition from light to dark</span>
<span class="sd">        or dark to light.  The algorithms in this method are based off of the Partial Area Effect as discussed in</span>
<span class="sd">        http://www.sciencedirect.com/science/article/pii/S0262885612001850</span>

<span class="sd">        First edges are detected at the pixel level by using a gradient based edge detection method.  The edges are then</span>
<span class="sd">        refined to subpixel accuracy using the PAE.  Tests have shown that the PAE achieves accuracy better than 0.1</span>
<span class="sd">        pixels in most cases.</span>

<span class="sd">        There are two tuning parameters for the PAE method.  One is the :attr:`.pae_threshold`.  This is the threshold</span>
<span class="sd">        for detecting pixel level edges (ie the absolute value of the gradient of the image must be above this threshold</span>
<span class="sd">        for an edge to be identified).  The second tuning</span>
<span class="sd">        parameter is the :attr:`.pae_order`.  The :attr:`.pae_order` specifies whether a linear or quadratic fit is used</span>
<span class="sd">        to refine the edge location.  It should have a value of 1 or 2.</span>

<span class="sd">        Note that this method returns all edges in an image.  If you are looking for just limbs, check out the</span>
<span class="sd">        :meth:`identify_subpixel_limbs` method instead</span>

<span class="sd">        :param image: The image to be processed</span>
<span class="sd">        :return: a 2xn numpy array of the subpixel edge locations (cols [x], rows [y])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># optionally denoise the image before estimating the subpixel centers (recommended)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">denoise_flag</span><span class="p">:</span>
            <span class="n">image_smoothed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">denoise_image</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">denoise_flag</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">flip_denoise_flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flip_denoise_flag</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">image_smoothed</span> <span class="o">=</span> <span class="n">image</span>

        <span class="c1"># everything is implemented in refine_edges_pae so just do that...</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">refine_edges_pae</span><span class="p">(</span><span class="n">image_smoothed</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">flip_denoise_flag</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">denoise_flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="ImageProcessing.refine_edges_pae"><a class="viewcode-back" href="../../image_processing/giant.image_processing.ImageProcessing.refine_edges_pae.html#giant.image_processing.ImageProcessing.refine_edges_pae">[docs]</a>    <span class="k">def</span> <span class="nf">refine_edges_pae</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                         <span class="n">pixel_edges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">horizontal_mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">vertical_mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">horizontal_gradient</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">vertical_gradient</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method refines pixel level edges to subpixel level using the PAE method.</span>

<span class="sd">        The PAE method is explained at https://www.sciencedirect.com/science/article/pii/S0262885612001850 and is not</span>
<span class="sd">        discussed in detail here.  In brief, a linear or parabolic function is fit to the edge data based off of the</span>
<span class="sd">        intensity data in the pixels surrounding the edge locations.</span>

<span class="sd">        To use this function, you can either input just an image, in which case the pixel level edges will be</span>
<span class="sd">        detected using the :meth:`identify_pixel_edges` method, or you can also specify the pixel level edges, the</span>
<span class="sd">        mask specifying which edges are horizontal, the mask specifying which edges are vertical, and the horizontal and</span>
<span class="sd">        vertical gradient arrays for the image.  The edges are refined and returned as a 2D array with the x</span>
<span class="sd">        locations in the first row and the y locations in the second row.</span>

<span class="sd">        :param image:  The image the edges are being extracted from</span>
<span class="sd">        :param pixel_edges: The pixel level edges from the image as a 2D array with x in the first row and y in the</span>
<span class="sd">                            second row</span>
<span class="sd">        :param horizontal_mask: A binary mask which selects the horizontal edges from the `pixel_edges` parameter</span>
<span class="sd">        :param vertical_mask: A binary mask which selects the vertical edges from the `pixel_edges` parameter</span>
<span class="sd">        :param horizontal_gradient: The horizontal image gradient</span>
<span class="sd">        :param vertical_gradient: The vertical image gradient</span>
<span class="sd">        :return: The subpixel edge locations as a 2d array with the x values in the first row and the y values in the</span>
<span class="sd">                 second row (col [x], row [y])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if the pixel level edges have not been supplied then calculate them</span>
        <span class="k">if</span> <span class="n">pixel_edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="p">(</span><span class="n">horizontal_mask</span><span class="p">,</span> <span class="n">vertical_mask</span><span class="p">,</span>
             <span class="n">horizontal_gradient</span><span class="p">,</span> <span class="n">vertical_gradient</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">identify_pixel_edges</span><span class="p">(</span><span class="n">image</span><span class="p">,</span>
                                                                                    <span class="n">split_horizontal_vertical</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                                    <span class="n">return_gradient</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">horizontal_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">horizontal_mask</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">vertical_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">vertical_mask</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">horizontal_edges</span> <span class="o">=</span> <span class="n">pixel_edges</span><span class="p">[:,</span> <span class="n">horizontal_mask</span><span class="p">[</span><span class="n">pixel_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pixel_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
            <span class="n">vertical_edges</span> <span class="o">=</span> <span class="n">pixel_edges</span><span class="p">[:,</span> <span class="n">vertical_mask</span><span class="p">[</span><span class="n">pixel_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pixel_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">denoise_flag</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">denoise_image</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">denoise_flag</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">flip_denoise_flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flip_denoise_flag</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># group the pixel level edges into edges with positive and negative slopes</span>
        <span class="n">horiz_pos_edges</span><span class="p">,</span> <span class="n">horiz_neg_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_pos_neg_edges</span><span class="p">(</span><span class="n">horizontal_gradient</span><span class="p">,</span> <span class="n">vertical_gradient</span><span class="p">,</span>
                                                                     <span class="n">horizontal_edges</span><span class="p">)</span>
        <span class="n">vert_pos_edges</span><span class="p">,</span> <span class="n">vert_neg_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_pos_neg_edges</span><span class="p">(</span><span class="n">horizontal_gradient</span><span class="p">,</span> <span class="n">vertical_gradient</span><span class="p">,</span>
                                                                   <span class="n">vertical_edges</span><span class="p">)</span>

        <span class="c1"># process the horizontal edges</span>

        <span class="c1"># precompute the indices</span>
        <span class="n">prm4</span> <span class="o">=</span> <span class="n">horiz_pos_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">4</span>
        <span class="n">prm3</span> <span class="o">=</span> <span class="n">horiz_pos_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span>
        <span class="n">prm2</span> <span class="o">=</span> <span class="n">horiz_pos_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span>
        <span class="n">prm1</span> <span class="o">=</span> <span class="n">horiz_pos_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">pr</span> <span class="o">=</span> <span class="n">horiz_pos_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">prp1</span> <span class="o">=</span> <span class="n">horiz_pos_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">prp2</span> <span class="o">=</span> <span class="n">horiz_pos_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span>
        <span class="n">prp3</span> <span class="o">=</span> <span class="n">horiz_pos_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span>
        <span class="n">prp4</span> <span class="o">=</span> <span class="n">horiz_pos_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span>
        <span class="n">pcm1</span> <span class="o">=</span> <span class="n">horiz_pos_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">pc</span> <span class="o">=</span> <span class="n">horiz_pos_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pcp1</span> <span class="o">=</span> <span class="n">horiz_pos_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">nrm4</span> <span class="o">=</span> <span class="n">horiz_neg_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">4</span>
        <span class="n">nrm3</span> <span class="o">=</span> <span class="n">horiz_neg_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span>
        <span class="n">nrm2</span> <span class="o">=</span> <span class="n">horiz_neg_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span>
        <span class="n">nrm1</span> <span class="o">=</span> <span class="n">horiz_neg_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">nr</span> <span class="o">=</span> <span class="n">horiz_neg_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nrp1</span> <span class="o">=</span> <span class="n">horiz_neg_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">nrp2</span> <span class="o">=</span> <span class="n">horiz_neg_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span>
        <span class="n">nrp3</span> <span class="o">=</span> <span class="n">horiz_neg_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span>
        <span class="n">nrp4</span> <span class="o">=</span> <span class="n">horiz_neg_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span>
        <span class="n">ncm1</span> <span class="o">=</span> <span class="n">horiz_neg_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="n">horiz_neg_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ncp1</span> <span class="o">=</span> <span class="n">horiz_neg_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># calculate the average intensity on either side of the edge</span>
        <span class="c1"># above the edge for positive sloped edges</span>
        <span class="n">int_top_pos</span> <span class="o">=</span> <span class="n">image</span><span class="p">[[</span><span class="n">prm3</span><span class="p">,</span> <span class="n">prm4</span><span class="p">,</span> <span class="n">prm4</span><span class="p">],</span> <span class="p">[</span><span class="n">pcm1</span><span class="p">,</span> <span class="n">pcm1</span><span class="p">,</span> <span class="n">pc</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>

        <span class="c1"># below the edge for positive sloped edges</span>
        <span class="n">int_bot_pos</span> <span class="o">=</span> <span class="n">image</span><span class="p">[[</span><span class="n">prp3</span><span class="p">,</span> <span class="n">prp4</span><span class="p">,</span> <span class="n">prp4</span><span class="p">],</span> <span class="p">[</span><span class="n">pcp1</span><span class="p">,</span> <span class="n">pcp1</span><span class="p">,</span> <span class="n">pc</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>

        <span class="c1"># above the edge for negative sloped edges</span>
        <span class="n">int_top_neg</span> <span class="o">=</span> <span class="n">image</span><span class="p">[[</span><span class="n">nrm3</span><span class="p">,</span> <span class="n">nrm4</span><span class="p">,</span> <span class="n">nrm4</span><span class="p">],</span> <span class="p">[</span><span class="n">ncp1</span><span class="p">,</span> <span class="n">ncp1</span><span class="p">,</span> <span class="n">nc</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>

        <span class="c1"># below the edge for negative sloped edges</span>
        <span class="n">int_bot_neg</span> <span class="o">=</span> <span class="n">image</span><span class="p">[[</span><span class="n">nrp3</span><span class="p">,</span> <span class="n">nrp4</span><span class="p">,</span> <span class="n">nrp4</span><span class="p">],</span> <span class="p">[</span><span class="n">ncm1</span><span class="p">,</span> <span class="n">ncm1</span><span class="p">,</span> <span class="n">nc</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>

        <span class="c1"># sum the columns of intensity for the positive slop edges</span>
        <span class="n">sum_left_pos_slope</span> <span class="o">=</span> <span class="n">image</span><span class="p">[[</span><span class="n">prm2</span><span class="p">,</span> <span class="n">prm1</span><span class="p">,</span> <span class="n">pr</span><span class="p">,</span> <span class="n">prp1</span><span class="p">,</span> <span class="n">prp2</span><span class="p">,</span> <span class="n">prp3</span><span class="p">,</span> <span class="n">prp4</span><span class="p">],</span>
                                   <span class="p">[</span><span class="n">pcm1</span><span class="p">,</span> <span class="n">pcm1</span><span class="p">,</span> <span class="n">pcm1</span><span class="p">,</span> <span class="n">pcm1</span><span class="p">,</span> <span class="n">pcm1</span><span class="p">,</span> <span class="n">pcm1</span><span class="p">,</span> <span class="n">pcm1</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sum_mid_pos_slope</span> <span class="o">=</span> <span class="n">image</span><span class="p">[[</span><span class="n">prm3</span><span class="p">,</span> <span class="n">prm2</span><span class="p">,</span> <span class="n">prm1</span><span class="p">,</span> <span class="n">pr</span><span class="p">,</span> <span class="n">prp1</span><span class="p">,</span> <span class="n">prp2</span><span class="p">,</span> <span class="n">prp3</span><span class="p">],</span>
                                  <span class="p">[</span><span class="n">pc</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="n">pc</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sum_right_pos_slope</span> <span class="o">=</span> <span class="n">image</span><span class="p">[[</span><span class="n">prm4</span><span class="p">,</span> <span class="n">prm3</span><span class="p">,</span> <span class="n">prm2</span><span class="p">,</span> <span class="n">prm1</span><span class="p">,</span> <span class="n">pr</span><span class="p">,</span> <span class="n">prp1</span><span class="p">,</span> <span class="n">prp2</span><span class="p">],</span>
                                    <span class="p">[</span><span class="n">pcp1</span><span class="p">,</span> <span class="n">pcp1</span><span class="p">,</span> <span class="n">pcp1</span><span class="p">,</span> <span class="n">pcp1</span><span class="p">,</span> <span class="n">pcp1</span><span class="p">,</span> <span class="n">pcp1</span><span class="p">,</span> <span class="n">pcp1</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># sum the columns of intensity for the negative slop edges</span>
        <span class="n">sum_left_neg_slope</span> <span class="o">=</span> <span class="n">image</span><span class="p">[[</span><span class="n">nrm4</span><span class="p">,</span> <span class="n">nrm3</span><span class="p">,</span> <span class="n">nrm2</span><span class="p">,</span> <span class="n">nrm1</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">nrp1</span><span class="p">,</span> <span class="n">nrp2</span><span class="p">],</span>
                                   <span class="p">[</span><span class="n">ncm1</span><span class="p">,</span> <span class="n">ncm1</span><span class="p">,</span> <span class="n">ncm1</span><span class="p">,</span> <span class="n">ncm1</span><span class="p">,</span> <span class="n">ncm1</span><span class="p">,</span> <span class="n">ncm1</span><span class="p">,</span> <span class="n">ncm1</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sum_mid_neg_slope</span> <span class="o">=</span> <span class="n">image</span><span class="p">[[</span><span class="n">nrm3</span><span class="p">,</span> <span class="n">nrm2</span><span class="p">,</span> <span class="n">nrm1</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">nrp1</span><span class="p">,</span> <span class="n">nrp2</span><span class="p">,</span> <span class="n">nrp3</span><span class="p">],</span>
                                  <span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">nc</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sum_right_neg_slope</span> <span class="o">=</span> <span class="n">image</span><span class="p">[[</span><span class="n">nrm2</span><span class="p">,</span> <span class="n">nrm1</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">nrp1</span><span class="p">,</span> <span class="n">nrp2</span><span class="p">,</span> <span class="n">nrp3</span><span class="p">,</span> <span class="n">nrp4</span><span class="p">],</span>
                                    <span class="p">[</span><span class="n">ncp1</span><span class="p">,</span> <span class="n">ncp1</span><span class="p">,</span> <span class="n">ncp1</span><span class="p">,</span> <span class="n">ncp1</span><span class="p">,</span> <span class="n">ncp1</span><span class="p">,</span> <span class="n">ncp1</span><span class="p">,</span> <span class="n">ncp1</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># calculate the coefficient for the partial area for the positive slopes</span>
        <span class="n">dy_pos_slope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_pae_delta</span><span class="p">(</span><span class="n">sum_left_pos_slope</span><span class="p">,</span> <span class="n">sum_mid_pos_slope</span><span class="p">,</span> <span class="n">sum_right_pos_slope</span><span class="p">,</span>
                                               <span class="n">int_top_pos</span><span class="p">,</span> <span class="n">int_bot_pos</span><span class="p">)</span>

        <span class="c1"># calculate the subpixel edge locations for the positive slope edges</span>
        <span class="n">sp_horiz_edges_pos</span> <span class="o">=</span> <span class="n">horiz_pos_edges</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">sp_horiz_edges_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">dy_pos_slope</span>

        <span class="c1"># calculate the coefficient for the partial area for the positive slopes</span>
        <span class="n">dy_neg_slope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_pae_delta</span><span class="p">(</span><span class="n">sum_left_neg_slope</span><span class="p">,</span> <span class="n">sum_mid_neg_slope</span><span class="p">,</span> <span class="n">sum_right_neg_slope</span><span class="p">,</span>
                                               <span class="n">int_top_neg</span><span class="p">,</span> <span class="n">int_bot_neg</span><span class="p">)</span>

        <span class="c1"># calculate the subpixel edge locations for the negative slope edges</span>
        <span class="n">sp_horiz_edges_neg</span> <span class="o">=</span> <span class="n">horiz_neg_edges</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">sp_horiz_edges_neg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">dy_neg_slope</span>

        <span class="c1"># process the vertical edges</span>

        <span class="c1"># precompute the indices</span>
        <span class="n">pcm4</span> <span class="o">=</span> <span class="n">vert_pos_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">4</span>
        <span class="n">pcm3</span> <span class="o">=</span> <span class="n">vert_pos_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span>
        <span class="n">pcm2</span> <span class="o">=</span> <span class="n">vert_pos_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span>
        <span class="n">pcm1</span> <span class="o">=</span> <span class="n">vert_pos_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">pc</span> <span class="o">=</span> <span class="n">vert_pos_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pcp1</span> <span class="o">=</span> <span class="n">vert_pos_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">pcp2</span> <span class="o">=</span> <span class="n">vert_pos_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span>
        <span class="n">pcp3</span> <span class="o">=</span> <span class="n">vert_pos_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span>
        <span class="n">pcp4</span> <span class="o">=</span> <span class="n">vert_pos_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span>
        <span class="n">prm1</span> <span class="o">=</span> <span class="n">vert_pos_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">pr</span> <span class="o">=</span> <span class="n">vert_pos_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">prp1</span> <span class="o">=</span> <span class="n">vert_pos_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">ncm4</span> <span class="o">=</span> <span class="n">vert_neg_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">4</span>
        <span class="n">ncm3</span> <span class="o">=</span> <span class="n">vert_neg_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span>
        <span class="n">ncm2</span> <span class="o">=</span> <span class="n">vert_neg_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span>
        <span class="n">ncm1</span> <span class="o">=</span> <span class="n">vert_neg_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="n">vert_neg_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ncp1</span> <span class="o">=</span> <span class="n">vert_neg_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">ncp2</span> <span class="o">=</span> <span class="n">vert_neg_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span>
        <span class="n">ncp3</span> <span class="o">=</span> <span class="n">vert_neg_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span>
        <span class="n">ncp4</span> <span class="o">=</span> <span class="n">vert_neg_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span>
        <span class="n">nrm1</span> <span class="o">=</span> <span class="n">vert_neg_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">nr</span> <span class="o">=</span> <span class="n">vert_neg_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nrp1</span> <span class="o">=</span> <span class="n">vert_neg_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># calculate the average intensity on either side of the edge</span>
        <span class="c1"># left of the edge for positive sloped edges</span>
        <span class="n">int_left_pos</span> <span class="o">=</span> <span class="n">image</span><span class="p">[[</span><span class="n">prm1</span><span class="p">,</span> <span class="n">prm1</span><span class="p">,</span> <span class="n">pr</span><span class="p">],</span> <span class="p">[</span><span class="n">pcm3</span><span class="p">,</span> <span class="n">pcm4</span><span class="p">,</span> <span class="n">pcm4</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>

        <span class="c1"># right of the edge for positive sloped edges</span>
        <span class="n">int_right_pos</span> <span class="o">=</span> <span class="n">image</span><span class="p">[[</span><span class="n">prp1</span><span class="p">,</span> <span class="n">prp1</span><span class="p">,</span> <span class="n">pr</span><span class="p">],</span> <span class="p">[</span><span class="n">pcp3</span><span class="p">,</span> <span class="n">pcp4</span><span class="p">,</span> <span class="n">pcp4</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>

        <span class="c1"># left of the edge for negative sloped edges</span>
        <span class="n">int_left_neg</span> <span class="o">=</span> <span class="n">image</span><span class="p">[[</span><span class="n">nrp1</span><span class="p">,</span> <span class="n">nrp1</span><span class="p">,</span> <span class="n">nr</span><span class="p">],</span> <span class="p">[</span><span class="n">ncm3</span><span class="p">,</span> <span class="n">ncm4</span><span class="p">,</span> <span class="n">ncm4</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>

        <span class="c1"># right of the edge for negative sloped edges</span>
        <span class="n">int_right_neg</span> <span class="o">=</span> <span class="n">image</span><span class="p">[[</span><span class="n">nrm1</span><span class="p">,</span> <span class="n">nrm1</span><span class="p">,</span> <span class="n">nr</span><span class="p">],</span> <span class="p">[</span><span class="n">ncp3</span><span class="p">,</span> <span class="n">ncp4</span><span class="p">,</span> <span class="n">ncp4</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>

        <span class="c1"># sum the rows of intensity for the positive slop edges</span>
        <span class="n">sum_top_pos_slope</span> <span class="o">=</span> <span class="n">image</span><span class="p">[[</span><span class="n">prm1</span><span class="p">,</span> <span class="n">prm1</span><span class="p">,</span> <span class="n">prm1</span><span class="p">,</span> <span class="n">prm1</span><span class="p">,</span> <span class="n">prm1</span><span class="p">,</span> <span class="n">prm1</span><span class="p">,</span> <span class="n">prm1</span><span class="p">],</span>
                                  <span class="p">[</span><span class="n">pcm2</span><span class="p">,</span> <span class="n">pcm1</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="n">pcp1</span><span class="p">,</span> <span class="n">pcp2</span><span class="p">,</span> <span class="n">pcp3</span><span class="p">,</span> <span class="n">pcp4</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sum_mid_pos_slope</span> <span class="o">=</span> <span class="n">image</span><span class="p">[[</span><span class="n">pr</span><span class="p">,</span> <span class="n">pr</span><span class="p">,</span> <span class="n">pr</span><span class="p">,</span> <span class="n">pr</span><span class="p">,</span> <span class="n">pr</span><span class="p">,</span> <span class="n">pr</span><span class="p">,</span> <span class="n">pr</span><span class="p">],</span>
                                  <span class="p">[</span><span class="n">pcm3</span><span class="p">,</span> <span class="n">pcm2</span><span class="p">,</span> <span class="n">pcm1</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="n">pcp1</span><span class="p">,</span> <span class="n">pcp2</span><span class="p">,</span> <span class="n">pcp3</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sum_bottom_pos_slope</span> <span class="o">=</span> <span class="n">image</span><span class="p">[[</span><span class="n">prp1</span><span class="p">,</span> <span class="n">prp1</span><span class="p">,</span> <span class="n">prp1</span><span class="p">,</span> <span class="n">prp1</span><span class="p">,</span> <span class="n">prp1</span><span class="p">,</span> <span class="n">prp1</span><span class="p">,</span> <span class="n">prp1</span><span class="p">],</span>
                                     <span class="p">[</span><span class="n">pcm4</span><span class="p">,</span> <span class="n">pcm3</span><span class="p">,</span> <span class="n">pcm2</span><span class="p">,</span> <span class="n">pcm1</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="n">pcp1</span><span class="p">,</span> <span class="n">pcp2</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># sum the rows of intensity for the negative slop edges</span>
        <span class="n">sum_top_neg_slope</span> <span class="o">=</span> <span class="n">image</span><span class="p">[[</span><span class="n">nrm1</span><span class="p">,</span> <span class="n">nrm1</span><span class="p">,</span> <span class="n">nrm1</span><span class="p">,</span> <span class="n">nrm1</span><span class="p">,</span> <span class="n">nrm1</span><span class="p">,</span> <span class="n">nrm1</span><span class="p">,</span> <span class="n">nrm1</span><span class="p">],</span>
                                  <span class="p">[</span><span class="n">ncm4</span><span class="p">,</span> <span class="n">ncm3</span><span class="p">,</span> <span class="n">ncm2</span><span class="p">,</span> <span class="n">ncm1</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">ncp1</span><span class="p">,</span> <span class="n">ncp2</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sum_mid_neg_slope</span> <span class="o">=</span> <span class="n">image</span><span class="p">[[</span><span class="n">nr</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">nr</span><span class="p">],</span>
                                  <span class="p">[</span><span class="n">ncm3</span><span class="p">,</span> <span class="n">ncm2</span><span class="p">,</span> <span class="n">ncm1</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">ncp1</span><span class="p">,</span> <span class="n">ncp2</span><span class="p">,</span> <span class="n">ncp3</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sum_bottom_neg_slope</span> <span class="o">=</span> <span class="n">image</span><span class="p">[[</span><span class="n">nrp1</span><span class="p">,</span> <span class="n">nrp1</span><span class="p">,</span> <span class="n">nrp1</span><span class="p">,</span> <span class="n">nrp1</span><span class="p">,</span> <span class="n">nrp1</span><span class="p">,</span> <span class="n">nrp1</span><span class="p">,</span> <span class="n">nrp1</span><span class="p">],</span>
                                     <span class="p">[</span><span class="n">ncm2</span><span class="p">,</span> <span class="n">ncm1</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">ncp1</span><span class="p">,</span> <span class="n">ncp2</span><span class="p">,</span> <span class="n">ncp3</span><span class="p">,</span> <span class="n">ncp4</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># calculate the coefficient for the partial area for the positive slopes</span>
        <span class="n">dx_pos_slope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_pae_delta</span><span class="p">(</span><span class="n">sum_top_pos_slope</span><span class="p">,</span> <span class="n">sum_mid_pos_slope</span><span class="p">,</span> <span class="n">sum_bottom_pos_slope</span><span class="p">,</span>
                                               <span class="n">int_left_pos</span><span class="p">,</span> <span class="n">int_right_pos</span><span class="p">)</span>

        <span class="c1"># calculate the subpixel edge locations for the positive slope edges</span>
        <span class="n">sp_vert_edges_pos</span> <span class="o">=</span> <span class="n">vert_pos_edges</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">sp_vert_edges_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">dx_pos_slope</span>

        <span class="c1"># calculate the coefficient for the partial area for the positive slopes</span>
        <span class="n">dx_neg_slope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_pae_delta</span><span class="p">(</span><span class="n">sum_top_neg_slope</span><span class="p">,</span> <span class="n">sum_mid_neg_slope</span><span class="p">,</span> <span class="n">sum_bottom_neg_slope</span><span class="p">,</span>
                                               <span class="n">int_left_neg</span><span class="p">,</span> <span class="n">int_right_neg</span><span class="p">)</span>

        <span class="c1"># calculate the subpixel edge locations for the negative slope edges</span>
        <span class="n">sp_vert_edges_neg</span> <span class="o">=</span> <span class="n">vert_neg_edges</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">sp_vert_edges_neg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">dx_neg_slope</span>

        <span class="c1"># return the subpixel edges</span>
        <span class="k">if</span> <span class="n">flip_denoise_flag</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">denoise_flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">sp_horiz_edges_pos</span><span class="p">,</span> <span class="n">sp_horiz_edges_neg</span><span class="p">,</span> <span class="n">sp_vert_edges_pos</span><span class="p">,</span> <span class="n">sp_vert_edges_neg</span><span class="p">])</span></div>

    <span class="k">def</span> <span class="nf">_locate_limbs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">region</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">centroid</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">illum_dir</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method identifies limb points in a region.</span>

<span class="sd">        This method combines the :meth:`identify_pixel_edges`, :meth:`_pixel_limbs`, and a subpixel method based off</span>
<span class="sd">        of the :attr:`.subpixel_method` attribute to determine the pixel level limb points in the region.  It inputs the</span>
<span class="sd">        region being considered, the centroid of the object in the region, and the illumination direction.  It outputs</span>
<span class="sd">        the subpixel limbs from the region.</span>

<span class="sd">        :param region: The imaging region being considered as a 2D array of illumination data</span>
<span class="sd">        :param centroid: The centroid of the blob in the region (typically provided by the opencv connected components</span>
<span class="sd">                         with stats function).</span>
<span class="sd">        :param illum_dir: The illumination direction in the region begin considered</span>
<span class="sd">        :return: the limb locations in the image</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get the pixel level edges</span>
        <span class="p">(</span><span class="n">horiz_edges</span><span class="p">,</span> <span class="n">vert_edges</span><span class="p">,</span>
         <span class="n">horizontal_gradient</span><span class="p">,</span> <span class="n">vertical_gradient</span><span class="p">,</span>
         <span class="n">normalized_gradient</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">identify_pixel_edges</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">split_horizontal_vertical</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_gradient</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># determine the limb edges</span>
        <span class="n">limbs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pixel_limbs</span><span class="p">(</span><span class="n">horiz_edges</span> <span class="o">|</span> <span class="n">vert_edges</span><span class="p">,</span> <span class="n">centroid</span><span class="p">,</span> <span class="n">illum_dir</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">subpixel_method</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;PAE&#39;</span><span class="p">:</span>
            <span class="n">limbs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">refine_edges_pae</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">pixel_edges</span><span class="o">=</span><span class="n">limbs</span><span class="p">,</span>
                                          <span class="n">horizontal_mask</span><span class="o">=</span><span class="n">horiz_edges</span><span class="p">,</span> <span class="n">vertical_mask</span><span class="o">=</span><span class="n">vert_edges</span><span class="p">,</span>
                                          <span class="n">horizontal_gradient</span><span class="o">=</span><span class="n">horizontal_gradient</span><span class="p">,</span> <span class="n">vertical_gradient</span><span class="o">=</span><span class="n">vertical_gradient</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">subpixel_method</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;ZERNIKE_RAMP&quot;</span><span class="p">:</span>
            <span class="n">limbs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">refine_edges_zernike_ramp</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">pixel_edges</span><span class="o">=</span><span class="n">limbs</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># do nothing and just return the pixel limbs</span>
            <span class="n">limbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">limbs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">limbs</span>

<div class="viewcode-block" id="ImageProcessing.refine_edges_zernike_ramp"><a class="viewcode-back" href="../../image_processing/giant.image_processing.ImageProcessing.refine_edges_zernike_ramp.html#giant.image_processing.ImageProcessing.refine_edges_zernike_ramp">[docs]</a>    <span class="k">def</span> <span class="nf">refine_edges_zernike_ramp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pixel_edges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method refines edge locations using the Zernike Ramp method described in</span>
<span class="sd">        https://arc.aiaa.org/doi/full/10.2514/1.A33692?mobileUi=0.</span>

<span class="sd">        The subpixel edge locations are found by computing the inner product between precomputed Zernike moments</span>
<span class="sd">        and the image data around the pixel level edges, and then computing a correction to the pixel level</span>
<span class="sd">        edge (see the paper for details).</span>

<span class="sd">        There is one tuning parameter for this method and that is the half edge width which is specified in the</span>
<span class="sd">        :attr:`.zernike_edge_width` attribute.  This should be set to roughly half the total edge length in pixels,</span>
<span class="sd">        which is typically approximately 1.66*sigma where sigma is the point spread function full width half maximum</span>
<span class="sd">        for the camera.</span>

<span class="sd">        This method returns a 2xn array of subpixel edge points, leaving the pixel level edge points for areas where it</span>
<span class="sd">        failed.</span>

<span class="sd">        :param image: The image which the edge points index into</span>
<span class="sd">        :param pixel_edges: the pixel level edge points to be refined. If none then they will be computed for the whole</span>
<span class="sd">                            image</span>
<span class="sd">        :return: A 2xn array of subpixel edge points (col [x], row[y])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">pixel_edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">edge_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">identify_pixel_edges</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">split_horizontal_vertical</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_gradient</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">pixel_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">edge_mask</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">pixel_edges</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">stops</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">pixel_edges</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="p">[[</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]])</span>

        <span class="n">subpixel_edges</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">edge_width_squared</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zernike_edge_width</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="c1"># loop through each edge</span>
        <span class="k">for</span> <span class="n">edge</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pixel_edges</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">starts</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">stops</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>

            <span class="k">if</span> <span class="p">((</span><span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="c1"># we are too close to the edge so just keep the pixel level point</span>
                <span class="n">subpixel_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">sub_img</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">start</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">stop</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">stop</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

            <span class="c1"># compute the correlation between the moment and the image data</span>
            <span class="n">first_order_imaginary_correlation</span> <span class="o">=</span> <span class="p">(</span><span class="n">FIRST_ORDER_IMAGINARY_MOMENTS</span><span class="o">*</span><span class="n">sub_img</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">first_order_real_correlation</span> <span class="o">=</span> <span class="p">(</span><span class="n">FIRST_ORDER_REAL_MOMENTS</span><span class="o">*</span><span class="n">sub_img</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">second_order_correlation</span> <span class="o">=</span> <span class="p">(</span><span class="n">SECOND_ORDER_MOMENTS</span><span class="o">*</span><span class="n">sub_img</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="c1"># determine the edge normal</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">first_order_imaginary_correlation</span><span class="p">,</span> <span class="n">first_order_real_correlation</span><span class="p">)</span>
            <span class="n">cos_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
            <span class="n">sin_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>

            <span class="c1"># determine the ratio of the correlations</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="n">second_order_correlation</span> <span class="o">/</span> <span class="p">(</span><span class="n">first_order_real_correlation</span><span class="o">*</span><span class="n">cos_angle</span> <span class="o">+</span>
                                                <span class="n">first_order_imaginary_correlation</span><span class="o">*</span><span class="n">sin_angle</span><span class="p">)</span>

            <span class="c1"># solve for the distance along hte normal we need to perturb</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">zernike_edge_width</span> <span class="o">&gt;</span> <span class="mf">0.01</span><span class="p">:</span>
                <span class="n">location</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">edge_width_squared</span> <span class="o">-</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">edge_width_squared</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">edge_width_squared</span><span class="o">*</span><span class="n">ratio</span><span class="p">))</span><span class="o">/</span><span class="n">edge_width_squared</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">location</span> <span class="o">=</span> <span class="n">ratio</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.9</span><span class="p">:</span>
                <span class="n">subpixel_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="o">+</span><span class="mf">2.5</span><span class="o">*</span><span class="n">location</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cos_angle</span><span class="p">,</span> <span class="n">sin_angle</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># if we&#39;re here then we didn&#39;t get a good fit</span>
                <span class="n">subpixel_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">subpixel_edges</span><span class="p">)</span><span class="o">.</span><span class="n">T</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_pixel_limbs</span><span class="p">(</span><span class="n">edge_mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">centroid</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">illum_dir</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">step</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method identifies pixel level limb points from a binary image of edge points.</span>

<span class="sd">        A limb is defined as the first edge point encountered by a scan vector in the direction of the illumination</span>
<span class="sd">        direction.  The limb points are extracted by (1) selecting starting locations for the scan vectors along a line</span>
<span class="sd">        perpendicular to the illumination direction spaced `step` pixels apart and then (2) scanning from these starting</span>
<span class="sd">        points in the illumination direction to identify the first edge point that is along the line.</span>

<span class="sd">        This method inputs a binary image with true values in the pixels which contain edges, the centroid of the object</span>
<span class="sd">        being considered in the binary image, the illumination direction, and the step size. It outputs the pixel level</span>
<span class="sd">        edges as a 2D array with the x values in the first row and the y values in the second row.</span>

<span class="sd">        :param edge_mask: A binary image with true values in the pixels containing edges.</span>
<span class="sd">        :param centroid: The centroid of the object being considered</span>
<span class="sd">        :param illum_dir: the illumination direction in the `edge_mask` image</span>
<span class="sd">        :param step: The step size to sample for limb points at</span>
<span class="sd">        :return: The pixel level limb locations as a 2D array with the x values in the first row and the y values in the</span>
<span class="sd">                 second row</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># identify the pixel level edges</span>
        <span class="n">edge_y</span><span class="p">,</span> <span class="n">edge_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">edge_mask</span><span class="p">)</span>
        <span class="n">edge_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">edge_x</span><span class="p">,</span> <span class="n">edge_y</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">edge_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">100000</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        
        <span class="c1"># determine how far we need to travel from the centroid to start our scan lines</span>
        <span class="n">line_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">edge_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>

        <span class="c1"># determine the maximum distance an edge can be from a scan line for it to belong to that scan line</span>
        <span class="n">max_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">edge_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">/</span><span class="n">edge_y</span><span class="o">.</span><span class="n">size</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
        <span class="c1"># max_distance = 1.1 * np.sqrt(2) * step / 2</span>

        <span class="c1"># determine the direction to offset our scan stars</span>
        <span class="n">perpendicular_direction</span> <span class="o">=</span> <span class="n">illum_dir</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">perpendicular_direction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># get the middle of the start positions of our scan lines</span>
        <span class="c1"># middle start position of scan</span>
        <span class="n">scan_start_middle</span> <span class="o">=</span> <span class="n">centroid</span> <span class="o">-</span> <span class="n">line_length</span> <span class="o">*</span> <span class="n">illum_dir</span>

        <span class="c1"># choose scan starting locations</span>
        <span class="n">scan_starts</span> <span class="o">=</span> <span class="n">scan_start_middle</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">line_length</span><span class="p">,</span> <span class="n">line_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">perpendicular_direction</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># compute the vector from the scan starts to the potential limb points</span>
        <span class="n">scan_start2edge_points</span> <span class="o">=</span> <span class="n">edge_points</span> <span class="o">-</span> <span class="n">scan_starts</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># compute the distance from the edge points to the scan lines by taking the projection of the edge points</span>
        <span class="c1"># onto the scan line</span>
        <span class="n">edge_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">perpendicular_direction</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">@</span> <span class="n">scan_start2edge_points</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># compute the distance from the scan start to each potential limb point</span>
        <span class="n">scan_start2edge_points_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">scan_start2edge_points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># locate which points are within the maximum distance from the scan line</span>
        <span class="n">limb_points_check</span> <span class="o">=</span> <span class="n">edge_distances</span> <span class="o">&lt;</span> <span class="n">max_distance</span>

        <span class="c1"># choose the closest edge point from the scan starts</span>
        <span class="n">limbs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">scan_line</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">scan_starts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">lpc</span> <span class="o">=</span> <span class="n">limb_points_check</span><span class="p">[</span><span class="n">scan_line</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">lpc</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">potential_limbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">limb_points_check</span><span class="p">[</span><span class="n">scan_line</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">real_limb</span> <span class="o">=</span> <span class="n">potential_limbs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">scan_start2edge_points_dist</span><span class="p">[</span><span class="n">scan_line</span><span class="p">,</span> <span class="n">lpc</span><span class="p">])]</span>

                <span class="n">edges</span> <span class="o">=</span> <span class="n">edge_points</span><span class="p">[:,</span> <span class="n">real_limb</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">limbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">limbs</span><span class="p">:</span>
            <span class="n">limbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">limbs</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="k">return</span> <span class="n">limbs</span></div>
</pre></div>

          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2021 United States Government.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>